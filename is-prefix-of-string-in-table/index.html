<!DOCTYPE html>
<html>
    <!-- vim:set tw=100 ts=8 sw=4 et                                                            :-->
    <head>
        <title>Is Prefix Of String In Table?  A Journey Into SIMD String Processing.</title>
        <meta name="msvalidate.01" content="E828541C73A98C315E3D6B8C88EF6057" />
        <meta name="viewport" content="width=device-width, initial-scale=0.65, maximum-scale=1.0" />

        <!-- https://www.google.com/fonts#UsePlace:use/Collection:Lato:200,300,300italic -->
        <!--
        <meta name="viewport" content="width=device-width, min-width=1100px, initial-scale=0.7, maximum-scale=1.0, shrint-to-fit=no" />
        <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:200,300,300italic">
        <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:300,300i,400,400i">
        -->
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet">
        <link rel="stylesheet" href="//oss.maxcdn.com/normalize/3.0.1/normalize.min.css">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
        <link rel="stylesheet" href="../prism.css">
        <link rel="stylesheet" href="../home.css">
        <link rel="stylesheet" href="page.css">
        <script src="//oss.maxcdn.com/jquery/2.1.1/jquery.min.js"></script>
        <script src="../prism.js"></script>
        <script src="../home.js"></script>
        <script src="page.js"></script>
    </head>
    <!--

        TODO:

            - Syntax highlighting
                - Review asm keywords.
                - Tweak/extend colorscheme.
            - Add screenshots of stepping through the routine for:
                - C version
                - Asm version
            - Zip up everything and provide a download for it on github.
            - Add a section on release build vs PGO.
            - Benchmark section.
                - How it works.
                - How to build/download perhaps.
            - Add comparison section of all the various iterations
                - Diagram depicting sequence of events things were written in.
                - Updated graphs of performance.
                - Diffs to previous version of the various changes to code
            - Embed a speakerdeck deck graphically depicting how the algorithm works.
            - Interface section.
            - Fix the image alignment issues on high DPI/Retina/font-scaling resolutions.

    -->
    <body>

        <header class="header">
            <div class="header-logo" href="#">
                <strong>T</strong>rent <strong>N</strong>elson
            </div>
            <ul class="header-links">
                <li><a href="#home"><i class="fa fa-home"></i>Is Prefix Of String In Table?</a></li>
                <li><a href="https://github.com/tpn" target="_blank"><i class="fa fa-github"></i> GitHub</a></li>
                <li><a href="https://twitter.com/trentnelson" class="twitter-follow-button" data-show-count="false">Follow @trentnelson</a></li>
            </ul>
        </header>

        <a class="xref" name="home"></a>
        <section class="section section-hero">
            <div class="container">
                <h1>
                    Is Prefix Of String In Table?
                </h1>
                <h3>
                    A Journey Into SIMD String Processing.
                </h3>
            </div>
        </section>

        <section class="section section-summary">
            <div class="container">

                <small>
                    Current status: <strong>draft</strong>.  Updated: 19th April, 2018.
                    Target publish date: <del>20th April, 2018</del>23rd April, 2018.
                    Thanks to <a href="https://twitter.com/rygorous">Fabian Giesen</a>,
                    <a href="https://twitter.com/pshufb">Wojciech Mu&#322;a</a>,
                    <a href="https://twitter.com/geofflangdale">Geoff Langdale</a>,
                    <a href="https://twitter.com/lemire">Daniel Lemire</a>, and
                    <a href="https://twitter.com/KendallWillets">Kendall Willets</a>
                    for their valuable
                    <a href="https://twitter.com/trentnelson/status/985715037934440448">feedback</a>
                    on an early draft of this article.
                </small>

                <hr/>
                <h2>TL;DR</h2>
                <p>

                    Goal: given a string, determine if it prefix-matches a set of known strings as
                    fast as possible.  That is, in a set of known strings, do any of them prefix
                    match the incoming search string?

                </p>
                <p>

                    A reference implementation was written in C as a <a
                    href="#IsPrefixOfCStrInArray">baseline</a>, which simply looped
                    through an array of strings, comparing each one, byte-by-byte, looking for a
                    prefix match.  Prefix match performance ranged from 28 CPU cycles to 130, and
                    negative match performance was around 74 cycles.

                </p>
                <p>

                    A SIMD-friendly C structure called <a href="#STRING_TABLE">STRING_TABLE</a> was
                    derived.  It is optimized for up to 16 strings, ideally of length less than or
                    equal 16 characters.  The table is created from the set of known strings
                    up-front; it is sorted by length, ascending, and a unique character (with
                    regards to other characters at the same byte offset) is then extracted, along
                    with its index.  A 16 byte character array, <a
                    href="#STRING_SLOT">STRING_SLOT</a>, is used to capture the unique characters.
                    A 16 element array of unsigned characters, SLOT_INDEX, is used to capture the
                    index.  Similarly, lengths are stored in the same fashion via SLOT_LENGTHS.
                    Finally, a 16 element array of STRING_SLOTs is used to capture up to the first
                    16 bytes of each string in the set.

                </p>

                <p>

                    An example of the memory layout of the STRING_TABLE structure at run time using
                    sample <a href="#ntfs-reserved-names">test data</a>, is depicted below.  Note
                    the width of each row is 16 bytes (128 bits), which is the size of an XMM register.

                </p>

                <a href="StringTable.svg" target="_blank">
                    <img class="svg-image" src="StringTable.svg"/>
                </a>

                <!--
                <picture>
                    <source srcset="StringTableLayout2.png"/>
                    <img width="1042px" height="675px" srcset="StringTableLayout2.png"/>
                </picture>
                -->

                <p>
                    The layout of the STRING_TABLE structure allows us to determine if a given
                    search string <strong>does not</strong> prefix match all 16 strings at once
                    in 12 assembly instructions.  This breaks down into 18 &#181;ops, with a
                    block throughput of 3.48 cycles on Intel's Skylake architecture:
                </p>

                <div class="tab-box language box-intro">
                    <ul class="tabs">
                        <li data-content="content-intro-nasm">Assembly</li>
                        <li data-content="content-intro-iaca">IACA</li>
                    </ul>
                    <div class="content">
<pre class="code content-intro-nasm"><code class="language-nasm">
mov      rax,  String.Buffer[rdx]           ; Load address of string buffer.
vpbroadcastb xmm4, String.Length[rdx]       ; Broadcast string length.
vmovdqa  xmm3, StringTable.Lengths[rcx]     ; Load table lengths.
vmovdqu  xmm0, String.Buffer[rdx]           ; Load search buffer.
vpcmpgtb xmm1, xmm3, xmm4                   ; Identify slots &gt; string length.
vpshufb  xmm5, xmm0, StringTable.UniqueIndex[rcx] ; Rearrange string by unique index.
vpcmpeqb xmm5, xmm5, StringTable.UniqueChars[rcx] ; Compare rearranged to unique chars.
vptest   xmm1, xmm5                         ; Unique slots AND (!long slots).
jnc      Short Pfx10                        ; CY=0, continue with routine.
xor      eax, eax                           ; CY=1, no match.
not      al                                 ; al = -1 (NO_MATCH_FOUND).
ret                                         ; Return NO_MATCH_FOUND.
</code></pre>

<pre class="code content-intro-iaca"><code class="language-nasm">
S:\Source\tracer>iaca x64\Release\StringTable2.dll
Intel(R) Architecture Code Analyzer Version -  v3.0-28-g1ba2cbb build date: 2017-10-23;17:30:24
Analyzed File -  x64\Release\StringTable2.dll
Binary Format - 64Bit
Architecture  -  SKL
Analysis Type - Throughput

Throughput Analysis Report
--------------------------
Block Throughput: 3.48 Cycles       Throughput Bottleneck: FrontEnd
Loop Count:  24
Port Binding In Cycles Per Iteration:
----------------------------------------------------------------------------
| Port   |  0  - DV  |  1  |  2  - D   |  3  - D   |  4  |  5  |  6  |  7  |
----------------------------------------------------------------------------
| Cycles | 2.0   0.0 | 1.0 | 3.5   3.5 | 3.5   3.5 | 0.0 | 3.0 | 2.0 | 0.0 |
----------------------------------------------------------------------------

DV - Divider pipe (on port 0)
D - Data fetch pipe (on ports 2 and 3)
* - instruction micro-ops not bound to a port
^ - Micro Fusion occurred

|    | Ports pressure in cycles        | |
|&#181;ops|0DV| 1 | 2 - D | 3 - D |4| 5 | 6 |7|
-------------------------------------------
| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | mov rax, qword ptr [rdx+0x8]
| 2  |   |   |0.5 0.5|0.5 0.5| |1.0|   | | vpbroadcastb xmm4, byte ptr [rdx]
| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | vmovdqa xmm3, xmmword ptr [rcx+0x20]
| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | vmovdqu xmm0, xmmword ptr [rax]
| 1  |1.0|   |       |       | |   |   | | vpcmpgtb xmm1, xmm3, xmm4
| 2^ |   |   |0.5 0.5|0.5 0.5| |1.0|   | | vpshufb xmm5, xmm0, xmmword ptr [rcx+0x10]
| 2^ |   |1.0|0.5 0.5|0.5 0.5| |   |   | | vpcmpeqb xmm5, xmm5, xmmword ptr [rcx]
| 2  |1.0|   |       |       | |1.0|   | | vptest xmm1, xmm5
| 1  |   |   |       |       | |   |1.0| | jnb 0x10
| 1* |   |   |       |       | |   |   | | xor eax, eax
| 1  |   |   |       |       | |   |1.0| | not al
| 3^ |   |   |0.5 0.5|0.5 0.5| |   |   | | ret
Total Num Of &#181;ops: 18
</code></pre>

                    </div>
                </div>

                <p>

                    Ten iterations of a function named IsPrefixOfStringInTable were authored.  The
                    <a href="#IsPrefixOfStringInTable_10">tenth</a> and final iteration was the
                    fastest, prefix matching in as little as 19 cycles &mdash; a 4x improvement over
                    the baseline.  Negative matching took 11 cycles &mdash; a 6.7x improvement.

                </p>

                <picture>
                    <source srcset="PrefixMatchPerformance.png"/>
                    <img width="815px" height="660px" srcset="PrefixMatchPerformance.png"/>
                </picture>

                <p>

                    An <a
                    href="#IsPrefixOfStringInTable_x64_2">assembly</a>
                    version of the algorithm was authored specifically to optimize for the negative
                    match case, and was able to do so in as little as 8 cycles, representing a 9x
                    improvement over the baseline.  (It was a little bit slower than the fastest
                    C routine in the case of prefix matches, though, as can be seen above.)

                </p>

                <picture>
                    <source srcset="NegativeMatchPerformance.png"/>
                    <img width="817px" height="657px" srcset="NegativeMatchPerformance.png"/>
                </picture>

                <p>

                    <small>
                    (Feedback for an early draft of this article was then solicited on <a
                    href="https://twitter.com/trentnelson/status/985715037934440448">Twitter</a>,
                    resulting in three more iterations of the C version, and two more iterations
                    of the assembly version.  The PGO build of the fastest C version (thirteenth
                    attempt) prefix matched in about 16 cycles (and also had the best "worst case
                    input string" performance (where three slots needed comparison), negative
                    matching in about 26 cycles).  The fifth iteration of the assembly version
                    negative matched in about 6 cycles, a 3 and 1 cycle improvement, respectively.
                    Now, I could re-do these intro graphs, or you could just picture the ones above
                    with a few more bars, slightly shorter in length than their nearest counterparts,
                    and then I won't have to.)
                    </small>

                </p>

                <!--
                <div class="cols-2">
                    <div>
                        <script async class="speakerdeck-embed" data-id="feadc0a06e770130c56622000a9f1084" src="//speakerdeck.com/assets/embed.js"></script>
                    </div>
                    <div>
                        <script async class="speakerdeck-embed" data-id="606aa4e02d30013103c12a5f68b843a3" src="//speakerdeck.com/assets/embed.js"></script>
                    </div>
                    <div>
                        <script async class="speakerdeck-embed" data-id="feadc0a06e770130c56622000a9f1084" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
                    </div>
                    <div>
                        <script async class="speakerdeck-embed" data-id="606aa4e02d30013103c12a5f68b843a3" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
                    </div>
                </div>
                -->

            </div>
        </section>
        <hr/>

        <section class="section section-toc">
            <div class="container">

                <h2>Contents</h2>

                <small><em>(Work In Progress)</em></small></h2>

                <p>
                    <ul class="toc-list">
                        <li>
                            <a href="#background">Background</a>
                            <ul class="toc-list-2">
                                <li><a href="#tracer-project">The Tracer Project</a></li>
                                <li><a href="#baseline">Baseline C Implementation</a></li>
                                <li>
                                    <a href="#proposed-interface">Proposed Interface</a>
                                    <ul>
                                        <li>
                                            The <a href="#IsPrefixOfStringInTable">
                                            IsPrefixOfStringInTable</a> function.
                                        </li>
                                        <li>
                                            The <a href="#STRING_MATCH">STRING_MATCH</a> structure.
                                        </li>
                                    </ul>
                                </li>
                                <li><a href="#test-data">The Test Data</a></li>
                                <li>
                                    <a href="#requirements-and-design-decisions">
                                        Requirements and Design Decisions
                                    </a>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="#data-structures">The Data Structures</a>
                            <ul class="toc-list-2">
                                <li>
                                    <a href="#STRING_TABLE">STRING_TABLE</a>
                                    (See also <a href="#CreateStringTable">CreateStringTable</a>.)
                                </li>
                                    <li><a href="#STRING_ARRAY">STRING_ARRAY</a></li>
                                    <li><a href="#STRING_SLOT">STRING_SLOT</a></li>
                                    <li><a href="#SLOT_INDEX">SLOT_INDEX</a></li>
                                    <li><a href="#SLOT_LENGTHS">SLOT_LENGTHS</a></li>
                            </ul>
                        </li>
                        <li>
                            <a href="#algorithm">The Algorithm</a>
                        </li>

                        <!--
                        <li>
                            <a href="#implementation">The Implementation(s)</a>
                            <ul class="toc-list-2">
                                <li>
                                    The <a href="#IsPrefixOfStringInTable">IsPrefixOfStringInTable</a> function signature.
                                    (TODO)
                                </li>
                                <li><a href="#how-it-works">How It Works</a> (TODO)</li>
                                <li>
                                    First round.
                                    <ul class="toc-list-3">
                                        <li>
                                            Fastest C version: <a href="#IsPrefixOfStringInTable_10">IsPrefixOfStringInTable_10</a>.
                                        </li>
                                        <li>
                                            Fastest assembly version: <a
                                            href="#IsPrefixOfStringInTable_x64_2">IsPrefixOfStringInTable_x64_2</a>.
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    Second round, after internet feedback.
                                    <ul class="toc-list-3">
                                        <li>
                                            Fastest C version: <a href="#IsPrefixOfStringInTable_10">IsPrefixOfStringInTable_10</a>.
                                        </li>
                                        <li>
                                            Fastest assembly version: <a
                                            href="#IsPrefixOfStringInTable_x64_2">IsPrefixOfStringInTable_x64_2</a>.
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="#benchmark">The Benchmark</a> (TODO)
                        </li>
                        -->
                        <li>
                            <a href="#other-applications">Other Applications</a>
                        </li>
                        <li>
                            <a href="#appendix">Appendix</a>
                            <ul class="toc-list-2">
                                <li>The <a href="#CreateStringTable">CreateStringTable</a> implementation.</li>
                                <li>A list of all C <a href="#typedefs">typedefs</a> referenced in the article.</li>
                            </ul>
                        </li>
                    </ul>
                </p>
            </div>
        </section>
        <hr/>

        <section class="section section-body">
            <div class="container">

                <h1>The Background</h1>

                <h2>The Tracer Project</h2>
                <p>

                    One of the frustrations I had with existing Python profilers was that there was
                    no easy or efficient means to filter or exclude trace information based on the module
                    name of the code being executed.  I tackled this in my
                    <a href="https://github.com/tpn/tracer">tracer</a> project, which allows you to
                    set an environment variable named TRACER_MODULE_NAMES to restrict which modules
                    should be traced, e.g.:
                    <small><pre>set TRACER_MODULE_NAMES=myproject1;myproject2;myproject3.subproject;numpy;pandas;scipy</pre></small>

                </p>

                <p>

                    If the code being executed is coming from the module
                    <small><code>myproject3.subproject.foo</code></small>,
                    then we need to trace it, as that string <strong>prefix matches</strong>
                    the third entry on our list.

                </p>

                <p>

                    This article details the custom data structure and algorithm I came up with in
                    order to try and solve the prefix matching problem more optimally with a SIMD
                    approach.  The resulting <a
                    href="https://github.com/tpn/tracer/tree/master/StringTable2">StringTable</a>
                    component is used extensively within the tracer project, and as such, must
                    conform to unique constraints such as no use of the C runtime library and
                    allocating all memory through TraceStore-backed allocators.  Thus, it's not
                    really something you'd drop in to your current project in its current form.
                    Hopefully, the article still proves to be interesting.

                </p>

                <small>

                    <p>

                        Note: the code samples provided herein are copied directly from the tracer
                        project, which is written in C and assembly, and uses the Pascal-esque
                        <em>Cutler Normal Form</em> style for C.  If you're used to the more UNIX-style
                        <a href="https://www.freebsd.org/cgi/man.cgi?query=style&sektion=9">
                        <em>Kernel Normal Form</em></a> of C, it's quite like that, except that it's
                        absolutely nothing like that, and all these code samples will probably be
                        very jarring.  And if that doesn't put you off, there's zero support at the
                        moment for running on anything other than Windows, including these
                        benchmarks.  How's that for alienating most of your article's audience up
                        front!

                    <p>

                </small>

                <a class="xref" name="IsPrefixOfCStrInArray"></a>
                <h2>Baseline C Implementation</h2>

                <p>

                    The simplest way of solving this in C is to have an array of C strings (i.e.
                    NULL terminated byte arrays), then for each string, loop through byte by byte
                    and see if it prefix matches the search string.

                </p>

                <div class="tab-box language box-simple">
                    <ul class="tabs">
                        <li data-content="content-simple-cnf">Baseline (Cutler Normal Form)</li>
                        <li data-content="content-simple-knf">Baseline (Kernel Normal Form)</li>
                    </ul>
                    <div class="content">
<pre class="code content-simple-cnf"><code class="language-c">
//
// Declare a set of module names to be used as a string array.
//

CONST PCSZ ModuleNames[] = {
    "myproject1",
    "myproject2",
    "myproject3.subproject",
    "numpy",
    "pandas",
    "scipy",
    NULL,
};

//
// Define the function pointer typedef.
//

typedef
STRING_TABLE_INDEX
(IS_PREFIX_OF_CSTR_IN_ARRAY)(
    _In_ PCSZ *StringArray,
    _In_ PCSZ String,
    _Out_opt_ PSTRING_MATCH Match
    );
typedef IS_PREFIX_OF_CSTR_IN_ARRAY *PIS_PREFIX_OF_CSTR_IN_ARRAY;

//
// Forward declaration.
//

IS_PREFIX_OF_CSTR_IN_ARRAY IsPrefixOfCStrInArray;

_Use_decl_annotations_
STRING_TABLE_INDEX
IsPrefixOfCStrInArray(
    PCSZ *StringArray,
    PCSZ String,
    PSTRING_MATCH Match
    )
{
    PCSZ Left;
    PCSZ Right;
    PCSZ *Target;
    ULONG Index = 0;
    ULONG Count;

    for (Target = StringArray; *Target != NULL; Target++, Index++) {
        Count = 0;
        Left = String;
        Right = *Target;

        while (*Left &amp;&amp; *Right &amp;&amp; *Left++ == *Right++) {
            Count++;
        }

        if (Count &gt; 0 &amp;&amp; !*Right) {
            if (ARGUMENT_PRESENT(Match)) {
                Match-&gt;Index = (BYTE)Index;
                Match-&gt;NumberOfMatchedCharacters = (BYTE)Count;
                Match-&gt;String = NULL;
            }
            return (STRING_TABLE_INDEX)Index;
        }
    }

    return NO_MATCH_FOUND;
}

</code></pre>
<pre class="code content-simple-knf"><code class="language-c">
const char *module_names[] = {
    "myproject1",
    "myproject2",
    "myproject3.subproject",
    "numpy",
    "pandas",
    "scipy",
    0,
};

struct string_match {
    /* Index of the match. */
    unsigned char index;

    /* Number of characters matched. */
    unsigned char number_of_chars_matched;

    /* Pad out to an 8-byte boundary. */
    unsigned short padding[3];

    /* Pointer to the string that was matched. */
    char *str;
};

unsigned char
is_prefix_of_c_str_in_array(const char **array,
                            const char *str,
                            struct string_match *match)
{
    char *left, *right, **target;
    unsigned int c, i = 0;

    for (target = array; target; target++, i++) {
        c = 0;
        left = str;
        right *target;
        while (*left &amp;&amp; *right &amp;&amp; *left++ == *right) {
            c++;
        }
        if (c &gt; 0 &amp;&amp; !*right) {
            if (match) {
                match-&gt;index = i;
                match-&gt;chars_matched = c;
                match-&gt;str = target[i];
            }
            return i;
        }
    }

    return -1;
}
</code></pre>
                    </div>
                </div>

                <p>

                    Another type of code pattern that the string table attempts to replace is
                    anything that does a lot of if/else if/else if-type string comparisons to
                    look for keywords.  For example, in the
                    <a href="https://github.com/id-Software/Quake-III-Arena/blob/dbe4ddb10315479fc00086f08e25d968b4b43c49/q3asm/q3asm.c#L609">
                    Quake III</a> source, there's some symbol/string processing logic that looks
                    like this:

                </p>

<pre class="code content-q3"><code class="language-c">
	// call instructions reset currentArgOffset
	if ( !strncmp( token, "CALL", 4 ) ) {
		EmitByte( &amp;segment[CODESEG], OP_CALL );
		instructionCount++;
		currentArgOffset = 0;
		return;
	}

	// arg is converted to a reversed store
	if ( !strncmp( token, "ARG", 3 ) ) {
		EmitByte( &amp;segment[CODESEG], OP_ARG );
		instructionCount++;
		if ( 8 + currentArgOffset >= 256 ) {
			CodeError( "currentArgOffset >= 256" );
			return;
		}
		EmitByte( &amp;segment[CODESEG], 8 + currentArgOffset );
		currentArgOffset += 4;
		return;
	}

	// ret just leaves something on the op stack
	if ( !strncmp( token, "RET", 3 ) ) {
		EmitByte( &amp;segment[CODESEG], OP_LEAVE );
		instructionCount++;
		EmitInt( &amp;segment[CODESEG], 8 + currentLocals + currentArgs );
		return;
	}

	// pop is needed to discard the return value of
	// a function
	if ( !strncmp( token, "pop", 3 ) ) {
		EmitByte( &amp;segment[CODESEG], OP_POP );
		instructionCount++;
		return;
	}

        ...
</code></pre>

                <p>

                    An example of using the string table approach for this problem is discussed
                    in the <a href="#other-applications">Other Applications</a> section.

                </p>

                <a class="xref" name="proposed-interface"></a>

                <h3>The Proposed Interface</h3>

                <p>

                    Let's take a look at the interface we're proposing, the
                    <strong>IsPrefixOfStringInTable</strong> function, that this article is based upon:

                </p>

                <a class="xref" name="IsPrefixOfStringInTable"></a>

<pre class="code content-proposed-interface-cnf"><code class="language-c">
//
// Our string table index is simply a char, with -1 indicating no match found.
//

typedef CHAR STRING_TABLE_INDEX;
#define NO_MATCH_FOUND -1

typedef
STRING_TABLE_INDEX
(IS_PREFIX_OF_STRING_IN_TABLE)(
    _In_ PSTRING_TABLE StringTable,
    _In_ PSTRING String,
    _Out_opt_ PSTRING_MATCH StringMatch
    );
typedef IS_PREFIX_OF_STRING_IN_TABLE *PIS_PREFIX_OF_STRING_IN_TABLE;

IS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable;

_Use_decl_annotations_
STRING_TABLE_INDEX
IsPrefixOfStringInTable(
    PSTRING_TABLE StringTable,
    PSTRING String,
    PSTRING_MATCH Match
    )
/*++

Routine Description:

    Searches a string table to see if any strings "prefix match" the given
    search string.  That is, whether any string in the table "starts with
    or is equal to" the search string.

Arguments:

    StringTable - Supplies a pointer to a STRING_TABLE struct.

    String - Supplies a pointer to a STRING struct that contains the string to
        search for.

    Match - Optionally supplies a pointer to a variable that contains the
        address of a STRING_MATCH structure.  This will be populated with
        additional details about the match if a non-NULL pointer is supplied.

Return Value:

    Index of the prefix match if one was found, NO_MATCH_FOUND if not.

--*/
</code></pre>

                <p>

                    All implementations discussed in this article adhere to that function signature.
                    The <a href="#STRING_TABLE">STRING_TABLE</a> structure will be discussed shortly.

                </p>

                <p>

                    The STRING_MATCH structure is used to optionally communicate information about
                    the prefix match back to the caller.  The index and characters matched fields
                    are often very useful when using the string table for text parsing; see the <a
                    href="#other-applications">other applications</a> section below for an example.

                </p>

                <p>

                    The structure is defined as follows:

                </p>

                <a class="xref" name="STRING_MATCH"></a>

<pre class="code content-string-match"><code class="language-c">
//
// This structure is used to communicate matches back to the caller.
//

typedef struct _STRING_MATCH {

    //
    // Index of the match.
    //

    BYTE Index;

    //
    // Number of characters matched.
    //

    BYTE NumberOfMatchedCharacters;

    //
    // Pad out to 8-bytes.
    //

    USHORT Padding[3];

    //
    // Pointer to the string that was matched.  The underlying buffer will
    // stay valid for as long as the STRING_TABLE struct persists.
    //

    PSTRING String;

} STRING_MATCH, *PSTRING_MATCH, **PPSTRING_MATCH;
C_ASSERT(sizeof(STRING_MATCH) == 16);
</code></pre>

                <a class="xref" name="test-data"></a>
                <h2>The Test Data</h2>

                <p>

                    Instead of using some arbitrary Python module names, this article is going to
                    focus on a string table constructed out of a set of 16 strings that represent
                    reserved names of the NTFS file system, at least when it was first released
                    way back in the early 90s.

                </p>

                <p>

                    This list is desirable as it has good distribution of characters, there is
                    a good mix of both short and long entries, plus one oversized one
                    ($INDEX_ALLOCATION, which clocks in at 17 characters), and almost all
                    strings lead with a common character (the dollar sign), preventing a simple
                    <em>first character</em> optimization used by <a href="https://github.com/tpn/tracer/blob/2018-04-18.1/StringTable/StringTable.h#L324">
                    the initial version of the StringTable component I wrote in 2016</a>.

                </p>
                <p>

                    So the scenario we'll be emulating, in this case, is that we've just been passed
                    a filename for creation, and we need to check if it prefix matches any of the
                    reserved names.

                </p>

                <p>

                    Here's the full list of NTFS names we'll be using.  We're assuming 8-bit ASCII
                    encoding (no UTF-8) and case sensitive.  (If this were actually the NT kernel,
                    we'd need to use wide characters with UTF-16 enconding, and be
                    case-insensitive.)

                </p>

                <a class="xref" name="ntfs-reserved-names"></a>
                <h3>NTFS Reserved Names</h3>

                <p>
                    <ul>
                        <li>$AttrDef</li>
                        <li>$BadClus</li>
                        <li>$Bitmap</li>
                        <li>$Boot</li>
                        <li>$Extend</li>
                        <li>$LogFile</li>
                        <li>$MftMirr</li>
                        <li>$Mft</li>
                        <li>$Secure</li>
                        <li>$UpCase</li>
                        <li>$Volume</li>
                        <li>$Cairo</li>
                        <li>$INDEX_ALLOCATION</li>
                        <li>$DATA</li>
                        <li>????</li>
                        <li>.</li>
                    </ul>
                </p>

                <p>

                    The ordering is important in certain cases.  For example, when you have
                    overlapping strings, such as $MftMirr, and $Mft, you should put the longest
                    strings first.  They will be matched first, and as our routine terminates upon
                    the first successful prefix match &mdash; if a longer string resided after a
                    shorter one, it would never get detected.

                </p>

                <p>

                    Let's review some guiding design requirements and cover some of the design
                    decisions I made, which should help shape your understanding of the
                    implementation.

                </p>

                <a class="xref" name="requirements-and-design-decisions"></a>
                <h2>Requirements and Design Decisions</h2>

                <p>

                    The STRING struct will be used to capture incoming search strings as well as the
                    representation of any strings registered in the table (or more accurately, in
                    the corresponding StringArray structure associated with the string table.

                </p>
<pre class="code content-string-struct"><code class="language-c">
//
// The STRING structure used by the NT kernel.  Our STRING_ARRAY structure
// relies on an array of these structures.  We never pass raw 'char *'s
// around, only STRING/PSTRING structs/pointers.
//

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    ULONG  Padding;
    PCHAR Buffer;
} STRING, *PSTRING;
typedef const STRING *PCSTRING;
</code></pre>

                <p>

                    The design should optimize for string lengths less than or equal to 16.  Lengths
                    greater than 16 are permitted, up to 128 bytes, but they incur more overhead during
                    the prefix lookup.

                </p>

                <p>

                    The design should prioritize the fast-path code where there is no match for a
                    given search string.  Being able to terminate the search as early as possible is
                    ideal.

                </p>

                <p>

                    The performance hits taken by unaligned data access are non-nelgible, especially
                    when dealing with XMM/YMM loads.  Pay special care to alignment constrants and
                    make sure that everything under our control is aligned on a suitable boundary.

                    (The only thing we can't really control in the real world is the alignment of
                    the incoming search string buffer, which will often be at undesirable alignments
                    like 2, 4, 6, etc.  Our test program explicitly aligns the incoming search
                    strings on 32-byte boundaries to avoid the penalties associated with unaligned
                    access.)

                </p>

                <p>

                    The string table is geared toward a single-shot build.  Once you've created it
                    with a given string array or used a delimited environment variable, that's it.
                    There are no AddString() or RemoveString() routines.  The order you provided the
                    strings in will be the same order the table uses &mdash; no re-ordering will be
                    done.  Thus, for prefix matching purposes, if two strings share a common prefix,
                    the longer one should go first, as the prefix search routine will check it first.

                </p>

                <p>

                    Only single matches are performed; the first match that qualifies as a prefix
                    match (target string in table had length less than or equal to the search
                    string, and all of its characters matched).  There is no support for obtaining
                    multiple matches &mdash; if you've constructed your string tables properly
                    (no duplicate or incorrectly-ordered overlapping fields), you shouldn't need to.

                </p>

                <p>
                    So, to summarise, the design guidelines are as follows.

                    <ul>

                        <li>

                            Prioritize fast-path exit in the non-matched case.  (I refer to this as
                            <strong>negative matching</strong> in a lot of places.)

                        </li>

                        <li>

                            Optimize for up to 16 string slots, where each slot has up to 16
                            characters, ideally.  It can have up to 128 in total, however, any bytes
                            outside of the first sixteen live in the string array structure
                            supporting the string table (accessible via pStringArray).

                        </li>

                        <li>

                            If a slot is longer than 16 characters, optimize for the assumption that
                            it won't be *that* much longer.  i.e. assume a string of length 18 bytes
                            is more common than 120 bytes.

                        </li>

                    </ul>
               </p>

                <h1>The Data Structures</h1>

                <p>

                    The primary data structure employed by this solution is the STRING_TABLE
                    structure.  It is composed of supporting structures: STRING_SLOT, SLOT_INDEX and
                    SLOT_LENGTH, and either embeds or points to the originating STRING_ARRAY
                    structure from which it was created.

                </p>

                <p>

                    Let's review the STRING_TABLE <small>
                    <a href="https://github.com/tpn/tracer/blob/2018-04-18.2/StringTable2/StringTable.h#L194">
                    (view on GitHub)</a></small> structure first and then touch on the supporting
                    structures.

                </p>

                <a class="xref" name="STRING_TABLE"></a>
                <h2>STRING_TABLE</h2>

                <div class="tab-box language box-string-table">
                    <ul class="tabs">
                        <li data-content="content-string-table-cnf">C - Cutler Normal Form</li>
                        <li data-content="content-string-table-knf">C - Kernel Normal Form</li>
                        <li data-content="content-string-table-masm">MASM</li>
                    </ul>
                    <div class="content">
<pre class="code content-string-table-cnf"><code class="language-c">
//
// The STRING_TABLE struct is an optimized structure for testing whether a
// prefix entry for a string is in a table, with the expectation that the
// strings being compared will be relatively short (ideally &lt;= 16 characters),
// and the table of string prefixes to compare to will be relatively small
// (ideally &lt;= 16 strings).
//
// The overall goal is to be able to prefix match a string with the lowest
// possible (amortized) latency.  Fixed-size, memory-aligned character arrays,
// and SIMD instructions are used to try and achieve this.
//

typedef struct _STRING_TABLE {

    //
    // A slot where each individual element contains a uniquely-identifying
    // letter, with respect to the other strings in the table, of each string
    // in an occupied slot.
    //

    STRING_SLOT UniqueChars;

    //
    // (16 bytes consumed.)
    //

    //
    // For each unique character identified above, the following structure
    // captures the 0-based index of that character in the underlying string.
    // This is used as an input to vpshufb to rearrange the search string's
    // characters such that it can be vpcmpeqb'd against the unique characters
    // above.
    //

    SLOT_INDEX UniqueIndex;

    //
    // (32 bytes consumed.)
    //

    //
    // Length of the underlying string in each slot.
    //

    SLOT_LENGTHS Lengths;

    //
    // (48 bytes consumed, aligned at 16 bytes.)
    //

    //
    // Pointer to the STRING_ARRAY associated with this table, which we own
    // (we create it and copy the caller's contents at creation time and
    // deallocate it when we get destroyed).
    //
    // N.B.  We use pStringArray here instead of StringArray because the
    //       latter is a field name at the end of the struct.
    //
    //

    PSTRING_ARRAY pStringArray;

    //
    // (56 bytes consumed, aligned at 8 bytes.)
    //

    //
    // String table flags.
    //

    STRING_TABLE_FLAGS Flags;

    //
    // (60 bytes consumed, aligned at 4 bytes.)
    //

    //
    // A 16-bit bitmap indicating which slots are occupied.
    //

    USHORT OccupiedBitmap;

    //
    // A 16-bit bitmap indicating which slots have strings longer than 16 chars.
    //

    USHORT ContinuationBitmap;

    //
    // (64 bytes consumed, aligned at 64 bytes.)
    //

    //
    // The 16-element array of STRING_SLOT structs.  We want this to be aligned
    // on a 64-byte boundary, and it consumes 256-bytes of memory.
    //

    STRING_SLOT Slots[16];

    //
    // (320 bytes consumed, aligned at 64 bytes.)
    //

    //
    // We want the structure size to be a power of 2 such that an even number
    // can fit into a 4KB page (and reducing the likelihood of crossing page
    // boundaries, which complicates SIMD boundary handling), so we have an
    // extra 192-bytes to play with here.  The CopyStringArray() routine is
    // special-cased to allocate the backing STRING_ARRAY structure plus the
    // accommodating buffers in this space if it can fit.
    //
    // (You can test whether or not this occurred by checking the invariant
    //  `StringTable-&gt;pStringArray == &amp;StringTable-&gt;StringArray`, if this
    //  is true, the array was allocated within this remaining padding space.)
    //

    union {
        STRING_ARRAY StringArray;
        CHAR Padding[192];
    };

} STRING_TABLE, *PSTRING_TABLE, **PPSTRING_TABLE;

//
// Assert critical size and alignment invariants at compile time.
//

C_ASSERT(FIELD_OFFSET(STRING_TABLE, UniqueIndex) == 16);
C_ASSERT(FIELD_OFFSET(STRING_TABLE, Lengths) == 32);
C_ASSERT(FIELD_OFFSET(STRING_TABLE, pStringArray) == 48);
C_ASSERT(FIELD_OFFSET(STRING_TABLE, Slots)   == 64);
C_ASSERT(FIELD_OFFSET(STRING_TABLE, Padding) == 320);
C_ASSERT(sizeof(STRING_TABLE) == 512);

</code></pre>

<pre class="code content-string-table-knf"><code class="language-c">
struct string_table {
    char                       unique_chars[16];
    unsigned char              unique_index[16];
    unsigned char              slot_lengths[16];
    struct string_array       *string_array_ptr;
    struct string_table_flags  flags;
    unsigned short             occupied_bitmap;
    unsigned short             continuation_bitmap;
    char                       slots[16][16];
    union {
        struct string_array    string_array;
        char                   padding[184];
    } u;
};

</code></pre>
<pre class="code content-string-table-masm"><code class="language-nasm">
STRING_TABLE struct
    UniqueChars         CHAR 16 dup  (?)
    UniqueIndex         BYTE 16 dup  (?)
    Lengths             BYTE 16 dup  (?)
    pStringArray        PSTRING_ARRAY ?
    Flags               ULONG         ?
    OccupiedBitmap      USHORT        ?
    ContinuationBitmap  USHORT        ?
    Slots               STRING_SLOT 16 dup ({ })
    union
        StringArray STRING_ARRAY {?}
        Padding CHAR 192 dup (?)
    ends
STRING_TABLE ends

;
; Assert our critical field offsets and structure size as per the same approach
; taken in StringTable.h.
;

.erre (STRING_TABLE.UniqueIndex  eq  16), @CatStr(&lt;UnexpectedOffset STRING_TABLE.UniqueIndex: &gt;, %(STRING_TABLE.UniqueIndex))
.erre (STRING_TABLE.Lengths      eq  32), @CatStr(&lt;UnexpectedOffset STRING_TABLE.Lengths: &gt;, %(STRING_TABLE.Lengths))
.erre (STRING_TABLE.pStringArray eq  48), @CatStr(&lt;UnexpectedOffset STRING_TABLE.pStringArray: &gt;, %(STRING_TABLE.pStringArray))
.erre (STRING_TABLE.Slots        eq  64), @CatStr(&lt;UnexpectedOffset STRING_TABLE.Slots: &gt;, %(STRING_TABLE.Slots))
.erre (STRING_TABLE.Padding      eq 320), @CatStr(&lt;UnexpectedOffset STRING_TABLE.Padding: &gt;, %(STRING_TABLE.Padding))
.erre (size STRING_TABLE eq 512), @CatStr(&lt;IncorrectStructSize: STRING_TABLE: &gt;, %(size STRING_TABLE))

PSTRING_TABLE typedef ptr STRING_TABLE

;
; CamelCase typedefs that are nicer to work with in assembly
; than their uppercase counterparts.
;

StringTable typedef STRING_TABLE
</code></pre>

                    </div>
                </div>

                <p>

                    The following diagram depicts an in-memory representation of the STRING_TABLE
                    structure using our NTFS reserved prefix names.  It is created via the
                    <a href="#CreateStringTable">CreateStringTable</a> routine, which we feature
                    in the appendix of this article.

                </p>

                <picture>
                    <source srcset="StringTableLayout2.png"/>
                    <img width="1042px" height="675px" srcset="StringTableLayout2.png"/>
                    <!--
                    <source srcset="StringTableLayout2.png"/>
                    <img width="1641px" height="1020px" srcset="StringTableLayout2.png"/>
                    -->
                </picture>

                <p>

                    In order to improve the uniqueness of the unique characters selected from each
                    string, the strings are sorted by length during string table creation and
                    enumerated in this order whilst identifying unique characters.  The rationale
                    behind this is that shorter strings simply have fewer characters to choose from,
                    longer strings have more to choose from.  If we identified unique characters in
                    the order they appear in the string table, we may have longer strings preceeding
                    shorter ones, such that toward the end of the table, nothing unique can be
                    extracted from the short ones.

                </p>

                <p>

                    The utility of the string table is maximised by ensuring a unique character is
                    selected from every string, thus, we sort by length first.  Note that the
                    uniqueness is actually determined by offset:character pairs, with the offsets
                    becoming the indices stored in the <em>UniqueIndex</em> slot.  If you trace
                    through the diagram above, you'll see that the unique character in each slot
                    matches the character in the corresponding string slot, indicated by the
                    underlying index.

                </p>

                <p>



                </p>


                <a class="xref" name="supporting-structures"></a>
                <h2>Supporting Structures</h2>

                The string array captures a raw array representation of the underlying strings
                making up the string table.  It is either embedded within the padding area at the
                end of the string table, or a separate allocation is made during string table
                creation.  The main interface to creating a string table is via a STRING_ARRAY
                structure.  The helper functions,
                <a href="https://github.com/tpn/tracer/blob/2018-04-18.2/StringTable2/CreateStringTable.c#L471">
                    CreateStringTableFromDelimitedString
                </a> and
                <a href="https://github.com/tpn/tracer/blob/2018-04-18.2/StringTable2/CreateStringTable.c#L595">
                    CreateStringTableFromDelimitedEnvironmentVariable
                </a> simply break down their input into a STRING_ARRAY representation first
                before calling
                <a href="https://github.com/tpn/tracer/blob/2018-04-18.2/StringTable2/CreateStringTable.c#L51">
                    CreateStringTable
                </a>.

                <a class="xref" name="STRING_ARRAY"></a>
                <h3>STRING_ARRAY</h3>

<pre class="code content-string-array"><code class="language-c">
typedef struct _Struct_size_bytes_(SizeInQuadwords&gt;&gt;3) _STRING_ARRAY {

    //
    // Size of the structure, in quadwords.  Why quadwords?  It allows us to
    // keep this size field to a USHORT, which helps with the rest of the
    // alignment in this struct (we want the STRING Strings[] array to start
    // on an 8-byte boundary).
    //
    // N.B.  We can't express the exact field size in the SAL annotation
    //       below, because the array of buffer sizes are inexpressible;
    //       however, we know the maximum length, so we can use the implicit
    //       invariant that the total buffer size can't exceed whatever num
    //       elements * max size is.
    //

    _Field_range_(&lt;=, (
        sizeof(struct _STRING_ARRAY) +
        ((NumberOfElements - 1) * sizeof(STRING)) +
        (MaximumLength * NumberOfElements)
    ) &gt;&gt; 3)
    USHORT SizeInQuadwords;

    //
    // Number of elements in the array.
    //

    USHORT NumberOfElements;

    //
    // Minimum and maximum lengths for the String-&gt;Length fields.  Optional.
    //

    USHORT MinimumLength;
    USHORT MaximumLength;

    //
    // A pointer to the STRING_TABLE structure that "owns" us.
    //

    struct _STRING_TABLE *StringTable;

    //
    // The string array.  Number of elements in the array is governed by the
    // NumberOfElements field above.
    //

    STRING Strings[ANYSIZE_ARRAY];

} STRING_ARRAY, *PSTRING_ARRAY, **PPSTRING_ARRAY;
</code></pre>

                <small>

                    <a class="xref" name="SAL"></a>
                    <p>

                        Note: the odd-looking macros <a
                        href="https://github.com/tpn/winsdk-10/blob/master/Include/10.0.16299.0/shared/sal.h#L597">
                        _Struct_size_bytes_</a> and
                        <a
                        href="https://github.com/tpn/winsdk-10/blob/master/Include/10.0.16299.0/shared/sal.h#L615">
                        _Field_range_</a> are
                        <a
                        href="https://docs.microsoft.com/en-us/visualstudio/code-quality/annotating-structs-and-classes">
                        SAL Annotations</a>.  There's a neat deck called
                        <a
                        href="https://github.com/tpn/pdfs/blob/master/Program%20Analysis%20with%20PREfast%20and%20SAL%20-%20Erik%20Poll%20-%20Slides%20(3_StaticAnalysisPREfast).pdf"
                        >Engineering Better Software at Microsoft</a> which captures some interesting
                        details about SAL, for those wanting to read more.  The Code Analysis engine
                        that uses the annotations is built upon the <a
                        href="https://github.com/Z3Prover/z3">Z3 Theorem Prover</a>, which is a
                        fascinating little project in its own right.

                    </p>

                </small>

                <p>

                    And finally, we're left with the smaller helper structs that we use to
                    encapsulate the various innards of the string table.  (I use unions that
                    feature XMMWORD representations (which is a typedef of __m128i, representing
                    an XMM register) as well as underlying byte/character representations as I
                    personally find it makes the resulting C code a bit nicer.)

                </p>

                <a class="xref" name="STRING_SLOT"></a>
                <h3>STRING_SLOT</h3>

<pre class="code content-string-slot"><code class="language-c">
//
// String tables are composed of a 16 element array of 16 byte string "slots",
// which represent a unique character (with respect to other strings in the
// table) for a string in a given slot index.  The STRING_SLOT structure
// provides a convenient wrapper around this construct.
//

typedef union DECLSPEC_ALIGN(16) _STRING_SLOT {
    XMMWORD CharsXmm;
    CHAR Char[16];
} STRING_SLOT, *PSTRING_SLOT, **PPSTRING_SLOT;
C_ASSERT(sizeof(STRING_SLOT) == 16);
</code></pre>

                <a class="xref" name="SLOT_INDEX"></a>
                <h3>SLOT_INDEX</h3>
<pre class="code content-slot-index"><code class="language-c">
//
// An array of 1 byte unsigned integers used to indicate the 0-based index of
// a given unique character in the corresponding string.
//

typedef union DECLSPEC_ALIGN(16) _SLOT_INDEX {
    XMMWORD IndexXmm;
    BYTE Index[16];
} SLOT_INDEX, *PSLOT_INDEX, **PPSLOT_INDEX;
C_ASSERT(sizeof(SLOT_INDEX) == 16);
</code></pre>

                <a class="xref" name="SLOT_LENGTHS"></a>
                <h3>SLOT_LENGTHS</h3>
<pre class="code content-slot-lengths"><code class="language-c">
//
// A 16 element array of 1 byte unsigned integers, used to capture the length
// of each string slot in a single XMM 128-bit register.
//

typedef union DECLSPEC_ALIGN(16) _SLOT_LENGTHS {
    XMMWORD SlotsXmm;
    BYTE Slots[16];
} SLOT_LENGTHS, *PSLOT_LENGTHS, **PPSLOT_LENGTHS;
C_ASSERT(sizeof(SLOT_LENGTHS) == 16);
</code></pre>

                <a class="xref" name="algorithm"></a>
                <h1>The Algorithm</h1>

                <p>
                    <!--
                    <div>
                        <script async class="speakerdeck-embed" data-id="feadc0a06e770130c56622000a9f1084" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
                    </div>
                    -->

                    The source code is verbosely commented, so without further ado, here is the
                    implementation of our (initially) fastest C version of the prefix match function
                    <small>
                        <a
                        href="https://github.com/tpn/tracer/blob/2018-04-18.2/StringTable2/IsPrefixOfStringInTable_10.c#L21">
                            (view on GitHub)
                        </a>
                    </small>:

                </p>

                <!--
                <a class="xref" name="implementation"></a>
                <h1>The Implementation(s)</h1>

                -->
                <a class="xref" name="IsPrefixOfStringInTable_10"></a>
                <h2>IsPrefixOfStringInTable_10</h2>

<pre class="code content-is-prefix-v10"><code class="language-c">
_Use_decl_annotations_
STRING_TABLE_INDEX
IsPrefixOfStringInTable_10(
    PSTRING_TABLE StringTable,
    PSTRING String,
    PSTRING_MATCH Match
    )
/*++

Routine Description:

    Searches a string table to see if any strings "prefix match" the given
    search string.  That is, whether any string in the table "starts with
    or is equal to" the search string.

    This version is based off version 8, but rewrites the inner loop that checks
    for comparisons.

Arguments:

    StringTable - Supplies a pointer to a STRING_TABLE struct.

    String - Supplies a pointer to a STRING struct that contains the string to
        search for.

    Match - Optionally supplies a pointer to a variable that contains the
        address of a STRING_MATCH structure.  This will be populated with
        additional details about the match if a non-NULL pointer is supplied.

Return Value:

    Index of the prefix match if one was found, NO_MATCH_FOUND if not.

--*/
{
    ULONG Bitmap;
    ULONG Mask;
    ULONG Count;
    ULONG Length;
    ULONG Index;
    ULONG Shift = 0;
    ULONG CharactersMatched;
    ULONG NumberOfTrailingZeros;
    ULONG SearchLength;
    PSTRING TargetString;
    STRING_SLOT Slot;
    STRING_SLOT Search;
    STRING_SLOT Compare;
    SLOT_LENGTHS Lengths;
    XMMWORD LengthXmm;
    XMMWORD UniqueChar;
    XMMWORD TableUniqueChars;
    XMMWORD IncludeSlotsByUniqueChar;
    XMMWORD IgnoreSlotsByLength;
    XMMWORD IncludeSlotsByLength;
    XMMWORD IncludeSlots;
    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);

    //
    // Unconditionally do the following five operations before checking any of
    // the results and determining how the search should proceed:
    //
    //  1. Load the search string into an Xmm register, and broadcast the
    //     character indicated by the unique character index (relative to
    //     other strings in the table) across a second Xmm register.
    //
    //  2. Load the string table's unique character array into an Xmm register.
    //
    //  3. Broadcast the search string's length into an XMM register.
    //
    //  3. Load the string table's slot lengths array into an XMM register.
    //
    //  4. Compare the unique character from step 1 to the string table's unique
    //     character array set up in step 2.  The result of this comparison
    //     will produce an XMM register with each byte set to either 0xff if
    //     the unique character was found, or 0x0 if it wasn't.
    //
    //  5. Compare the search string's length from step 3 to the string table's
    //     slot length array set up in step 3.  This allows us to identify the
    //     slots that have strings that are of lesser or equal length to our
    //     search string.  As we're doing a prefix search, we can ignore any
    //     slots longer than our incoming search string.
    //
    // We do all five of these operations up front regardless of whether or not
    // they're strictly necessary.  That is, if the unique character isn't in
    // the unique character array, we don't need to load array lengths -- and
    // vice versa.  However, we assume the benefits afforded by giving the CPU
    // a bunch of independent things to do unconditionally up-front outweigh
    // the cost of putting in branches and conditionally loading things if
    // necessary.
    //

    //
    // Load the first 16-bytes of the search string into an XMM register.
    //

    Search.CharsXmm = _mm_load_si128((PXMMWORD)String-&gt;Buffer);

    //
    // Broadcast the search string's unique characters according to the string
    // table's unique character index.
    //

    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,
                                  StringTable-&gt;UniqueIndex.IndexXmm);

    //
    // Load the slot length array into an XMM register.
    //

    Lengths.SlotsXmm = _mm_load_si128(&amp;StringTable-&gt;Lengths.SlotsXmm);

    //
    // Load the string table's unique character array into an XMM register.
    //

    TableUniqueChars = _mm_load_si128(&amp;StringTable-&gt;UniqueChars.CharsXmm);

    //
    // Broadcast the search string's length into an XMM register.
    //

    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;
    LengthXmm = _mm_broadcastb_epi8(LengthXmm);

    //
    // Compare the search string's unique character with all of the unique
    // characters of strings in the table, saving the results into an XMM
    // register.  This comparison will indicate which slots we can ignore
    // because the characters at a given index don't match.  Matched slots
    // will be 0xff, unmatched slots will be 0x0.
    //

    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);

    //
    // Find all slots that are longer than the incoming string length, as these
    // are the ones we're going to exclude from any prefix match.
    //
    // N.B. Because we default the length of empty slots to 0x7f, they will
    //      handily be included in the ignored set (i.e. their bytes will also
    //      be set to 0xff), which means they'll also get filtered out when
    //      we invert the mask shortly after.
    //

    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);

    //
    // Invert the result of the comparison; we want 0xff for slots to include
    // and 0x0 for slots to ignore (it's currently the other way around).  We
    // can achieve this by XOR'ing the result against our all-ones XMM register.
    //

    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);

    //
    // We're now ready to intersect the two XMM registers to determine which
    // slots should still be included in the comparison (i.e. which slots have
    // the exact same unique character as the string and a length less than or
    // equal to the length of the search string).
    //

    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,
                                 IncludeSlotsByLength);

    //
    // Generate a mask.
    //

    Bitmap = _mm_movemask_epi8(IncludeSlots);

    if (!Bitmap) {

        //
        // No bits were set, so there are no strings in this table starting
        // with the same character and of a lesser or equal length as the
        // search string.
        //

        return NO_MATCH_FOUND;
    }

    SearchLength = min(String-&gt;Length, 16);

    Count = __popcnt(Bitmap);

    do {

        //
        // Extract the next index by counting the number of trailing zeros left
        // in the bitmap and adding the amount we've already shifted by.
        //

        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);
        Index = NumberOfTrailingZeros + Shift;

        //
        // Shift the bitmap right, past the zeros and the 1 that was just found,
        // such that it's positioned correctly for the next loop's tzcnt. Update
        // the shift count accordingly.
        //

        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);
        Shift = Index + 1;

        //
        // Load the slot and its length.
        //

        Slot.CharsXmm = _mm_load_si128(&amp;StringTable-&gt;Slots[Index].CharsXmm);
        Length = Lengths.Slots[Index];

        //
        // Compare the slot to the search string.
        //

        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);

        //
        // Create a mask of the comparison, then filter out high bits from the
        // search string's length (which is capped at 16).  (This shouldn't be
        // technically necessary as the string array buffers should have been
        // calloc'd and zeroed, but optimizing compilers can often ignore the
        // zeroing request -- which can produce some bizarre results where the
        // debug build is correct (because the buffers were zeroed) but the
        // release build fails because the zeroing got ignored and there are
        // junk bytes past the NULL terminator, which get picked up in our
        // 128-bit loads.)
        //

        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);

        //
        // Count how many characters matched.
        //

        CharactersMatched = __popcnt(Mask);

        if ((USHORT)CharactersMatched &lt; Length &amp;&amp; Length &lt; 16) {

            //
            // The slot length is longer than the number of characters matched
            // from the search string; this isn't a prefix match.  Continue.
            //

            continue;
        }

        if (Length &gt; 16) {

            //
            // The first 16 characters in the string matched against this
            // slot, and the slot is oversized (longer than 16 characters),
            // so do a direct comparison between the remaining buffers.
            //

            TargetString = &amp;StringTable-&gt;pStringArray-&gt;Strings[Index];

            CharactersMatched = IsPrefixMatch(String, TargetString, 16);

            if (CharactersMatched == NO_MATCH_FOUND) {

                //
                // The prefix match failed, continue our search.
                //

                continue;
            }
        }

        //
        // This slot is a prefix match.  Fill out the Match structure if the
        // caller provided a non-NULL pointer, then return the index of the
        // match.
        //

        if (ARGUMENT_PRESENT(Match)) {

            Match-&gt;Index = (BYTE)Index;
            Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;
            Match-&gt;String = &amp;StringTable-&gt;pStringArray-&gt;Strings[Index];

        }

        return (STRING_TABLE_INDEX)Index;

    } while (--Count);

    //
    // If we get here, we didn't find a match.
    //

    //IACA_VC_END();

    return NO_MATCH_FOUND;
}



</code></pre>

                <a class="xref" name="IsPrefixOfStringInTable_x64_2"></a>
                <h2>IsPrefixOfStringInTable_x64_2</h2>

                <p>

                    Looking at the output of the assembly of the C version, I suspected a faster
                    version could be written in assembly specifically for the negative match case.
                    This led to a proof-of-concept LEAF_ENTRY named <a
                    href="https://github.com/tpn/tracer/blob/2018-04-18.2/StringTable2/IsPrefixOfStringInTable_x64_1.asm#L25">
                    IsPrefixOfStringInTable_x64_1</a> that simply dealt with the negative match
                    fast-path.  That is, it correctly returned NO_MATCH_FOUND if the unique
                    character and length vectors did not corroborate with the incoming search
                    string.

                </p>

                <p>

                    However, it also returned NO_MATCH_FOUND if there was a corroboration
                    (requiring a comparison against each slot matched in the bitmap).  So, it wasn't
                    particularly useful other than evaluating how fast we could get the negative
                    match case.

                </p>

                <p>

                    But as far as proof-of-concepts go, it was very effective, indicating that the
                    negative match could be done in as little as about 12 instructions and ~6-7-ish
                    CPU cycles, depending on which way the wind was blowing.  The disassembly for
                    this initial test looks like this:

                </p>

                <hr/>
<small><pre>
0:000&gt; uf StringTable2!IsPrefixOfStringInTable_x64_1
StringTable2!IsPrefixOfStringInTable_x64_1:
00007ffd`15593290 488b4208        mov           rax,qword ptr [rdx+8]
00007ffd`15593294 c5fa6f00        vmovdqu       xmm0,xmmword ptr [rax]
00007ffd`15593298 c5f96f4910      vmovdqa       xmm1,xmmword ptr [rcx+10h]
00007ffd`1559329d c4e27900c1      vpshufb       xmm0,xmm0,xmm1
00007ffd`155932a2 c5f96f11        vmovdqa       xmm2,xmmword ptr [rcx]
00007ffd`155932a6 c5f96f5920      vmovdqa       xmm3,xmmword ptr [rcx+20h]
00007ffd`155932ab c4e25129ed      vpcmpeqq      xmm5,xmm5,xmm5
00007ffd`155932b0 c4e2797822      vpbroadcastb  xmm4,byte ptr [rdx]
00007ffd`155932b5 c5f974c2        vpcmpeqb      xmm0,xmm0,xmm2
00007ffd`155932b9 c5d964cb        vpcmpgtb      xmm1,xmm4,xmm3
00007ffd`155932bd c5f1efcd        vpxor         xmm1,xmm1,xmm5
00007ffd`155932c1 c4e27917c1      vptest        xmm0,xmm1
00007ffd`155932c6 33c0            xor           eax,eax
00007ffd`155932c8 f6d0            not           al
00007ffd`155932ca c3              ret
</pre></small>
                <hr/>

                <p>

                    Implementing it as a LEAF_ENTRY bit me in the ass when it came time to implement
                    the second version, which I wanted to keep identical to the first version,
                    except, you know, have it work.

                </p>

                <p>

                    A bit of background information first.  The Windows x64 ABI and calling
                    convention dictates there are two types of functions:
                    <a
                    href="https://github.com/tpn/winsdk-10/blob/master/Include/10.0.16299.0/shared/macamd64.inc#L524">
                    NESTED_ENTRY</a> and
                    <a href="https://github.com/tpn/winsdk-10/blob/master/Include/10.0.16299.0/shared/macamd64.inc#L353">
                    LEAF_ENTRY</a>.  NESTED_ENTRY is by far the most common; C and C++ functions are
                    all implicitly NESTED_ENTRY functions.  (The LEAF_ENTRY and NESTED_ENTRY symbols
                    are MASM (ml64.exe) macro names, but the concept applies to all languages.)

                </p>

                <p>

                    A LEAF_ENTRY can only be implemented in assembly.  It is constrained in that it
                    may not manipulate any of the non-volatile x64 registers (rbx, rdi, rsi, rsp,
                    rbp, r12, r13, r14, r15, xmm6-15), nor may it call any other functions (because
                    call implicitly modifies the stack pointer), nor may it have a structured
                    exception handler (because that also manipulates the stack pointer).

                </p>

                <p>

                    The reason behind all of these constraints is that LEAF_ENTRY routines do not
                    have any unwind information generated for them in their runtime function
                    entries.  Unwind information is used by the kernel to do just that, unwind
                    the modifications made to non-volatile registers whilst traversing back up
                    through the call stack looking for an exception handler in the case of an
                    exception.

                </p>

                <p>

                    For example, here's the function entry and associated unwind information for the
                    IsPrefixOfStringInTable_10 function:

                </p>

                <hr/>
<small><pre>
0:000> .fnent StringTable2!IsPrefixOfStringInTable_10
Debugger function entry 000001f9`048edf98 for:
Exact matches:
    StringTable2!IsPrefixOfStringInTable_10 (struct _STRING_TABLE *, struct _STRING *, struct _STRING_MATCH *)

BeginAddress      = 00000000`00001fe0
EndAddress        = 00000000`00002165
UnwindInfoAddress = 00000000`00004370

Unwind info at 00007ffd`15594370, 1e bytes
  version 1, flags 0, prolog 81, codes d
  00: offs 81, unwind op 4, op info 7   UWOP_SAVE_NONVOL FrameOffset: 20 reg: rdi.
  02: offs 7c, unwind op 4, op info 6   UWOP_SAVE_NONVOL FrameOffset: 60 reg: rsi.
  04: offs 77, unwind op 4, op info 5   UWOP_SAVE_NONVOL FrameOffset: 58 reg: rbp.
  06: offs 72, unwind op 4, op info 3   UWOP_SAVE_NONVOL FrameOffset: 50 reg: rbx.
  08: offs c, unwind op 2, op info 4    UWOP_ALLOC_SMALL.
  09: offs 8, unwind op 0, op info f    UWOP_PUSH_NONVOL reg: r15.
  0a: offs 6, unwind op 0, op info e    UWOP_PUSH_NONVOL reg: r14.
  0b: offs 4, unwind op 0, op info d    UWOP_PUSH_NONVOL reg: r13.
  0c: offs 2, unwind op 0, op info c    UWOP_PUSH_NONVOL reg: r12.
0:000>
</pre></small>
                <hr/>

                <p>

                    We can see that the C version of our routine manipulates 9 non-volatile
                    registers in total, including the stack pointer.  The first instructions
                    of the C version constitute the function's prologue; in the disassembly,
                    you can see that four of the rxx registers are pushed to the stack and then
                    0x28 (40) bytes of stack space is allocated:

                </p>

                <hr/>
<small><pre>
0:000> uf StringTable2!IsPrefixOfStringInTable_10
StringTable2!IsPrefixOfStringInTable_10:
00007ffd`15591fe0 4154            push    r12
00007ffd`15591fe2 4155            push    r13
00007ffd`15591fe4 4156            push    r14
00007ffd`15591fe6 4157            push    r15
00007ffd`15591fe8 4883ec28        sub     rsp,28h
--- END OF PROLOGUE ---
00007ffd`15591fec c5fa6f5920      vmovdqu xmm3,xmmword ptr [rcx+20h]
</pre></small>
                <hr/>

                <p>

                    With our LEAF_ENTRY version, though, we don't need to push anything to the stack
                    as we won't be manipulating any non-volatile registers.  If an exception occurs
                    within the body of our implementation (say we dereference a NULL pointer), the
                    kernel knows it doesn't have to undo any non-volatile register modifications
                    (using offsets specified by the unwind information) because there isn't any
                    unwind information.  It can simply advance to the frame before us (e.g. rsp at
                    the time of the fault, minus 8 bytes) as it continues its search for runtime
                    function entries and associated unwind information.  As you can see, there is
                    no unwind information:

                </p>

                <hr/>
<small><pre>
0:000> .fnent StringTable2!IsPrefixOfStringInTable_x64_1
Debugger function entry 000001f9`048edf98 for:
Exact matches:
    StringTable2!IsPrefixOfStringInTable_x64_1 (void)

BeginAddress      = 00000000`00003290
EndAddress        = 00000000`000032cb
UnwindInfoAddress = 00000000`00004468

Unwind info at 00007ffd`15594468, 4 bytes
  version 1, flags 0, prolog 0, codes 0
</pre></small>
                <hr/>

                <p>

                    Now, the problem with a LEAF_ENTRY for anything more than a trivial bit of code
                    is that you only have a handful of volatile registers to work with, and no stack
                    space can be used for register spilling or temporaries.  (There's a nice little
                    32 byte home parameter space trailing the return address that is intended for
                    routines to stash the four parameter variables, rcx, rdx, r8 and r9, but I
                    didn't use this; I figured if I was going to the trouble of avoiding stack
                    spills I may as well try avoid all memory spills.)

                </p>

                <p>

                    So, the good news is that the completed version 2 of the assembly routine
                    worked, and basically maintained the negative match performance of the first
                    attempt, maybe save for a cycle or two.  Even still, it consistently hovers
                    around 8 cycles for negative matches, which is 3-4 cycles better than our
                    fastest C version.  It was simultaneously fun, challenging, and tedious to
                    write.  To get around the limited registers, I ended up spilling to XMM
                    registers via vpinsr/vpextr combinations, as can be seen below.

                </p>

<pre class="code content-is-prefix-asm-v4"><code class="language-nasm">
;++
;
; BOOL
; IsPrefixOfStringInTable_x64_4(
;     _In_ PSTRING_TABLE StringTable,
;     _In_ PSTRING String,
;     _Out_ PSTRING_MATCH StringMatch
;     )
;
; Routine Description:
;
;     This routine searches for a prefix match of String in the given
;     StringTable structure.
;
; Arguments:
;
;     StringTable - Supplies a pointer to a STRING_TABLE structure to search.
;
;     String - Supplies a pointer to a STRING structure that a prefix match
;         is searched for.
;
;     StringMatch - Supplies a pointer to a STRING_MATCH structure that will
;         receive the results of the string match.
;
; Return Value:
;
;    Returns TRUE on sucess, FALSE on failure.
;
;--

        LEAF_ENTRY IsPrefixOfStringInTable_x64_2, _TEXT$00

;
; Load the string buffer into xmm0, and the unique indexes from the string table
; into xmm1.  Shuffle the buffer according to the unique indexes, and store the
; result back into xmm0.
;

        ;IACA_VC_START

        mov     rax, String.Buffer[rdx]
        vmovdqu xmm0, xmmword ptr [rax]                 ; Load search buffer.
        vmovdqa xmm1, xmmword ptr StringTable.UniqueIndex[rcx] ; Load indexes.
        vpshufb xmm5, xmm0, xmm1

;
; Load the string table's unique character array into xmm2, and the lengths for
; each string slot into xmm3.
;

        vmovdqa xmm2, xmmword ptr StringTable.UniqueChars[rcx]  ; Load chars.
        vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]      ; Load lengths.

;
; Broadcast the byte-sized string length into xmm4.
;

        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.

;
; Compare the search string's unique character array (xmm5) against the string
; table's unique chars (xmm2), saving the result back into xmm5.
;

        vpcmpeqb    xmm5, xmm5, xmm2            ; Compare unique chars.

;
; Compare the search string's length, which we've broadcasted to all 8-byte
; elements of the xmm4 register, to the lengths of the slots in the string
; table, to find those that are greater in length.  Invert the result, such
; that we're left with a masked register where each 0xff element indicates
; a slot with a length less than or equal to our search string's length.
;

        vpcmpeqq    xmm2, xmm2, xmm2            ; Set xmm2 to all ones.
        vpcmpgtb    xmm1, xmm3, xmm4            ; Identify long slots.
        vpxor       xmm1, xmm1, xmm2            ; Invert the result.

;
; Intersect-and-test the unique character match xmm mask register (xmm5) with
; the length match mask xmm register (xmm1).  This affects flags, allowing us
; to do a fast-path exit for the no-match case (where ZF = 1).
;

        vptest      xmm5, xmm1                  ; Check for no match.
        jnz         short Pfx10                 ; There was a match.

;
; No match, set rax to -1 and return.
;

        xor         eax, eax                    ; Clear rax.
        not         al                          ; al = -1
        ret                                     ; Return.

        ;IACA_VC_END

;
; (There was at least one match, continue with processing.)
;

;
; Calculate the "search length" for the incoming search string, which is
; equivalent of 'min(String-&gt;Length, 16)'.  (The search string's length
; currently lives in xmm4, albeit as a byte-value broadcasted across the
; entire register, so extract that first.)
;
; Once the search length is calculated, deposit it back at the second byte
; location of xmm4.
;
;   r10 and xmm4[15:8] - Search length (min(String-&gt;Length, 16))
;
;   r11 - String length (String-&gt;Length)
;

Pfx10:  vpextrb     r11, xmm4, 0                ; Load length.
        mov         rax, 16                     ; Load 16 into rax.
        mov         r10, r11                    ; Copy into r10.
        cmp         r10w, ax                    ; Compare against 16.
        cmova       r10w, ax                    ; Use 16 if length is greater.
        vpinsrb     xmm4, xmm4, r10d, 1         ; Save back to xmm4b[1].

;
; Home our parameter registers into xmm registers instead of their stack-backed
; location, to avoid memory writes.
;

        vpxor       xmm2, xmm2, xmm2            ; Clear xmm2.
        vpinsrq     xmm2, xmm2, rcx, 0          ; Save rcx into xmm2q[0].
        vpinsrq     xmm2, xmm2, rdx, 1          ; Save rdx into xmm2q[1].

;
; Intersect xmm5 and xmm1 (as we did earlier with the 'vptest xmm5, xmm1'),
; yielding a mask identifying indices we need to perform subsequent matches
; upon.  Convert this into a bitmap and save in xmm2d[2].
;

        vpand       xmm5, xmm5, xmm1            ; Intersect unique + lengths.
        vpmovmskb   edx, xmm5                   ; Generate a bitmap from mask.

;
; We're finished with xmm5; repurpose it in the same vein as xmm2 above.
;

        vpxor       xmm5, xmm5, xmm5            ; Clear xmm5.
        vpinsrq     xmm5, xmm5, r8, 0           ; Save r8 into xmm5q[0].

;
; Summary of xmm register stashing for the rest of the routine:
;
; xmm2:
;        0:63   (vpinsrq 0)     rcx (1st function parameter, StringTable)
;       64:127  (vpinsrq 1)     rdx (2nd function paramter, String)
;
; xmm4:
;       0:7     (vpinsrb 0)     length of search string
;       8:15    (vpinsrb 1)     min(String-&gt;Length, 16)
;      16:23    (vpinsrb 2)     loop counter (when doing long string compares)
;      24:31    (vpinsrb 3)     shift count
;
; xmm5:
;       0:63    (vpinsrq 0)     r8 (3rd function parameter, StringMatch)
;      64:95    (vpinsrd 2)     bitmap of slots to compare
;      96:127   (vpinsrd 3)     index of slot currently being processed
;

;
; Initialize rcx as our counter register by doing a popcnt against the bitmap
; we just generated in edx, and clear our shift count register (r9).
;

        popcnt      ecx, edx                    ; Count bits in bitmap.
        xor         r9, r9                      ; Clear r9.

        align 16

;
; Top of the main comparison loop.  The bitmap will be present in rdx.  Count
; trailing zeros of the bitmap, and then add in the shift count, producing an
; index (rax) we can use to load the corresponding slot.
;
; Register usage at top of loop:
;
;   rax - Index.
;
;   rcx - Loop counter.
;
;   rdx - Bitmap initially, then slot length.
;
;   r9 - Shift count.
;
;   r10 - Search length.
;
;   r11 - String length.
;

Pfx20:  tzcnt       r8d, edx                    ; Count trailing zeros.
        mov         eax, r8d                    ; Copy tzcnt to rax,
        add         rax, r9                     ; Add shift to create index.
        inc         r8                          ; tzcnt + 1
        shrx        rdx, rdx, r8                ; Reposition bitmap.
        vpinsrd     xmm5, xmm5, edx, 2          ; Store bitmap, free up rdx.
        xor         edx, edx                    ; Clear edx.
        mov         r9, rax                     ; Copy index back to shift.
        inc         r9                          ; Shift = Index + 1
        vpinsrd     xmm5, xmm5, eax, 3          ; Store the raw index xmm5d[3].

;
; "Scale" the index (such that we can use it in a subsequent vmovdqa) by
; shifting left by 4 (i.e. multiply by '(sizeof STRING_SLOT)', which is 16).
;
; Then, load the string table slot at this index into xmm1, then shift rax back.
;

        shl         eax, 4
        vpextrq     r8, xmm2, 0
        vmovdqa     xmm1, xmmword ptr [rax + StringTable.Slots[r8]]
        shr         eax, 4

;
; The search string's first 16 characters are already in xmm0.  Compare this
; against the slot that has just been loaded into xmm1, storing the result back
; into xmm1.
;

        vpcmpeqb    xmm1, xmm1, xmm0            ; Compare search string to slot.

;
; Convert the XMM mask into a 32-bit representation, then zero high bits after
; our "search length", which allows us to ignore the results of the comparison
; above for bytes that were after the search string's length, if applicable.
; Then, count the number of bits remaining, which tells us how many characters
; we matched.
;

        vpmovmskb   r8d, xmm1                   ; Convert into mask.
        bzhi        r8d, r8d, r10d              ; Zero high bits.
        popcnt      r8d, r8d                    ; Count bits.

;
; Load the slot length into rdx.  As xmm3 already has all the slot lengths in
; it, we can load rax (the current index) into xmm1 and use it to extract the
; slot length via shuffle.  (The length will be in the lowest byte of xmm1
; after the shuffle, which we can then vpextrb.)
;

        movd        xmm1, rax                   ; Load index into xmm1.
        vpshufb     xmm1, xmm3, xmm1            ; Shuffle lengths.
        vpextrb     rdx, xmm1, 0                ; Extract target length to rdx.

;
; If 16 characters matched, and the search string's length is longer than 16,
; we're going to need to do a comparison of the remaining strings.
;

        cmp         r8w, 16                     ; Compare chars matched to 16.
        je          short @F                    ; 16 chars matched.
        jmp         Pfx30                       ; Less than 16 matched.

;
; All 16 characters matched.  If the slot length is greater than 16, we need
; to do an inline memory comparison of the remaining bytes.  If it's 16 exactly,
; then great, that's a slot match, we're done.
;

@@:     cmp         dl, 16                      ; Compare length to 16.
        ja          Pfx50                       ; Length is &gt; 16.
        je          short Pfx35                 ; Lengths match!
                                                ; Length &lt;= 16, fall through...

;
; Less than or equal to 16 characters were matched.  Compare this against the
; length of the slot; if equal, this is a match, if not, no match, continue.
;

Pfx30:  cmp         r8b, dl                     ; Compare against slot length.
        jne         @F                          ; No match found.
        jmp         short Pfx35                 ; Match found!

;
; No match against this slot, decrement counter and either continue the loop
; or terminate the search and return no match.
;

@@:     vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.
        dec         cx                          ; Decrement counter.
        jnz         Pfx20                       ; cx != 0, continue.

        xor         eax, eax                    ; Clear rax.
        not         al                          ; al = -1
        ret                                     ; Return.

;
; Pfx35 and Pfx40 are the jump targets for when the prefix match succeeds.  The
; former is used when we need to copy the number of characters matched from r8
; back to rax.  The latter jump target doesn't require this.
;

Pfx35:  mov         rax, r8                     ; Copy numbers of chars matched.

;
; Load the match parameter back into r8 and test to see if it's not-NULL, in
; which case we need to fill out a STRING_MATCH structure for the match.
;

Pfx40:  vpextrq     r8, xmm5, 0                 ; Extract StringMatch.
        test        r8, r8                      ; Is NULL?
        jnz         short @F                    ; Not zero, need to fill out.

;
; StringMatch is NULL, we're done. Extract index of match back into rax and ret.
;

        vpextrd     eax, xmm5, 3                ; Extract raw index for match.
        ret                                     ; StringMatch == NULL, finish.

;
; StringMatch is not NULL.  Fill out characters matched (currently rax), then
; reload the index from xmm5 into rax and save.
;

@@:     mov         byte ptr StringMatch.NumberOfMatchedCharacters[r8], al
        vpextrd     eax, xmm5, 3                ; Extract raw index for match.
        mov         byte ptr StringMatch.Index[r8], al

;
; Final step, loading the address of the string in the string array.  This
; involves going through the StringTable, so we need to load that parameter
; back into rcx, then resolving the string array address via pStringArray,
; then the relevant STRING offset within the StringArray.Strings structure.
;

        vpextrq     rcx, xmm2, 0            ; Extract StringTable into rcx.
        mov         rcx, StringTable.pStringArray[rcx] ; Load string array.

        shl         eax, 4                  ; Scale the index; sizeof STRING=16.
        lea         rdx, [rax + StringArray.Strings[rcx]] ; Resolve address.
        mov         qword ptr StringMatch.String[r8], rdx ; Save STRING ptr.
        shr         eax, 4                  ; Revert the scaling.

        ret

;
; 16 characters matched and the length of the underlying slot is greater than
; 16, so we need to do a little memory comparison to determine if the search
; string is a prefix match.
;
; The slot length is stored in rax at this point, and the search string's
; length is stored in r11.  We know that the search string's length will
; always be longer than or equal to the slot length at this point, so, we
; can subtract 16 (currently stored in r10) from rax, and use the resulting
; value as a loop counter, comparing the search string with the underlying
; string slot byte-by-byte to determine if there's a match.
;

Pfx50:  sub         rdx, r10                ; Subtract 16 from search length.

;
; Free up some registers by stashing their values into various xmm offsets.
;

        vpinsrb     xmm4, xmm4, ecx, 2      ; Free up rcx register.
        mov         rcx, rdx                ; Free up rdx, rcx is now counter.

;
; Load the search string buffer and advance it 16 bytes.
;

        vpextrq     r11, xmm2, 1            ; Extract String into r11.
        mov         r11, String.Buffer[r11] ; Load buffer address.
        add         r11, r10                ; Advance buffer 16 bytes.

;
; Loading the slot is more involved as we have to go to the string table, then
; the pStringArray pointer, then the relevant STRING offset within the string
; array (which requires re-loading the index from xmm5d[3]), then the string
; buffer from that structure.
;

        vpextrq     r8, xmm2, 0             ; Extract StringTable into r8.
        mov         r8, StringTable.pStringArray[r8] ; Load string array.

        shl         eax, 4                  ; Scale the index; sizeof STRING=16.

        lea         r8, [rax + StringArray.Strings[r8]] ; Resolve address.
        mov         r8, String.Buffer[r8]   ; Load string table buffer address.
        add         r8, r10                 ; Advance buffer 16 bytes.

        xor         eax, eax                ; Clear eax.

;
; We've got both buffer addresses + 16 bytes loaded in r11 and r8 respectively.
; Do a byte-by-byte comparison.
;

        align 16
@@:     mov         dl, byte ptr [rax + r11]    ; Load byte from search string.
        cmp         dl, byte ptr [rax + r8]     ; Compare against target.
        jne         short Pfx60                 ; If not equal, jump.

;
; The two bytes were equal, update rax, decrement rcx and potentially continue
; the loop.
;

        inc         ax                          ; Increment index.
        loopnz      @B                          ; Decrement cx and loop back.

;
; All bytes matched!  Add 16 (still in r10) back to rax such that it captures
; how many characters we matched, and then jump to Pfx40 for finalization.
;

        add         rax, r10
        jmp         Pfx40

;
; Byte comparisons were not equal.  Restore the rcx loop counter and decrement
; it.  If it's zero, we have no more strings to compare, so we can do a quick
; exit.  If there are still comparisons to be made, restore the other registers
; we trampled then jump back to the start of the loop Pfx20.
;

Pfx60:  vpextrb     rcx, xmm4, 2                ; Restore rcx counter.
        dec         cx                          ; Decrement counter.
        jnz         short @F                    ; Jump forward if not zero.

;
; No more comparisons remaining, return.
;

        xor         eax, eax                    ; Clear rax.
        not         al                          ; al = -1
        ret                                     ; Return.

;
; More comparisons remain; restore the registers we clobbered and continue loop.
;

@@:     vpextrb     r10, xmm4, 1                ; Restore r10.
        vpextrb     r11, xmm4, 0                ; Restore r11.
        vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.
        jmp         Pfx20                       ; Continue comparisons.

        ;IACA_VC_END

        LEAF_END   IsPrefixOfStringInTable_x64_2, _TEXT$00

</code></pre>

                <!--
                <hr/>
                <p><em>Work in progress.</em></p>
                <hr/>

                <h1>The Benchmark</h1>

                <p>

                    See <a
                    href="https://github.com/tpn/tracer/blob/2018-04-18.2/StringTable2BenchmarkExe">StringTable2BenchmarkExe</a>.

                </p>

                <h1>What about the other 9 C implementations?</h1>

                <p>

                    XXX TODO.

                </p>
                -->

                <a class="xref" name="other-applications"></a>
                <h1>Other Applications</h1>
                <p>

                    Once I'd written the first version of the StringTable component, it became the
                    hammer for all of my string-related problems!  My favorite example of this is
                    the code I wrote for parsing the output of Windows debug engine's 'examine
                    symbols' command.

                </p>

                <p>

                    Here's an example of a few lines of output from the cdb command
                    <small><code>x /v /t Rtl!*</code></small>:

                </p>

<small>
<pre>
prv global 00007ffd`1570d100   10 struct _STRING Rtl!ExtendedLengthVolumePrefixA = struct _STRING "\\?\"
prv global 00007ffd`1570d110   10 struct _UNICODE_STRING Rtl!ExtendedLengthVolumePrefixW = "\\?\"
prv global 00007ffd`1570da30  5a8 char *[181] Rtl!RtlFunctionNames = char *[181]
prv global 00007ffd`15711018    8 <function> * Rtl!__C_specific_handler_impl = 0x00007ffd`214c0f00
prv global 00007ffd`1570d820  208 char *[65] Rtl!RtlExFunctionNames = char *[65]
prv global 00007ffd`15711000    8 <function> * Rtl!atexit_impl = 0x00007ffd`15704370
...
prv global 00007ffd`1570d120  1a8 char *[53] Rtl!CuFunctionNames = char *[53]
prv func   00007ffd`15708be0   5d <function> Rtl!AppendCharBufferToCharBuffer (char **, char *, unsigned long)
prv func   00007ffd`15702450   2e <function> Rtl!RtlHeapAllocatorFreePointer (void *, void **)
prv func   00007ffd`15702730   3c <function> Rtl!RtlHeapAllocatorAlignedFreePointer (void *, void **)
prv func   00007ffd`157093b0   1e <CLR type> Rtl!UnregisterRtlAtExitEntry$fin$0 (void)
...
prv func   00007ffd`157061f0   48 <function> Rtl!RtlCryptGenRandom (struct _RTL *, unsigned long, unsigned char *)
prv func   00007ffd`15707500   b2 <function> Rtl!AppendTailGuardedListTsx (struct _GUARDED_LIST *, struct _LIST_ENTRY *)
prv func   00007ffd`157075c0    d <function> Rtl!DummyVectorCall1 (union __m128i *, union __m128i *, ...
prv func   00007ffd`157025c0   4f <function> Rtl!RtlHeapAllocatorAlignedMalloc (void *, unsigned int64, unsigned int64)
prv func   00007ffd`15703cc0   9e <function> Rtl!DisableCreateSymbolicLinkPrivilege (void)
</pre>
</small>

                <p>

                    The function <a
                    href="https://github.com/tpn/tracer/blob/c2f36bcc686ce6633c91671650f58b62bffb126e/DebugEngine/DebugEngineExamineSymbols.c#L143">
                    ExamineSymbolsParseLine</a> is called for each line of output and is responsible
                    for parsing it into a <a
                    href="https://github.com/tpn/tracer/blob/c2f36bcc686ce6633c91671650f58b62bffb126e/DebugEngine/DebugEngine.h#L1655">
                    DEBUG_ENGINE_EXAMINED_SYMBOL</a> structure.  It's some good ol' fashioned string
                    processing using nothing but pointer arithmetic and a bunch of string tables.

                </p>

                <p>

                    It was the first time I needed to match more than 16 strings in a given category,
                    though.  A pattern emerged that was quite reasonable, and it became my defacto
                    way of dealing with multiple string tables for a given category.

                </p>

                <p>

                    Let's look at the <em>basic type</em> category.  Two string tables were
                    constructed from the following constant delimited strings
                    <small>
                        <a href="https://github.com/tpn/tracer/blob/c2f36bcc686ce6633c91671650f58b62bffb126e/DebugEngine/DebugEngineConstants.c#L114">
                            (view on GitHub)
                        </a>
                    </small>:

                </p>


<pre class="code"><code class="language-c">
#define DSTR(String) String ";"

//
// ExamineSymbolsBasicTypes
//

CONST STRING ExamineSymbolsBasicTypes1 = RTL_CONSTANT_STRING(
    DSTR("&lt;NoType&gt;")
    DSTR("&lt;function&gt;")
    DSTR("char")
    DSTR("wchar_t")
    DSTR("short")
    DSTR("long")
    DSTR("int64")
    DSTR("int")
    DSTR("unsigned char")
    DSTR("unsigned wchar_t")
    DSTR("unsigned short")
    DSTR("unsigned long")
    DSTR("unsigned int64")
    DSTR("unsigned int")
    DSTR("union")
    DSTR("struct")
);

CONST STRING ExamineSymbolsBasicTypes2 = RTL_CONSTANT_STRING(
    DSTR("&lt;CLR type&gt;")
    DSTR("bool")
    DSTR("void")
    DSTR("class")
    DSTR("float")
    DSTR("double")
    DSTR("_SAL_ExecutionContext")
    DSTR("__enative_startup_state")
);

</code></pre>

                <p>

                    In concert with the two string tables, an enumeration was defined
                    <small>
                        <a href="https://github.com/tpn/tracer/blob/c2f36bcc686ce6633c91671650f58b62bffb126e/DebugEngine/DebugEngine.h#L1029">
                            (view on GitHub)
                        </a>
                    </small>:

                </p>

<pre class="code"><code class="language-c">
//
// The order of these enumeration symbols must match the exact order of the
// corresponding string in the relevant ExamineSymbolsBasicTypes[1..n] STRING
// structure (see DebugEngineConstants.c).  This is because string tables are
// created from the delimited strings and the match index is cast directly to
// an enum of this type.
//

typedef enum _DEBUG_ENGINE_EXAMINE_SYMBOLS_TYPE {
    UnknownType = -1,

    //
    // First 16 types captured by BasicTypeStringTable1.
    //

    NoType = 0,
    FunctionType,

    CharType,
    WideCharType,
    ShortType,
    LongType,
    Integer64Type,
    IntegerType,

    UnsignedCharType,
    UnsignedWideCharType,
    UnsignedShortType,
    UnsignedLongType,
    UnsignedInteger64Type,
    UnsignedIntegerType,

    UnionType,
    StructType,

    //
    // Next 16 types captured by BasicTypeStringTable2.
    //

    CLRType = 16,
    BoolType,
    VoidType,
    ClassType,
    FloatType,
    DoubleType,
    SALExecutionContextType,
    ENativeStartupStateType,

    //
    // Any types that don't map directly to literal type names extracted from
    // the output string are listed here.  The first one starts at 48 in order
    // to differentiate it from the string tables.
    //

    //
    // Call site of an inline function.
    //

    InlineCallerType = 48,

    //
    // Enum is special in that it doesn't map to a string in the string table;
    // if a type can't be inferred from the list above, it defaults to Enum.
    //

    EnumType,

    //
    // Any enumeration value >= InvalidType is invalid.  Make sure this always
    // comes last in the enum layout.
    //

    InvalidType

} DEBUG_ENGINE_EXAMINE_SYMBOLS_TYPE;

</code></pre>

                <p>

                    Here's the part of the logic within
                    <a href="https://github.com/tpn/tracer/blob/c2f36bcc686ce6633c91671650f58b62bffb126e/DebugEngine/DebugEngineExamineSymbols.c#L407"
                    >ExamineSymbolsParseLine</a> that deals with matching the <em>basic type</em>
                    part of the line.  This refers to the 5th column of the output, e.g. the
                    <small><code>struct</code></small>,
                    <small><code>char *[181]</code></small>,
                    <small><code>&lt;function&gt;</code></small>,
                    <small><code>&lt;CLR type&gt;</code></small>
                    bits in the following output:
                    <small><pre>
prv global 00007ffd`1570d110   10 struct _UNICODE_STRING Rtl!ExtendedLengthVolumePrefixW = "\\?\"
prv global 00007ffd`1570da30  5a8 char *[181] Rtl!RtlFunctionNames = char *[181]
prv global 00007ffd`15711018    8 &lt;function&gt; * Rtl!__C_specific_handler_impl = 0x00007ffd`214c0f00
prv func   00007ffd`157093b0   1e &lt;CLR type&gt; Rtl!UnregisterRtlAtExitEntry$fin$0 (void)
                    </pre></small>

                </p>

<pre class="code"><code class="language-c">
    //
    // The basic type will be next.  Set up the variable then search the string
    // table for a match.  Set the length to the BytesRemaining for now; as long
    // as it's greater than or equal to the basic type length (which it should
    // always be), that will be fine.
    //

    BasicType.Buffer = Char;
    BasicType.Length = (USHORT)BytesRemaining;
    BasicType.MaximumLength = (USHORT)BytesRemaining;

    StringTable = Session-&gt;ExamineSymbolsBasicTypeStringTable1;
    IsPrefixOfStringInTable = Session-&gt;StringTableApi-&gt;IsPrefixOfStringInTable;
    MatchOffset = 0;
    MatchAttempts = 0;
    NumberOfStringTables = Session-&gt;NumberOfBasicTypeStringTables;
    ZeroStruct(Match);

RetryBasicTypeMatch:

    MatchIndex = IsPrefixOfStringInTable(StringTable, &amp;BasicType, &amp;Match);

    if (MatchIndex == NO_MATCH_FOUND) {
        if (++MatchAttempts &gt;= NumberOfStringTables) {

            //
            // We weren't able to match the name to any known types.
            // Default to the enum type.
            //

            SymbolType = EnumType;

        } else {

            //
            // There are string tables remaining.  Attempt another match.
            //

            StringTable++;
            MatchOffset += MAX_STRING_TABLE_ENTRIES;
            goto RetryBasicTypeMatch;

        }

    } else {

        //
        // We found a match.  Our enums are carefully offset in order to allow
        // the following `index + offset = enum value` logic to work.
        //

        SymbolType = MatchIndex + MatchOffset;
    }

</code></pre>

                <p>

                    If there's no match found, we check to see if we've performed the maximum number
                    of attempts, that is, whether or not we've exhausted all our string tables.  If
                    we have, we just default to the EnumType.

                </p>

                <p>

                    Otherwise, bump the StringTable pointer (which relies on the fact that the
                    underlying string table pointers in the session structure are contiguous &mdash;
                    a handy implementation detail), bump the match offset by number of entries per
                    string table, and try the match again.

                </p>

                <p>

                    If we found a match, we can obtain the SymbolType enum representation of the
                    underlying match by simply adding the match index to the match offset.  I like
                    that.  It's simple and fast.  It also plays nicely with switch statements; do
                    your lookup, resolve the underlying enum value, and process each possible path
                    in a case statement like you'd do with any other integer representation of an
                    option.

                </p>

                <p>

                    The other nice side-effect is that it forces you to pick which table a given
                    string should go in.  I made this decision by looking at which types occurred
                    most frequently, and simply put those in the first table.  Less frequent types
                    go in subsequent tables.

                </p>
                <p>

                    I have a hunch there's a lot of mileage in that approach; that is, linear
                    scanning an array of string tables until a match is found.  There will be an
                    inflection point where some form of a log(n) binary tree search will perform
                    better overall, but it would be very interesting to see how many strings you
                    need to potentially match against before that point is hit.

                </p>
                <p>

                    Unless the likelihood of matching any given string in your set is completely
                    random, by ordering the strings in your tables by how frequently they occur,
                    the amortized cost of parsing a chunk of text would be very competitive using
                    this approach, I would think.

                </p>
                <p>

                    A fun experiment for next time, perhaps!

                </p>

                <h2>Implementation Considerations</h2>

                <p>
                    <small><em>

                    Maybe put some notes here about the implications of authoring so many different
                    versions of a routine, and how to handle making them available to some
                    components (e.g. unit tests and benchmarks) without unnecessarily cluttering
                    other components.

                    Here's the approach used by the StringTable component:

                    </em></small>
                </p>

<pre class="code"><code class="language-c">
//
// Define the string table API structure.
//

typedef struct _STRING_TABLE_API {

    PSET_C_SPECIFIC_HANDLER SetCSpecificHandler;

    PCOPY_STRING_ARRAY CopyStringArray;
    PCREATE_STRING_TABLE CreateStringTable;
    PDESTROY_STRING_TABLE DestroyStringTable;

    PINITIALIZE_STRING_TABLE_ALLOCATOR
        InitializeStringTableAllocator;

    PINITIALIZE_STRING_TABLE_ALLOCATOR_FROM_RTL_BOOTSTRAP
        InitializeStringTableAllocatorFromRtlBootstrap;

    PCREATE_STRING_ARRAY_FROM_DELIMITED_STRING
        CreateStringArrayFromDelimitedString;

    PCREATE_STRING_TABLE_FROM_DELIMITED_STRING
        CreateStringTableFromDelimitedString;

    PCREATE_STRING_TABLE_FROM_DELIMITED_ENVIRONMENT_VARIABLE
        CreateStringTableFromDelimitedEnvironmentVariable;

    PIS_STRING_IN_TABLE IsStringInTable;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable;

} STRING_TABLE_API;
typedef STRING_TABLE_API *PSTRING_TABLE_API;

typedef struct _STRING_TABLE_API_EX {

    //
    // Inline STRING_TABLE_API.
    //

    PSET_C_SPECIFIC_HANDLER SetCSpecificHandler;

    PCOPY_STRING_ARRAY CopyStringArray;
    PCREATE_STRING_TABLE CreateStringTable;
    PDESTROY_STRING_TABLE DestroyStringTable;

    PINITIALIZE_STRING_TABLE_ALLOCATOR
        InitializeStringTableAllocator;

    PINITIALIZE_STRING_TABLE_ALLOCATOR_FROM_RTL_BOOTSTRAP
        InitializeStringTableAllocatorFromRtlBootstrap;

    PCREATE_STRING_ARRAY_FROM_DELIMITED_STRING
        CreateStringArrayFromDelimitedString;

    PCREATE_STRING_TABLE_FROM_DELIMITED_STRING
        CreateStringTableFromDelimitedString;

    PCREATE_STRING_TABLE_FROM_DELIMITED_ENVIRONMENT_VARIABLE
        CreateStringTableFromDelimitedEnvironmentVariable;

    PIS_STRING_IN_TABLE IsStringInTable;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable;

    //
    // Extended API methods used for benchmarking.
    //

    PIS_PREFIX_OF_CSTR_IN_ARRAY IsPrefixOfCStrInArray;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_1;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_2;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_3;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_4;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_5;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_6;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_7;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_8;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_9;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_10;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_x64_1;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_x64_2;
    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_x64_3;
    PIS_PREFIX_OF_STRING_IN_TABLE IntegerDivision_x64_1;

} STRING_TABLE_API_EX;
typedef STRING_TABLE_API_EX *PSTRING_TABLE_API_EX;

typedef union _STRING_TABLE_ANY_API {
    STRING_TABLE_API Api;
    STRING_TABLE_API_EX ApiEx;
} STRING_TABLE_ANY_API;
typedef STRING_TABLE_ANY_API *PSTRING_TABLE_ANY_API;

FORCEINLINE
BOOLEAN
LoadStringTableApi(
    _In_ PRTL Rtl,
    _Inout_ HMODULE *ModulePointer,
    _In_opt_ PUNICODE_STRING ModulePath,
    _In_ ULONG SizeOfAnyApi,
    _Out_writes_bytes_all_(SizeOfAnyApi) PSTRING_TABLE_ANY_API AnyApi
    )
/*++

Routine Description:

    Loads the string table module and resolves all API functions for either
    the STRING_TABLE_API or STRING_TABLE_API_EX structure.  The desired API
    is indicated by the SizeOfAnyApi parameter.

    Example use:

        STRING_TABLE_API_EX GlobalApi;
        PSTRING_TABLE_API_EX Api;

        Success = LoadStringTableApi(Rtl,
                                     NULL,
                                     NULL,
                                     sizeof(GlobalApi),
                                     (PSTRING_TABLE_ANY_API)&amp;GlobalApi);
        ASSERT(Success);
        Api = &amp;GlobalApi;

    In this example, the extended API will be provided as our sizeof(GlobalApi)
    will indicate the structure size used by STRING_TABLE_API_EX.

    See ../StringTable2BenchmarkExe/main.c for a complete example.

Arguments:

    Rtl - Supplies a pointer to an initialized RTL structure.

    ModulePointer - Optionally supplies a pointer to an existing module handle
        for which the API symbols are to be resolved.  May be NULL.  If not
        NULL, but the pointed-to value is NULL, then this parameter will
        receive the handle obtained by LoadLibrary() as part of this call.
        If the string table module is no longer needed, but the program will
        keep running, the caller should issue a FreeLibrary() against this
        module handle.

    ModulePath - Optionally supplies a pointer to a UNICODE_STRING structure
        representing a path name of the string table module to be loaded.
        If *ModulePointer is not NULL, it takes precedence over this parameter.
        If NULL, and no module has been provided via *ModulePointer, an attempt
        will be made to load the library via 'LoadLibraryA("StringTable.dll")'.

    SizeOfAnyApi - Supplies the size, in bytes, of the underlying structure
        pointed to by the AnyApi parameter.

    AnyApi - Supplies the address of a structure which will receive resolved
        API function pointers.  The API furnished will depend on the size
        indicated by the SizeOfAnyApi parameter.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL Success;
    HMODULE Module = NULL;
    ULONG NumberOfSymbols;
    ULONG NumberOfResolvedSymbols;

    //
    // Define the API names.
    //
    // N.B. These names must match STRING_TABLE_API_EX exactly (including the
    //      order).
    //

    CONST PCSTR Names[] = {
        "SetCSpecificHandler",
        "CopyStringArray",
        "CreateStringTable",
        "DestroyStringTable",
        "InitializeStringTableAllocator",
        "InitializeStringTableAllocatorFromRtlBootstrap",
        "CreateStringArrayFromDelimitedString",
        "CreateStringTableFromDelimitedString",
        "CreateStringTableFromDelimitedEnvironmentVariable",
        "IsStringInTable",
        "IsPrefixOfStringInTable",
        "IsPrefixOfCStrInArray",
        "IsPrefixOfStringInTable_1",
        "IsPrefixOfStringInTable_2",
        "IsPrefixOfStringInTable_3",
        "IsPrefixOfStringInTable_4",
        "IsPrefixOfStringInTable_5",
        "IsPrefixOfStringInTable_6",
        "IsPrefixOfStringInTable_7",
        "IsPrefixOfStringInTable_8",
        "IsPrefixOfStringInTable_9",
        "IsPrefixOfStringInTable_10",
        "IsPrefixOfStringInTable_x64_1",
        "IsPrefixOfStringInTable_x64_2",
        "IsPrefixOfStringInTable_x64_3",
        "IntegerDivision_x64_1",
    };

    //
    // Define an appropriately sized bitmap we can passed to Rtl-&gt;LoadSymbols().
    //

    ULONG BitmapBuffer[(ALIGN_UP(ARRAYSIZE(Names), sizeof(ULONG) &lt;&lt; 3) &gt;&gt; 5)+1];
    RTL_BITMAP FailedBitmap = { ARRAYSIZE(Names)+1, (PULONG)&amp;BitmapBuffer };

    //
    // Determine the number of symbols we want to resolve based on the size of
    // the API indicated by the caller.
    //

    if (SizeOfAnyApi == sizeof(AnyApi-&gt;Api)) {
        NumberOfSymbols = sizeof(AnyApi-&gt;Api) / sizeof(ULONG_PTR);
    } else if (SizeOfAnyApi == sizeof(AnyApi-&gt;ApiEx)) {
        NumberOfSymbols = sizeof(AnyApi-&gt;ApiEx) / sizeof(ULONG_PTR);
    } else {
        return FALSE;
    }

    //
    // Attempt to load the underlying string table module if necessary.
    //

    if (ARGUMENT_PRESENT(ModulePointer)) {
        Module = *ModulePointer;
    }

    if (!Module) {
        if (ARGUMENT_PRESENT(ModulePath)) {
            Module = LoadLibraryW(ModulePath-&gt;Buffer);
        } else {
            Module = LoadLibraryA("StringTable2.dll");
        }
    }

    if (!Module) {
        return FALSE;
    }

    //
    // We've got a handle to the string table module.  Load the symbols we want
    // dynamically via Rtl-&gt;LoadSymbols().
    //

    Success = Rtl-&gt;LoadSymbols(
        Names,
        NumberOfSymbols,
        (PULONG_PTR)AnyApi,
        NumberOfSymbols,
        Module,
        &amp;FailedBitmap,
        TRUE,
        &amp;NumberOfResolvedSymbols
    );

    ASSERT(Success);

    //
    // Debug helper: if the breakpoint below is hit, then the symbol names
    // have potentially become out of sync.  Look at the value of first failed
    // symbol to assist in determining the cause.
    //

    if (NumberOfSymbols != NumberOfResolvedSymbols) {
        PCSTR FirstFailedSymbolName;
        ULONG FirstFailedSymbol;
        ULONG NumberOfFailedSymbols;

        NumberOfFailedSymbols = Rtl-&gt;RtlNumberOfSetBits(&amp;FailedBitmap);
        FirstFailedSymbol = Rtl-&gt;RtlFindSetBits(&amp;FailedBitmap, 1, 0);
        FirstFailedSymbolName = Names[FirstFailedSymbol-1];
        __debugbreak();
    }

    //
    // Set the C specific handler for the module, such that structured
    // exception handling will work.
    //

    AnyApi-&gt;Api.SetCSpecificHandler(Rtl-&gt;__C_specific_handler);

    //
    // Update the caller's pointer and return success.
    //

    if (ARGUMENT_PRESENT(ModulePointer)) {
        *ModulePointer = Module;
    }

    return TRUE;
}

</code></pre>


                <h1>Appendix</h1>

                <p>

                    And now here's all the stuff that wasn't important enough to occur earlier in
                    the article.

                </p>

                <a class="xref" name="CreateStringTable"></a>
                <h2>String Table Construction</h2>

                <p>

                    The <a
                    href="https://github.com/tpn/tracer/blob/2018-04-18.2/StringTable2/CreateStringTable.c#L147">
                    CreateSingleStringTable</a> routine is responsible for construction of a new
                    STRING_TABLE.  It is here we identify the unique set of characters (and their
                    indices) to store in the first two fields of the string table.  The code is
                    provided below.

                </p>

<pre class="code content-typedefs"><code class="language-c">
_Use_decl_annotations_
PSTRING_TABLE
CreateSingleStringTable(
    PRTL Rtl,
    PALLOCATOR StringTableAllocator,
    PALLOCATOR StringArrayAllocator,
    PSTRING_ARRAY StringArray,
    BOOL CopyArray
    )
/*++

Routine Description:

    Allocates space for a STRING_TABLE structure using the provided allocators,
    then initializes it using the provided STRING_ARRAY.  If CopyArray is set
    to TRUE, the routine will copy the string array such that the caller is
    free to destroy it after the table has been successfully created.  If it
    is set to FALSE and StringArray-&gt;StringTable has a non-NULL value, it is
    assumed that sufficient space has already been allocated for the string
    table and this pointer will be used to initialize the rest of the structure.

    DestroyStringTable() must be called against the returned PSTRING_TABLE when
    the structure is no longer needed in order to ensure resources are released.

Arguments:

    Rtl - Supplies a pointer to an initialized RTL structure.

    StringTableAllocator - Supplies a pointer to an ALLOCATOR structure which
        will be used for creating the STRING_TABLE.

    StringArrayAllocator - Supplies a pointer to an ALLOCATOR structure which
        may be used to create the STRING_ARRAY if it cannot fit within the
        padding of the STRING_TABLE structure.  This is kept separate from the
        StringTableAllocator due to the stringent alignment requirements of the
        string table.

    StringArray - Supplies a pointer to an initialized STRING_ARRAY structure
        that contains the STRING structures that are to be added to the table.

    CopyArray - Supplies a boolean value indicating whether or not the
        StringArray structure should be deep-copied during creation.  This is
        typically set when the caller wants to be able to free the structure
        as soon as this call returns (or can't guarantee it will persist past
        this function's invocation, i.e. if it was stack allocated).

Return Value:

    A pointer to a valid PSTRING_TABLE structure on success, NULL on failure.
    Call DestroyStringTable() on the returned structure when it is no longer
    needed in order to ensure resources are cleaned up appropriately.

--*/
{
    BYTE Byte;
    BYTE Count;
    BYTE Index;
    BYTE Length;
    BYTE NumberOfElements;
    ULONG HighestBit;
    ULONG OccupiedMask;
    PULONG Bits;
    USHORT OccupiedBitmap;
    USHORT ContinuationBitmap;
    PSTRING_TABLE StringTable;
    PSTRING_ARRAY StringArray;
    PSTRING String;
    PSTRING_SLOT Slot;
    STRING_SLOT UniqueChars;
    SLOT_INDEX UniqueIndex;
    SLOT_INDEX LengthIndex;
    SLOT_LENGTHS Lengths;
    LENGTH_INDEX_TABLE LengthIndexTable;
    PCHARACTER_BITMAP Bitmap;
    SLOT_BITMAPS SlotBitmaps;
    PLENGTH_INDEX_ENTRY Entry;

    //
    // Validate arguments.
    //

    if (!ARGUMENT_PRESENT(StringTableAllocator)) {
        return NULL;
    }

    if (!ARGUMENT_PRESENT(StringArrayAllocator)) {
        return NULL;
    }

    if (!ARGUMENT_PRESENT(SourceStringArray)) {
        return NULL;
    }

    if (SourceStringArray-&gt;NumberOfElements == 0) {
        return NULL;
    }

    //
    // Copy the incoming string array if applicable.
    //

    if (CopyArray) {

        StringArray = CopyStringArray(
            StringTableAllocator,
            StringArrayAllocator,
            SourceStringArray,
            FIELD_OFFSET(STRING_TABLE, StringArray),
            sizeof(STRING_TABLE),
            &amp;StringTable
        );

        if (!StringArray) {
            return NULL;
        }

    } else {

        //
        // We're not copying the array, so initialize StringArray to point at
        // the caller's SourceStringArray, and StringTable to point at the
        // array's StringTable field (which will be non-NULL if sufficient
        // space has been allocated).
        //

        StringArray = SourceStringArray;
        StringTable = StringArray-&gt;StringTable;

    }

    //
    // If StringTable has no value, we've either been called with CopyArray set
    // to FALSE, or CopyStringArray() wasn't able to allocate sufficient space
    // for both the table and itself.  Either way, we need to allocate space for
    // the table.
    //

    if (!StringTable) {

        StringTable = (PSTRING_TABLE)(
            StringTableAllocator-&gt;AlignedCalloc(
                StringTableAllocator-&gt;Context,
                1,
                sizeof(STRING_TABLE),
                STRING_TABLE_ALIGNMENT
            )
        );

        if (!StringTable) {
            return NULL;
        }
    }

    //
    // Make sure the fields that are sensitive to alignment are, in fact,
    // aligned correctly.
    //

    if (!AssertStringTableFieldAlignment(StringTable)) {
        DestroyStringTable(StringTableAllocator,
                           StringArrayAllocator,
                           StringTable);
        return NULL;
    }

    //
    // At this point, we have copied the incoming StringArray if necessary,
    // and we've allocated sufficient space for the StringTable structure.
    // Enumerate over all of the strings, set the continuation bit if the
    // length &gt; 16, set the relevant slot length, set the relevant unique
    // character entry, then move the first 16-bytes of the string into the
    // relevant slot via an aligned SSE mov.
    //

    //
    // Initialize pointers and counters, clear stack-based structures.
    //

    Slot = StringTable-&gt;Slots;
    String = StringArray-&gt;Strings;

    OccupiedBitmap = 0;
    ContinuationBitmap = 0;
    NumberOfElements = (BYTE)StringArray-&gt;NumberOfElements;
    UniqueChars.CharsXmm = _mm_setzero_si128();
    UniqueIndex.IndexXmm = _mm_setzero_si128();
    LengthIndex.IndexXmm = _mm_setzero_si128();

    //
    // Set all the slot lengths to 0x7f up front instead of defaulting
    // to zero.  This allows for simpler logic when searching for a prefix
    // string, which involves broadcasting a search string's length to an XMM
    // register, then doing _mm_cmpgt_epi8() against the lengths array and
    // the string length.  If we left the lengths as 0 for unused slots, they
    // would get included in the resulting comparison register (i.e. the high
    // bits would be set to 1), so we'd have to do a subsequent masking of
    // the result at some point using the OccupiedBitmap.  By defaulting the
    // lengths to 0x7f, we ensure they'll never get included in any cmpgt-type
    // SIMD matches.  (We use 0x7f instead of 0xff because the _mm_cmpgt_epi8()
    // intrinsic assumes packed signed integers.)
    //

    Lengths.SlotsXmm = _mm_set1_epi8(0x7f);

    ZeroStruct(LengthIndexTable);
    ZeroStruct(SlotBitmaps);

    for (Count = 0; Count &lt; NumberOfElements; Count++) {

        XMMWORD CharsXmm;

        //
        // Set the string length for the slot.
        //

        Length = Lengths.Slots[Count] = (BYTE)String-&gt;Length;

        //
        // Set the appropriate bit in the continuation bitmap if the string is
        // longer than 16 bytes.
        //

        if (Length &gt; 16) {
            ContinuationBitmap |= (Count == 0 ? 1 : 1 &lt;&lt; (Count + 1));
        }

        if (Count == 0) {

            Entry = &amp;LengthIndexTable.Entry[0];
            Entry-&gt;Index = 0;
            Entry-&gt;Length = Length;

        } else {

            //
            // Perform a linear scan of the length-index table in order to
            // identify an appropriate insertion point.
            //

            for (Index = 0; Index &lt; Count; Index++) {
                if (Length &lt; LengthIndexTable.Entry[Index].Length) {
                    break;
                }
            }

            if (Index != Count) {

                //
                // New entry doesn't go at the end of the table, so shuffle
                // everything else down.
                //

                Rtl-&gt;RtlMoveMemory(&amp;LengthIndexTable.Entry[Index + 1],
                                   &amp;LengthIndexTable.Entry[Index],
                                   (Count - Index) * sizeof(*Entry));
            }

            Entry = &amp;LengthIndexTable.Entry[Index];
            Entry-&gt;Index = Count;
            Entry-&gt;Length = Length;
        }

        //
        // Copy the first 16-bytes of the string into the relevant slot.  We
        // have taken care to ensure everything is 16-byte aligned by this
        // stage, so we can use SSE intrinsics here.
        //

        CharsXmm = _mm_load_si128((PXMMWORD)String-&gt;Buffer);
        _mm_store_si128(&amp;(*Slot).CharsXmm, CharsXmm);

        //
        // Advance our pointers.
        //

        ++Slot;
        ++String;

    }

    //
    // Store the slot lengths.
    //

    _mm_store_si128(&amp;(StringTable-&gt;Lengths.SlotsXmm), Lengths.SlotsXmm);

    //
    // Loop through the strings in order of shortest to longest and construct
    // the uniquely-identifying character table with corresponding index.
    //


    for (Count = 0; Count &lt; NumberOfElements; Count++) {
        Entry = &amp;LengthIndexTable.Entry[Count];
        Length = Entry-&gt;Length;
        Slot = &amp;StringTable-&gt;Slots[Entry-&gt;Index];

        //
        // Iterate over each character in the slot and find the first one
        // without a corresponding bit set.
        //

        for (Index = 0; Index &lt; Length; Index++) {
            Bitmap = &amp;SlotBitmaps.Bitmap[Index];
            Bits = (PULONG)&amp;Bitmap-&gt;Bits[0];
            Byte = Slot-&gt;Char[Index];
            if (!BitTestAndSet(Bits, Byte)) {
                break;
            }
        }

        UniqueChars.Char[Count] = Byte;
        UniqueIndex.Index[Count] = Index;
        LengthIndex.Index[Count] = Entry-&gt;Index;
    }

    //
    // Loop through the elements again such that the unique chars are stored
    // in the order they appear in the table.
    //

    for (Count = 0; Count &lt; NumberOfElements; Count++) {
        for (Index = 0; Index &lt; NumberOfElements; Index++) {
            if (LengthIndex.Index[Index] == Count) {
                StringTable-&gt;UniqueChars.Char[Count] = UniqueChars.Char[Index];
                StringTable-&gt;UniqueIndex.Index[Count] = UniqueIndex.Index[Index];
                break;
            }
        }
    }

    //
    // Generate and store the occupied bitmap.  Each bit, from low to high,
    // corresponds to the index of a slot.  When set, the slot is occupied.
    // When clear, it is not.  So, fill bits from the highest bit set down.
    //

    HighestBit = (1 &lt;&lt; (StringArray-&gt;NumberOfElements-1));
    OccupiedMask = _blsmsk_u32(HighestBit);
    StringTable-&gt;OccupiedBitmap = (USHORT)OccupiedMask;

    //
    // Store the continuation bitmap.
    //

    StringTable-&gt;ContinuationBitmap = (USHORT)(ContinuationBitmap);

    //
    // Wire up the string array to the table.
    //

    StringTable-&gt;pStringArray = StringArray;

    //
    // And we're done, return the table.
    //

    return StringTable;
}
</code></pre>

                <a class="xref" name="release-vs-pgo"></a>
                <h3>Release Build versus Profile Guided Optimization Build</h3>

                <p>

                    It's interesting to see a side-by-side comparison of the optimized release build
                    next to the PGO build:

                </p>

                <!--
                <picture>
                    <source srcset="IsPrefixOfStringInTable_13-Release-vs-PGO.png"/>
                    <img width="1664px" height="3224px" srcset="PrefixOfStringInTable_13-Release-vs-PGO.png"/>
                </picture>
                -->


                <a class="xref" name="typedefs"></a>
                <h4>Typedefs</h4>

                <p>

                    If there's one thing you can't argue about with the Pascal-style Cutler Normal
                    Form, is that it loves a good typedef.  For the sake of completeness, here's a
                    list of all the explicit or implied typedefs featured in the code on this page.

                </p>

<pre class="code content-typedefs"><code class="language-c">

//
// Standard NT/Windows typedefs (typically living in minwindef.h).
//

typedef void *PVOID;
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef _Null_terminated_ char *PSZ;
typedef const _Null_terminated_ char *PCSZ;

typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;

typedef BYTE BOOLEAN;
typedef BOOLEAN *PBOOLEAN;

//
// The STRING structure used by the NT kernel.  Our STRING_ARRAY structure
// relies on an array of these structures.  We never pass raw 'char *'s
// around, only STRING/PSTRING structs/pointers.
//

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    ULONG  Padding;
    PCHAR Buffer;
} STRING, *PSTRING;
typedef const STRING *PCSTRING;

//
// Our SIMD register typedefs.
//

typedef __m128i DECLSPEC_ALIGN(16) XMMWORD, *PXMMWORD, **PPXMMWORD;
typedef __m256i DECLSPEC_ALIGN(32) YMMWORD, *PYMMWORD, **PPYMMWORD;
typedef __m512i DECLSPEC_ALIGN(64) ZMMWORD, *PZMMWORD, **PPZMMWORD;

</code></pre>


            </div>

        </section>

        <section class="section section-comments">
            <div class="container">
                <p>
                    <hr/>
                </p>
                <div id="disqus_thread"></div>
                <script>
                    var disqus_config = function () {
                        this.page.url = "http://trent.me/is-prefix-of-string-in-table";
                        this.page.identifier = "is-prefix-of-string-in-table";
                    };

                    (function() {
                        var d = document, s = d.createElement('script');
                        s.src = 'https://trent-me.disqus.com/embed.js';
                        s.setAttribute('data-timestamp', +new Date());
                        (d.head || d.body).appendChild(s);
                    })();

                </script>
            </div>
        </section>

        <section class="section section-footer">
            <div class="container">
                <small>
                    <p>
                        <a
                        href="https://github.com/tpn/website/blob/master/is-prefix-of-string-in-table/index.html">
                        View this page's source on GitHub.</a>
                    </p>
                    <p>
                        <a href="https://twitter.com/trentnelson" class="twitter-follow-button" data-show-count="false">Follow @trentnelson</a>
                        <iframe src="https://ghbtns.com/github-btn.html?user=tpn&type=follow" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>
                    </p>
                </small>
            </div>
        </section>

        <!-- Twitter/Analytics -->
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

        <script type="text/javascript">
            // Google Analytics
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-24686252-1', 'auto');
            ga('send', 'pageview');
        </script>

    </body>
</html>
