[
  {
    "objectID": "tools/pyscript/index.html",
    "href": "tools/pyscript/index.html",
    "title": "PyScript Test",
    "section": "",
    "text": "Hello world!  This is the current date and time, as computed by Python:"
  },
  {
    "objectID": "syntax-highlighter-test.html",
    "href": "syntax-highlighter-test.html",
    "title": "Test Syntax Highlighting",
    "section": "",
    "text": "Assembly Slim (fasm)Assembly Slim (asm)Assembly Full (asm)Assembly Full (fasm)CDiff AsmIACA\n\n\nmov      rax,  String.Buffer[rdx]                   ; Load address of string buffer.\nvpbroadcastb xmm4, byte ptr String.Length[rdx]      ; Broadcast string length.\nvmovdqa  xmm3, xmmword ptr StringTable.Lengths[rcx] ; Load table lengths.\nvmovdqu  xmm0, xmmword ptr [rax]                    ; Load string buffer.\nvpcmpgtb xmm1, xmm3, xmm4                           ; Identify slots &gt; string len.\nvpshufb  xmm5, xmm0, StringTable.UniqueIndex[rcx]   ; Rearrange string by unique index.\nvpcmpeqb xmm5, xmm5, StringTable.UniqueChars[rcx]   ; Compare rearranged to unique.\nvptest   xmm1, xmm5                                 ; Unique slots AND (!long slots).\njnc      short Pfx10                                ; CY=0, continue with routine.\nxor      eax, eax                                   ; CY=1, no match.\nnot      al                                         ; al = -1 (NO_MATCH_FOUND).\nret                                                 ; Return NO_MATCH_FOUND.\n\n\nmov      rax,  String.Buffer[rdx]                   ; Load address of string buffer.\nvpbroadcastb xmm4, byte ptr String.Length[rdx]      ; Broadcast string length.\nvmovdqa  xmm3, xmmword ptr StringTable.Lengths[rcx] ; Load table lengths.\nvmovdqu  xmm0, xmmword ptr [rax]                    ; Load string buffer.\nvpcmpgtb xmm1, xmm3, xmm4                           ; Identify slots &gt; string len.\nvpshufb  xmm5, xmm0, StringTable.UniqueIndex[rcx]   ; Rearrange string by unique index.\nvpcmpeqb xmm5, xmm5, StringTable.UniqueChars[rcx]   ; Compare rearranged to unique.\nvptest   xmm1, xmm5                                 ; Unique slots AND (!long slots).\njnc      short Pfx10                                ; CY=0, continue with routine.\nxor      eax, eax                                   ; CY=1, no match.\nnot      al                                         ; al = -1 (NO_MATCH_FOUND).\nret                                                 ; Return NO_MATCH_FOUND.\n\n\n;++\n;\n; STRING_TABLE_INDEX\n; IsPrefixOfStringInTable_x64_*(\n;     _In_ PSTRING_TABLE StringTable,\n;     _In_ PSTRING String,\n;     _Out_opt_ PSTRING_MATCH Match\n;     )\n;\n; Routine Description:\n;\n;   Searches a string table to see if any strings \"prefix match\" the given\n;   search string.  That is, whether any string in the table \"starts with\n;   or is equal to\" the search string.\n;\n; Arguments:\n;\n;   StringTable - Supplies a pointer to a STRING_TABLE struct.\n;\n;   String - Supplies a pointer to a STRING struct that contains the string to\n;       search for.\n;\n;   Match - Optionally supplies a pointer to a variable that contains the\n;       address of a STRING_MATCH structure.  This will be populated with\n;       additional details about the match if a non-NULL pointer is supplied.\n;\n; Return Value:\n;\n;   Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n;\n;--\n\n        LEAF_ENTRY IsPrefixOfStringInTable_x64_1, _TEXT$00\n\n        ;IACA_VC_START\n\n;\n; Load the string buffer into xmm0, and the unique indexes from the string table\n; into xmm1.  Shuffle the buffer according to the unique indexes, and store the\n; result back into xmm0.\n;\n\n        mov     rax, String.Buffer[rdx]\n        vmovdqu xmm0, xmmword ptr [rax]                 ; Load search buffer.\n        vmovdqa xmm1, xmmword ptr StringTable.UniqueIndex[rcx] ; Load indexes.\n        vpshufb xmm0, xmm0, xmm1\n\n;\n; Load the string table's unique character array into xmm2, and the lengths for\n; each string slot into xmm3.\n;\n\n        vmovdqa xmm2, xmmword ptr StringTable.UniqueChars[rcx]  ; Load chars.\n        vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]      ; Load lengths.\n\n;\n; Set xmm5 to all ones.  This is used later.\n;\n\n        vpcmpeqq    xmm5, xmm5, xmm5                    ; Set xmm5 to all ones.\n\n;\n; Broadcast the byte-sized string length into xmm4.\n;\n\n        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.\n\n;\n; Compare the search string's unique character array (xmm0) against the string\n; table's unique chars (xmm2), saving the result back into xmm0.\n;\n\n        vpcmpeqb    xmm0, xmm0, xmm2            ; Compare unique chars.\n\n;\n; Compare the search string's length, which we've broadcasted to all 8-byte\n; elements of the xmm4 register, to the lengths of the slots in the string\n; table, to find those that are greater in length.  Invert the result, such\n; that we're left with a masked register where each 0xff element indicates\n; a slot with a length less than or equal to our search string's length.\n;\n\n        vpcmpgtb    xmm1, xmm4, xmm3            ; Identify long slots.\n        vpxor       xmm1, xmm1, xmm5            ; Invert the result.\n\n;\n; Intersect-via-test xmm0 and xmm1 to identify string slots of a suitable\n; length with a matching unique character.\n;\n\n        vptest      xmm0, xmm1                  ; Check for no match.\n        ;jnz        short @F                    ; There was a match.\n                                                ; (Not yet implemented.)\n\n;\n; No match, set rax to -1 and return.\n;\n\n        xor         eax, eax                    ;\n        not         al                          ; rax = -1\n        ret\n\n        ;IACA_VC_END\n        LEAF_END   IsPrefixOfStringInTable_x64_1, _TEXT$00\n\n; vim:set tw=80 ts=8 sw=4 sts=4 et syntax=masm fo=croql comments=\\:;           :\n\n\n;++\n;\n; STRING_TABLE_INDEX\n; IsPrefixOfStringInTable_x64_*(\n;     _In_ PSTRING_TABLE StringTable,\n;     _In_ PSTRING String,\n;     _Out_opt_ PSTRING_MATCH Match\n;     )\n;\n; Routine Description:\n;\n;   Searches a string table to see if any strings \"prefix match\" the given\n;   search string.  That is, whether any string in the table \"starts with\n;   or is equal to\" the search string.\n;\n; Arguments:\n;\n;   StringTable - Supplies a pointer to a STRING_TABLE struct.\n;\n;   String - Supplies a pointer to a STRING struct that contains the string to\n;       search for.\n;\n;   Match - Optionally supplies a pointer to a variable that contains the\n;       address of a STRING_MATCH structure.  This will be populated with\n;       additional details about the match if a non-NULL pointer is supplied.\n;\n; Return Value:\n;\n;   Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n;\n;--\n\n        LEAF_ENTRY IsPrefixOfStringInTable_x64_1, _TEXT$00\n\n        ;IACA_VC_START\n\n;\n; Load the string buffer into xmm0, and the unique indexes from the string table\n; into xmm1.  Shuffle the buffer according to the unique indexes, and store the\n; result back into xmm0.\n;\n\n        mov     rax, String.Buffer[rdx]\n        vmovdqu xmm0, xmmword ptr [rax]                 ; Load search buffer.\n        vmovdqa xmm1, xmmword ptr StringTable.UniqueIndex[rcx] ; Load indexes.\n        vpshufb xmm0, xmm0, xmm1\n\n;\n; Load the string table's unique character array into xmm2, and the lengths for\n; each string slot into xmm3.\n;\n\n        vmovdqa xmm2, xmmword ptr StringTable.UniqueChars[rcx]  ; Load chars.\n        vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]      ; Load lengths.\n\n;\n; Set xmm5 to all ones.  This is used later.\n;\n\n        vpcmpeqq    xmm5, xmm5, xmm5                    ; Set xmm5 to all ones.\n\n;\n; Broadcast the byte-sized string length into xmm4.\n;\n\n        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.\n\n;\n; Compare the search string's unique character array (xmm0) against the string\n; table's unique chars (xmm2), saving the result back into xmm0.\n;\n\n        vpcmpeqb    xmm0, xmm0, xmm2            ; Compare unique chars.\n\n;\n; Compare the search string's length, which we've broadcasted to all 8-byte\n; elements of the xmm4 register, to the lengths of the slots in the string\n; table, to find those that are greater in length.  Invert the result, such\n; that we're left with a masked register where each 0xff element indicates\n; a slot with a length less than or equal to our search string's length.\n;\n\n        vpcmpgtb    xmm1, xmm4, xmm3            ; Identify long slots.\n        vpxor       xmm1, xmm1, xmm5            ; Invert the result.\n\n;\n; Intersect-via-test xmm0 and xmm1 to identify string slots of a suitable\n; length with a matching unique character.\n;\n\n        vptest      xmm0, xmm1                  ; Check for no match.\n        ;jnz        short @F                    ; There was a match.\n                                                ; (Not yet implemented.)\n\n;\n; No match, set rax to -1 and return.\n;\n\n        xor         eax, eax                    ;\n        not         al                          ; rax = -1\n        ret\n\n        ;IACA_VC_END\n\n        LEAF_END   IsPrefixOfStringInTable_x64_1, _TEXT$00\n\n; vim:set tw=80 ts=8 sw=4 sts=4 et syntax=masm fo=croql comments=\\:;           :\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_11(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This version is based off version 10, but with the vpandn used at the\n    end of the initial test, as suggested by Wojciech Mula (@pshufb).\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlots;\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we do the \"and not\" intersection with the include slots next.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // We're now ready to intersect the two XMM registers to determine which\n    // slots should still be included in the comparison (i.e. which slots have\n    // the exact same unique character as the string and a length less than or\n    // equal to the length of the search string).\n    //\n    // As the IgnoreSlotsByLength XMM register is the inverse of what we want\n    // at the moment (we want 0xff for slots to include, and 0x00 for slots\n    // to ignore; it's currently the other way around), we use _mm_andnot_si128\n    // instead of just _mm_and_si128.\n    //\n\n    IncludeSlots = _mm_andnot_si128(IgnoreSlotsByLength,\n                                    IncludeSlotsByUniqueChar);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    if (!Bitmap) {\n\n        //\n        // No bits were set, so there are no strings in this table starting\n        // with the same character and of a lesser or equal length as the\n        // search string.\n        //\n\n        return NO_MATCH_FOUND;\n    }\n\n    //\n    // Calculate the \"search length\" of the incoming string, which ensures we\n    // only compare up to the first 16 characters.\n    //\n\n    SearchLength = min(String-&gt;Length, 16);\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched &lt; Length && Length &lt;= 16) {\n\n            //\n            // The slot length is longer than the number of characters matched\n            // from the search string; this isn't a prefix match.  Continue.\n            //\n\n            continue;\n        }\n\n        if (Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n            }\n        }\n\n        //\n        // This slot is a prefix match.  Fill out the Match structure if the\n        // caller provided a non-NULL pointer, then return the index of the\n        // match.\n        //\n\n        if (ARGUMENT_PRESENT(Match)) {\n\n            Match-&gt;Index = (BYTE)Index;\n            Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n            Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n        }\n\n        return (STRING_TABLE_INDEX)Index;\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n% diff -u IsPrefixOfStringInTable_x64_2.asm IsPrefixOfStringInTable_x64_4.asm\n--- IsPrefixOfStringInTable_x64_2.asm   2018-04-26 14:15:53.805409700 -0400\n+++ IsPrefixOfStringInTable_x64_4.asm   2018-04-26 14:16:37.909717200 -0400\n@@ -33,6 +33,10 @@\n ;   search string.  That is, whether any string in the table \"starts with\n ;   or is equal to\" the search string.\n ;\n+;   This routine is based off version 2, but leverages the fact that\n+;   vptest sets the carry flag if '(xmm0 and (not xmm1))' evaluates\n+;   to all 0s, avoiding the the need to do the pxor or pandn steps.\n+;\n ; Arguments:\n ;\n ;   StringTable - Supplies a pointer to a STRING_TABLE struct.\n@@ -50,7 +54,7 @@\n ;\n ;--\n\n-        LEAF_ENTRY IsPrefixOfStringInTable_x64_2, _TEXT$00\n+        LEAF_ENTRY IsPrefixOfStringInTable_x64_4, _TEXT$00\n\n ;\n ; Load the string buffer into xmm0, and the unique indexes from the string table\n@@ -83,12 +87,6 @@\n         vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]      ; Load lengths.\n\n ;\n-; Set xmm2 to all ones.  We use this later to invert the length comparison.\n-;\n-\n-        vpcmpeqq    xmm2, xmm2, xmm2            ; Set xmm2 to all ones.\n-\n-;\n ; Broadcast the byte-sized string length into xmm4.\n ;\n\n@@ -103,16 +101,16 @@\n ;\n\n         vpcmpgtb    xmm1, xmm3, xmm4            ; Identify long slots.\n-        vpxor       xmm1, xmm1, xmm2            ; Invert the result.\n\n ;\n ; Intersect-and-test the unique character match xmm mask register (xmm5) with\n-; the length match mask xmm register (xmm1).  This affects flags, allowing us\n-; to do a fast-path exit for the no-match case (where ZF = 1).\n+; the inverted length match mask xmm register (xmm1).  This will set the carry\n+; flag (CY = 1) if the result of 'xmm5 and (not xmm1)' is all 0s, which allows\n+; us to do a fast-path exit for the no-match case.\n ;\n\n-        vptest      xmm5, xmm1                  ; Check for no match.\n-        jnz         short Pfx10                 ; There was a match.\n+        vptest      xmm1, xmm5                  ; Check for no match.\n+        jnc         short Pfx10                 ; There was a match.\n\n ;\n ; No match, set rax to -1 and return.\n@@ -159,12 +157,12 @@\n         vpinsrq     xmm2, xmm2, rdx, 1          ; Save rdx into xmm2q[1].\n\n ;\n-; Intersect xmm5 and xmm1 (as we did earlier with the 'vptest xmm5, xmm1'),\n+; Intersect xmm5 and xmm1 (as we did earlier with the 'vptest xmm1, xmm5'),\n ; yielding a mask identifying indices we need to perform subsequent matches\n ; upon.  Convert this into a bitmap and save in xmm2d[2].\n ;\n\n-        vpand       xmm5, xmm5, xmm1            ; Intersect unique + lengths.\n+        vpandn      xmm5, xmm1, xmm5            ; Intersect unique + lengths.\n         vpmovmskb   edx, xmm5                   ; Generate a bitmap from mask.\n\n ;\n@@ -473,7 +471,7 @@\n\n         ;IACA_VC_END\n\n-        LEAF_END   IsPrefixOfStringInTable_x64_2, _TEXT$00\n+        LEAF_END   IsPrefixOfStringInTable_x64_4, _TEXT$00\n\n ; vim:set tw=80 ts=8 sw=4 sts=4 et syntax=masm fo=croql comments=\\:;           :\n\n\nS:\\Source\\tracer&gt;iaca x64\\Release\\StringTable2.dll\nIntel(R) Architecture Code Analyzer\nVersion -  v3.0-28-g1ba2cbb build date: 2017-10-23;17:30:24\nAnalyzed File -  x64\\Release\\StringTable2.dll\nBinary Format - 64Bit\nArchitecture  -  SKL\nAnalysis Type - Throughput\n\nThroughput Analysis Report\n--------------------------\nBlock Throughput: 3.48 Cycles       Throughput Bottleneck: FrontEnd\nLoop Count:  24\nPort Binding In Cycles Per Iteration:\n----------------------------------------------------------------------------\n| Port   |  0  - DV  |  1  |  2  - D   |  3  - D   |  4  |  5  |  6  |  7  |\n----------------------------------------------------------------------------\n| Cycles | 2.0   0.0 | 1.0 | 3.5   3.5 | 3.5   3.5 | 0.0 | 3.0 | 2.0 | 0.0 |\n----------------------------------------------------------------------------\n\nDV - Divider pipe (on port 0)\nD - Data fetch pipe (on ports 2 and 3)\n* - instruction micro-ops not bound to a port\n^ - Micro Fusion occurred\n\n|    | Ports pressure in cycles        | |\n|μops|0DV| 1 | 2 - D | 3 - D |4| 5 | 6 |7|\n-------------------------------------------\n| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | mov rax, qword ptr [rdx+0x8]\n| 2  |   |   |0.5 0.5|0.5 0.5| |1.0|   | | vpbroadcastb xmm4, byte ptr [rdx]\n| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | vmovdqa xmm3, xmmword ptr [rcx+0x20]\n| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | vmovdqu xmm0, xmmword ptr [rax]\n| 1  |1.0|   |       |       | |   |   | | vpcmpgtb xmm1, xmm3, xmm4\n| 2^ |   |   |0.5 0.5|0.5 0.5| |1.0|   | | vpshufb xmm5, xmm0, xmmword ptr [rcx+0x10]\n| 2^ |   |1.0|0.5 0.5|0.5 0.5| |   |   | | vpcmpeqb xmm5, xmm5, xmmword ptr [rcx]\n| 2  |1.0|   |       |       | |1.0|   | | vptest xmm1, xmm5\n| 1  |   |   |       |       | |   |1.0| | jnb 0x10\n| 1* |   |   |       |       | |   |   | | xor eax, eax\n| 1  |   |   |       |       | |   |1.0| | not al\n| 3^ |   |   |0.5 0.5|0.5 0.5| |   |   | | ret\nTotal Num Of μops: 18"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Trent Nelson",
    "section": "",
    "text": "Systems Software Engineer and Private Pilot (tailwheel, complex, high-performance, aerobatics).\nE-mail: trent@trent.me.\n\nArticles | Projects & Repositories | Tools"
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html",
    "href": "articles/is-prefix-of-string-in-table/index.html",
    "title": "Is Prefix Of String In Table?",
    "section": "",
    "text": "TL;DR\n  Overview\n  The Background\n  \n  The Tracer Project\n  Baseline C Implementation\n  The Proposed Interface\n  \n  The IsPrefixOfStringInTable Function\n  The STRING_MATCH Structure\n  \n  The Test Data\n  \n  NTFS Reserved Names\n  \n  \n  Requirements and Design Decisions\n  The Data Structures\n  \n  STRING_TABLE\n  STRING_ARRAY\n  STRING_SLOT\n  SLOT_INDEX\n  String Table Construction\n  \n  The Benchmark\n  \n  Release vs PGO Oddities\n  \n  The Implementations\n  \n  Round 1\n  \n  C Implementations\n  \n  IsPrefixOfCStrInArray\n  IsPrefixOfStringInTable_1\n  IsPrefixMatch\n  IsPrefixMatchAvx2\n  IsPrefixOfStringInTable_2\n  IsPrefixOfStringInTable_3\n  IsPrefixOfStringInTable_4\n  IsPrefixOfStringInTable_5\n  IsPrefixOfStringInTable_6\n  IsPrefixOfStringInTable_7\n  IsPrefixOfStringInTable_8\n  IsPrefixOfStringInTable_9\n  IsPrefixOfStringInTable_10\n  \n  Speeding Up Negative Matches with Assembly\n  \n  Windows x64 ABI Calling Conventions\n  \n  NESTED_ENTRY\n  LEAF_ENTRY\n  \n  \n  Assembly Implementations\n  \n  IsPrefixOfStringInTable_x64_1\n  IsPrefixOfStringInTable_x64_2\n  IsPrefixOfStringInTable_x64_3\n  \n  Internet Feedback\n  \n  Round 2—Post-Internet Feedback\n  \n  IsPrefixOfStringInTable_11\n  IsPrefixOfStringInTable_x64_4\n  IsPrefixOfStringInTable_12\n  IsPrefixOfStringInTable_13\n  IsPrefixOfStringInTable_14\n  IsPrefixOfStringInTable_x64_5\n  \n  \n  Reviewing x64 v3…\n  \n  IsPrefixOfStringInTable_x64_8\n  IsPrefixOfStringInTable_x64_9\n  IsPrefixOfStringInTable_x64_10\n  IsPrefixOfStringInTable_x64_11\n  IsPrefixOfStringInTable_x64_12\n  \n  Other Applications\n  Appendix\n  \n  Implementation Considerations\n  Release Build versus Profile Guided Optimization Build\n  Typedefs\n  \n  Colophon\n  \n  Quarto & Markdown\n  Data Visualization\n  \n  Algorithm Diagrams\n  Benchmarks\n  \n  \n  Comments\nPublished: 4th May, 2018. Last updated: 1st November, 2024.\nHacker News discussion | Reddit discussion"
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#the-tracer-project",
    "href": "articles/is-prefix-of-string-in-table/index.html#the-tracer-project",
    "title": "Is Prefix Of String In Table?",
    "section": "The Tracer Project",
    "text": "The Tracer Project\nOne of the frustrations I had with existing Python profilers was that there was no easy or efficient means to filter or exclude trace information based on the module name of the code being executed. I tackled this in my tracer project, which allows you to set an environment variable named TRACER_MODULE_NAMES to restrict which modules should be traced, e.g.:\nset TRACER_MODULE_NAMES=myproject1;myproject2;myproject3.subproject;numpy;pandas;scipy\nIf the code being executed is coming from the module myproject3.subproject.foo, then we need to trace it, as that string prefix matches the third entry on our list.\nThis article details the custom data structure and algorithm I came up with in order to try and solve the prefix matching problem more optimally with a SIMD approach. The resulting StringTable component is used extensively within the tracer project, and as such, must conform to unique constraints such as no use of the C runtime library and allocating all memory through TraceStore-backed allocators. Thus, it’s not really something you’d drop in to your current project in its current form. Hopefully, the article still proves to be interesting.\n\n\n\n\n\n\nNote\n\n\n\nThe code samples provided herein are copied directly from the tracer project, which is written in C and assembly, and uses the Pascal-esque Cutler Normal Form style for C. If you’re used to the more UNIX-style Kernel Normal Form of C, it’s quite like that, except that it’s absolutely nothing like that, and all these code samples will probably be very jarring."
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#baseline-c-implementation",
    "href": "articles/is-prefix-of-string-in-table/index.html#baseline-c-implementation",
    "title": "Is Prefix Of String In Table?",
    "section": "Baseline C Implementation",
    "text": "Baseline C Implementation\nThe simplest way of solving this in C is to have an array of C strings (i.e., NULL-terminated byte arrays), then for each string, loop through byte by byte and see if it prefix matches the search string.\n\nBaseline (Cutler Normal Form)Baseline (Kernel Normal Form)\n\n\n//\n// Declare a set of module names to be used as a string array.\n//\n\nconst PCSZ ModuleNames[] = {\n    \"myproject1\",\n    \"myproject2\",\n    \"myproject3.subproject\",\n    \"numpy\",\n    \"pandas\",\n    \"scipy\",\n    NULL,\n};\n\n//\n// Define the function pointer typedef.\n//\n\ntypedef\nSTRING_TABLE_INDEX\n(IS_PREFIX_OF_CSTR_IN_ARRAY)(\n    _In_ PCSZ *StringArray,\n    _In_ PCSZ String,\n    _Out_opt_ PSTRING_MATCH Match\n    );\ntypedef IS_PREFIX_OF_CSTR_IN_ARRAY *PIS_PREFIX_OF_CSTR_IN_ARRAY;\n\n//\n// Forward declaration.\n//\n\nIS_PREFIX_OF_CSTR_IN_ARRAY IsPrefixOfCStrInArray;\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfCStrInArray(\n    PCSZ *StringArray,\n    PCSZ String,\n    PSTRING_MATCH Match\n    )\n{\n    PCSZ Left;\n    PCSZ Right;\n    PCSZ *Target;\n    ULONG Index = 0;\n    ULONG Count;\n\n    for (Target = StringArray; *Target != NULL; Target++, Index++) {\n        Count = 0;\n        Left = String;\n        Right = *Target;\n\n        while (*Left && *Right && *Left++ == *Right++) {\n            Count++;\n        }\n\n        if (Count &gt; 0 && !*Right) {\n            if (ARGUMENT_PRESENT(Match)) {\n                Match-&gt;Index = (BYTE)Index;\n                Match-&gt;NumberOfMatchedCharacters = (BYTE)Count;\n                Match-&gt;String = NULL;\n            }\n            return (STRING_TABLE_INDEX)Index;\n        }\n    }\n\n    return NO_MATCH_FOUND;\n}\n\n\nconst char *module_names[] = {\n    \"myproject1\",\n    \"myproject2\",\n    \"myproject3.subproject\",\n    \"numpy\",\n    \"pandas\",\n    \"scipy\",\n    0,\n};\n\nstruct string_match {\n    /* Index of the match. */\n    unsigned char index;\n\n    /* Number of characters matched. */\n    unsigned char number_of_chars_matched;\n\n    /* Pad out to an 8-byte boundary. */\n    unsigned short padding[3];\n\n    /* Pointer to the string that was matched. */\n    char *str;\n};\n\nunsigned char\nis_prefix_of_c_str_in_array(const char **array,\n                            const char *str,\n                            struct string_match *match)\n{\n    char *left, *right, **target;\n    unsigned int c, i = 0;\n\n    for (target = array; target; target++, i++) {\n        c = 0;\n        left = str;\n        right *target;\n        while (*left && *right && *left++ == *right) {\n            c++;\n        }\n        if (c &gt; 0 && !*right) {\n            if (match) {\n                match-&gt;index = i;\n                match-&gt;chars_matched = c;\n                match-&gt;str = target[i];\n            }\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n\n\nAnother type of code pattern that the string table attempts to replace is anything that does a lot of if/else if/else if-type string comparisons to look for keywords. For example, in the Quake III source, there’s some symbol/string processing logic that looks like this:\n// call instructions reset currentArgOffset\nif ( !strncmp( token, \"CALL\", 4 ) ) {\n    EmitByte( &segment[CODESEG], OP_CALL );\n    instructionCount++;\n    currentArgOffset = 0;\n    return;\n}\n\n// arg is converted to a reversed store\nif ( !strncmp( token, \"ARG\", 3 ) ) {\n    EmitByte( &segment[CODESEG], OP_ARG );\n    instructionCount++;\n    if ( 8 + currentArgOffset &gt;= 256 ) {\n        CodeError( \"currentArgOffset &gt;= 256\" );\n        return;\n    }\n    EmitByte( &segment[CODESEG], 8 + currentArgOffset );\n    currentArgOffset += 4;\n    return;\n}\n\n// ret just leaves something on the op stack\nif ( !strncmp( token, \"RET\", 3 ) ) {\n    EmitByte( &segment[CODESEG], OP_LEAVE );\n    instructionCount++;\n    EmitInt( &segment[CODESEG], 8 + currentLocals + currentArgs );\n    return;\n}\n\n// pop is needed to discard the return value of\n// a function\nif ( !strncmp( token, \"pop\", 3 ) ) {\n    EmitByte( &segment[CODESEG], OP_POP );\n    instructionCount++;\n    return;\n}\n...\nAn example of using the string table approach for this problem is discussed in the Other Applications section."
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#the-proposed-interface",
    "href": "articles/is-prefix-of-string-in-table/index.html#the-proposed-interface",
    "title": "Is Prefix Of String In Table?",
    "section": "The Proposed Interface",
    "text": "The Proposed Interface\nLet’s take a look at the interface we’re proposing, the IsPrefixOfStringInTable function, that this article is based upon:\n\nThe IsPrefixOfStringInTable Function\n//\n// Our string table index is simply a char, with -1 indicating no match found.\n//\n\ntypedef CHAR STRING_TABLE_INDEX;\n#define NO_MATCH_FOUND -1\n\ntypedef\nSTRING_TABLE_INDEX\n(IS_PREFIX_OF_STRING_IN_TABLE)(\n    _In_ PSTRING_TABLE StringTable,\n    _In_ PSTRING String,\n    _Out_opt_ PSTRING_MATCH StringMatch\n    );\ntypedef IS_PREFIX_OF_STRING_IN_TABLE *PIS_PREFIX_OF_STRING_IN_TABLE;\n\nIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable;\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\nAll implementations discussed in this article adhere to that function signature. The STRING_TABLE structure will be discussed shortly.\n\n\nThe STRING_MATCH Structure\nThe STRING_MATCH structure is used to optionally communicate information about the prefix match back to the caller. The index and characters matched fields are often very useful when using the string table for text parsing; see the other applications section below for an example.\nThe structure is defined as follows:\n//\n// This structure is used to communicate matches back to the caller.\n//\n\ntypedef struct _STRING_MATCH {\n\n    //\n    // Index of the match.\n    //\n\n    BYTE Index;\n\n    //\n    // Number of characters matched.\n    //\n\n    BYTE NumberOfMatchedCharacters;\n\n    //\n    // Pad out to 8-bytes.\n    //\n\n    USHORT Padding[3];\n\n    //\n    // Pointer to the string that was matched.  The underlying buffer will\n    // stay valid for as long as the STRING_TABLE struct persists.\n    //\n\n    PSTRING String;\n\n} STRING_MATCH, *PSTRING_MATCH, **PPSTRING_MATCH;\nC_ASSERT(sizeof(STRING_MATCH) == 16);"
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#the-test-data",
    "href": "articles/is-prefix-of-string-in-table/index.html#the-test-data",
    "title": "Is Prefix Of String In Table?",
    "section": "The Test Data",
    "text": "The Test Data\nInstead of using some arbitrary Python module names, this article is going to focus on a string table constructed out of a set of 16 strings that represent reserved names of the NTFS file system, at least when it was first released way back in the early 90s.\nThis list is desirable as it has good distribution of characters, there is a good mix of both short and long entries, plus one oversized one ($INDEX_ALLOCATION, which clocks in at 17 characters), and almost all strings lead with a common character (the dollar sign), preventing a simple first character optimization used by the initial version of the StringTable component I wrote in 2016.\nSo the scenario we’ll be emulating, in this case, is that we’ve just been passed a filename for creation, and we need to check if it prefix matches any of the reserved names.\nHere’s the full list of NTFS names we’ll be using. We’re assuming 8-bit ASCII encoding (no UTF-8) and case sensitive. (If this were actually the NT kernel, we’d need to use wide characters with UTF-16 encoding, and be case-insensitive.)\n\nNTFS Reserved Names\n\n$AttrDef\n$BadClus\n$Bitmap\n$Boot\n$Extend\n$LogFile\n$MftMirr\n$Mft\n$Secure\n$UpCase\n$Volume\n$Cairo\n$INDEX_ALLOCATION\n$DATA\n????\n.\n\nThe ordering is important in certain cases. For example, when you have overlapping strings, such as $MftMirr and $Mft, you should put the longest strings first. They will be matched first, and as our routine terminates upon the first successful prefix match—if a longer string resided after a shorter one, it would never get detected.\nLet’s review some guiding design requirements and cover some of the design decisions I made, which should help shape your understanding of the implementation."
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#string_table",
    "href": "articles/is-prefix-of-string-in-table/index.html#string_table",
    "title": "Is Prefix Of String In Table?",
    "section": "STRING_TABLE",
    "text": "STRING_TABLE\nLet’s review the STRING_TABLE view on GitHub structure first and then touch on the supporting structures.\n\nC (Cutler Normal Form)C (Kernel Normal Form)MASM\n\n\n//\n// The STRING_TABLE struct is an optimized structure for testing whether a\n// prefix entry for a string is in a table, with the expectation that the\n// strings being compared will be relatively short (ideally &lt;= 16 characters),\n// and the table of string prefixes to compare to will be relatively small\n// (ideally &lt;= 16 strings).\n//\n// The overall goal is to be able to prefix match a string with the lowest\n// possible (amortized) latency.  Fixed-size, memory-aligned character arrays,\n// and SIMD instructions are used to try and achieve this.\n//\n\ntypedef struct _STRING_TABLE {\n\n    //\n    // A slot where each individual element contains a uniquely-identifying\n    // letter, with respect to the other strings in the table, of each string\n    // in an occupied slot.\n    //\n\n    STRING_SLOT UniqueChars;\n\n    //\n    // (16 bytes consumed.)\n    //\n\n    //\n    // For each unique character identified above, the following structure\n    // captures the 0-based index of that character in the underlying string.\n    // This is used as an input to vpshufb to rearrange the search string's\n    // characters such that it can be vpcmpeqb'd against the unique characters\n    // above.\n    //\n\n    SLOT_INDEX UniqueIndex;\n\n    //\n    // (32 bytes consumed.)\n    //\n\n    //\n    // Length of the underlying string in each slot.\n    //\n\n    SLOT_LENGTHS Lengths;\n\n    //\n    // (48 bytes consumed, aligned at 16 bytes.)\n    //\n\n    //\n    // Pointer to the STRING_ARRAY associated with this table, which we own\n    // (we create it and copy the caller's contents at creation time and\n    // deallocate it when we get destroyed).\n    //\n    // N.B.  We use pStringArray here instead of StringArray because the\n    //       latter is a field name at the end of the struct.\n    //\n    //\n\n    PSTRING_ARRAY pStringArray;\n\n    //\n    // (56 bytes consumed, aligned at 8 bytes.)\n    //\n\n    //\n    // String table flags.\n    //\n\n    STRING_TABLE_FLAGS Flags;\n\n    //\n    // (60 bytes consumed, aligned at 4 bytes.)\n    //\n\n    //\n    // A 16-bit bitmap indicating which slots are occupied.\n    //\n\n    USHORT OccupiedBitmap;\n\n    //\n    // A 16-bit bitmap indicating which slots have strings longer than 16 chars.\n    //\n\n    USHORT ContinuationBitmap;\n\n    //\n    // (64 bytes consumed, aligned at 64 bytes.)\n    //\n\n    //\n    // The 16-element array of STRING_SLOT structs.  We want this to be aligned\n    // on a 64-byte boundary, and it consumes 256-bytes of memory.\n    //\n\n    STRING_SLOT Slots[16];\n\n    //\n    // (320 bytes consumed, aligned at 64 bytes.)\n    //\n\n    //\n    // We want the structure size to be a power of 2 such that an even number\n    // can fit into a 4KB page (and reducing the likelihood of crossing page\n    // boundaries, which complicates SIMD boundary handling), so we have an\n    // extra 192-bytes to play with here.  The CopyStringArray() routine is\n    // special-cased to allocate the backing STRING_ARRAY structure plus the\n    // accommodating buffers in this space if it can fit.\n    //\n    // (You can test whether or not this occurred by checking the invariant\n    //  `StringTable-&gt;pStringArray == &StringTable-&gt;StringArray`, if this\n    //  is true, the array was allocated within this remaining padding space.)\n    //\n\n    union {\n        STRING_ARRAY StringArray;\n        CHAR Padding[192];\n    };\n\n} STRING_TABLE, *PSTRING_TABLE, **PPSTRING_TABLE;\n\n//\n// Assert critical size and alignment invariants at compile time.\n//\n\nC_ASSERT(FIELD_OFFSET(STRING_TABLE, UniqueIndex) == 16);\nC_ASSERT(FIELD_OFFSET(STRING_TABLE, Lengths) == 32);\nC_ASSERT(FIELD_OFFSET(STRING_TABLE, pStringArray) == 48);\nC_ASSERT(FIELD_OFFSET(STRING_TABLE, Slots)   == 64);\nC_ASSERT(FIELD_OFFSET(STRING_TABLE, Padding) == 320);\nC_ASSERT(sizeof(STRING_TABLE) == 512);\n\n\nstruct string_table {\n    char                       unique_chars[16];\n    unsigned char              unique_index[16];\n    unsigned char              slot_lengths[16];\n    struct string_array       *string_array_ptr;\n    struct string_table_flags  flags;\n    unsigned short             occupied_bitmap;\n    unsigned short             continuation_bitmap;\n    char                       slots[16][16];\n    union {\n        struct string_array    string_array;\n        char                   padding[184];\n    } u;\n};\n\n\nSTRING_TABLE struct\n    UniqueChars         CHAR 16 dup  (?)\n    UniqueIndex         BYTE 16 dup  (?)\n    Lengths             BYTE 16 dup  (?)\n    pStringArray        PSTRING_ARRAY ?\n    Flags               ULONG         ?\n    OccupiedBitmap      USHORT        ?\n    ContinuationBitmap  USHORT        ?\n    Slots               STRING_SLOT 16 dup ({ })\n    union\n        StringArray STRING_ARRAY {?}\n        Padding CHAR 192 dup (?)\n    ends\nSTRING_TABLE ends\n\n;\n; Assert our critical field offsets and structure size as per the same approach\n; taken in StringTable.h.\n;\n\n.erre (STRING_TABLE.UniqueIndex  eq  16), @CatStr(&lt;UnexpectedOffset STRING_TABLE.UniqueIndex: &gt;, %(STRING_TABLE.UniqueIndex))\n.erre (STRING_TABLE.Lengths      eq  32), @CatStr(&lt;UnexpectedOffset STRING_TABLE.Lengths: &gt;, %(STRING_TABLE.Lengths))\n.erre (STRING_TABLE.pStringArray eq  48), @CatStr(&lt;UnexpectedOffset STRING_TABLE.pStringArray: &gt;, %(STRING_TABLE.pStringArray))\n.erre (STRING_TABLE.Slots        eq  64), @CatStr(&lt;UnexpectedOffset STRING_TABLE.Slots: &gt;, %(STRING_TABLE.Slots))\n.erre (STRING_TABLE.Padding      eq 320), @CatStr(&lt;UnexpectedOffset STRING_TABLE.Padding: &gt;, %(STRING_TABLE.Padding))\n.erre (size STRING_TABLE eq 512), @CatStr(&lt;IncorrectStructSize: STRING_TABLE: &gt;, %(size STRING_TABLE))\n\nPSTRING_TABLE typedef ptr STRING_TABLE\n\n;\n; CamelCase typedefs that are nicer to work with in assembly\n; than their uppercase counterparts.\n;\n\nStringTable typedef STRING_TABLE\n\n\n\nThe following diagram depicts an in-memory representation of the STRING_TABLE structure using our NTFS reserved prefix names. It is created via the CreateStringTable routine, which we feature in the appendix of this article.\n\n\n\nSTRING_TABLE Diagram\n\n\nIn order to improve the uniqueness of the unique characters selected from each string, the strings are sorted by length during string table creation and enumerated in this order while identifying unique characters. The rationale behind this is that shorter strings simply have fewer characters to choose from, while longer strings have more to choose from. If we identified unique characters in the order they appear in the string table, we may have longer strings preceding shorter ones, such that toward the end of the table, nothing unique can be extracted from the short ones.\nThe utility of the string table is maximized by ensuring a unique character is selected from every string; thus, we sort by length first. Note that the uniqueness is actually determined by offset:character pairs, with the offsets becoming the indices stored in the UniqueIndex slot. If you trace through the diagram above, you’ll see that the unique character in each slot matches the character in the corresponding string slot, indicated by the underlying index."
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#string_array",
    "href": "articles/is-prefix-of-string-in-table/index.html#string_array",
    "title": "Is Prefix Of String In Table?",
    "section": "STRING_ARRAY",
    "text": "STRING_ARRAY\nThe string array captures a raw array representation of the underlying strings making up the string table. It is either embedded within the padding area at the end of the string table, or a separate allocation is made during string table creation. The main interface to creating a string table is via a STRING_ARRAY structure. The helper functions, CreateStringTableFromDelimitedString and CreateStringTableFromDelimitedEnvironmentVariable, simply break down their input into a STRING_ARRAY representation first before calling CreateStringTable.\ntypedef struct _Struct_size_bytes_(SizeInQuadwords&gt;&gt;3) _STRING_ARRAY {\n\n    //\n    // Size of the structure, in quadwords.  Why quadwords?  It allows us to\n    // keep this size field to a USHORT, which helps with the rest of the\n    // alignment in this struct (we want the STRING Strings[] array to start\n    // on an 8-byte boundary).\n    //\n    // N.B.  We can't express the exact field size in the SAL annotation\n    //       below, because the array of buffer sizes are inexpressible;\n    //       however, we know the maximum length, so we can use the implicit\n    //       invariant that the total buffer size can't exceed whatever num\n    //       elements * max size is.\n    //\n\n    _Field_range_(&lt;=, (\n        sizeof(struct _STRING_ARRAY) +\n        ((NumberOfElements - 1) * sizeof(STRING)) +\n        (MaximumLength * NumberOfElements)\n    ) &gt;&gt; 3)\n    USHORT SizeInQuadwords;\n\n    //\n    // Number of elements in the array.\n    //\n\n    USHORT NumberOfElements;\n\n    //\n    // Minimum and maximum lengths for the String-&gt;Length fields.  Optional.\n    //\n\n    USHORT MinimumLength;\n    USHORT MaximumLength;\n\n    //\n    // A pointer to the STRING_TABLE structure that \"owns\" us.\n    //\n\n    struct _STRING_TABLE *StringTable;\n\n    //\n    // The string array.  Number of elements in the array is governed by the\n    // NumberOfElements field above.\n    //\n\n    STRING Strings[ANYSIZE_ARRAY];\n\n} STRING_ARRAY, *PSTRING_ARRAY, **PPSTRING_ARRAY;\n\n\n\n\n\n\nNote\n\n\n\nThe odd-looking macros _Struct_size_bytes_ and _Field_range_ are SAL Annotations. There’s a neat deck called Engineering Better Software at Microsoft which captures some interesting details about SAL, for those wanting to read more. The Code Analysis engine that uses the annotations is built upon the Z3 Theorem Prover, which is a fascinating little project in its own right.\n\n\nAnd finally, we’re left with the smaller helper structs that we use to encapsulate the various innards of the string table. (I use unions that feature XMMWORD representations (which is a typedef of __m128i, representing an XMM register) as well as underlying byte/character representations, as I personally find it makes the resulting C code a bit nicer.)"
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#string_slot",
    "href": "articles/is-prefix-of-string-in-table/index.html#string_slot",
    "title": "Is Prefix Of String In Table?",
    "section": "STRING_SLOT",
    "text": "STRING_SLOT\n//\n// String tables are composed of a 16 element array of 16 byte string \"slots\",\n// which represent a unique character (with respect to other strings in the\n// table) for a string in a given slot index. The STRING_SLOT structure\n// provides a convenient wrapper around this construct.\n//\n\ntypedef union DECLSPEC_ALIGN(16) _STRING_SLOT {\n    XMMWORD CharsXmm;\n    CHAR Char[16];\n} STRING_SLOT, *PSTRING_SLOT, **PPSTRING_SLOT;\nC_ASSERT(sizeof(STRING_SLOT) == 16);"
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#slot_index",
    "href": "articles/is-prefix-of-string-in-table/index.html#slot_index",
    "title": "Is Prefix Of String In Table?",
    "section": "SLOT_INDEX",
    "text": "SLOT_INDEX\n//\n// A 16 element array of 1 byte unsigned integers, used to capture the length\n// of each string slot in a single XMM 128-bit register.\n//\n\ntypedef union DECLSPEC_ALIGN(16) _SLOT_LENGTHS {\n    XMMWORD SlotsXmm;\n    BYTE Slots[16];\n} SLOT_LENGTHS, *PSLOT_LENGTHS, **PPSLOT_LENGTHS;\nC_ASSERT(sizeof(SLOT_LENGTHS) == 16);"
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#createstringtable",
    "href": "articles/is-prefix-of-string-in-table/index.html#createstringtable",
    "title": "Is Prefix Of String In Table?",
    "section": "String Table Construction",
    "text": "String Table Construction\nThe CreateSingleStringTable routine is responsible for the construction of a new STRING_TABLE. It is here that we identify the unique set of characters (and their indices) to store in the first two fields of the string table.\n//\n// Define private types used by this module.\n//\n\ntypedef struct _LENGTH_INDEX_ENTRY {\n    BYTE Length;\n    BYTE Index;\n} LENGTH_INDEX_ENTRY;\ntypedef LENGTH_INDEX_ENTRY *PLENGTH_INDEX_ENTRY;\n\ntypedef struct _LENGTH_INDEX_TABLE {\n    LENGTH_INDEX_ENTRY Entry[16];\n} LENGTH_INDEX_TABLE;\ntypedef LENGTH_INDEX_TABLE *PLENGTH_INDEX_TABLE;\n\ntypedef union DECLSPEC_ALIGN(32) _CHARACTER_BITMAP {\n    YMMWORD Ymm;\n    XMMWORD Xmm[2];\n    LONG Bits[(256 / (4 &lt;&lt; 3))];  // 8\n} CHARACTER_BITMAP;\nC_ASSERT(sizeof(CHARACTER_BITMAP) == 32);\ntypedef CHARACTER_BITMAP *PCHARACTER_BITMAP;\n\ntypedef struct _SLOT_BITMAPS {\n    CHARACTER_BITMAP Bitmap[16];\n} SLOT_BITMAPS;\ntypedef SLOT_BITMAPS *PSLOT_BITMAPS;\n\n//\n// Function implementation.\n//\n\n_Use_decl_annotations_\nPSTRING_TABLE\nCreateSingleStringTable(\n    PRTL Rtl,\n    PALLOCATOR StringTableAllocator,\n    PALLOCATOR StringArrayAllocator,\n    PSTRING_ARRAY StringArray,\n    BOOL CopyArray\n    )\n/*++\n\nRoutine Description:\n\n    Allocates space for a STRING_TABLE structure using the provided allocators,\n    then initializes it using the provided STRING_ARRAY.  If CopyArray is set\n    to TRUE, the routine will copy the string array such that the caller is\n    free to destroy it after the table has been successfully created.  If it\n    is set to FALSE and StringArray-&gt;StringTable has a non-NULL value, it is\n    assumed that sufficient space has already been allocated for the string\n    table and this pointer will be used to initialize the rest of the structure.\n\n    DestroyStringTable() must be called against the returned PSTRING_TABLE when\n    the structure is no longer needed in order to ensure resources are released.\n\nArguments:\n\n    Rtl - Supplies a pointer to an initialized RTL structure.\n\n    StringTableAllocator - Supplies a pointer to an ALLOCATOR structure which\n        will be used for creating the STRING_TABLE.\n\n    StringArrayAllocator - Supplies a pointer to an ALLOCATOR structure which\n        may be used to create the STRING_ARRAY if it cannot fit within the\n        padding of the STRING_TABLE structure.  This is kept separate from the\n        StringTableAllocator due to the stringent alignment requirements of the\n        string table.\n\n    StringArray - Supplies a pointer to an initialized STRING_ARRAY structure\n        that contains the STRING structures that are to be added to the table.\n\n    CopyArray - Supplies a boolean value indicating whether or not the\n        StringArray structure should be deep-copied during creation.  This is\n        typically set when the caller wants to be able to free the structure\n        as soon as this call returns (or can't guarantee it will persist past\n        this function's invocation, i.e. if it was stack allocated).\n\nReturn Value:\n\n    A pointer to a valid PSTRING_TABLE structure on success, NULL on failure.\n    Call DestroyStringTable() on the returned structure when it is no longer\n    needed in order to ensure resources are cleaned up appropriately.\n\n--*/\n{\n    BYTE Byte;\n    BYTE Count;\n    BYTE Index;\n    BYTE Length;\n    BYTE NumberOfElements;\n    ULONG HighestBit;\n    ULONG OccupiedMask;\n    PULONG Bits;\n    USHORT OccupiedBitmap;\n    USHORT ContinuationBitmap;\n    PSTRING_TABLE StringTable;\n    PSTRING_ARRAY StringArray;\n    PSTRING String;\n    PSTRING_SLOT Slot;\n    STRING_SLOT UniqueChars;\n    SLOT_INDEX UniqueIndex;\n    SLOT_INDEX LengthIndex;\n    SLOT_LENGTHS Lengths;\n    LENGTH_INDEX_TABLE LengthIndexTable;\n    PCHARACTER_BITMAP Bitmap;\n    SLOT_BITMAPS SlotBitmaps;\n    PLENGTH_INDEX_ENTRY Entry;\n\n    //\n    // Validate arguments.\n    //\n\n    if (!ARGUMENT_PRESENT(StringTableAllocator)) {\n        return NULL;\n    }\n\n    if (!ARGUMENT_PRESENT(StringArrayAllocator)) {\n        return NULL;\n    }\n\n    if (!ARGUMENT_PRESENT(SourceStringArray)) {\n        return NULL;\n    }\n\n    if (SourceStringArray-&gt;NumberOfElements == 0) {\n        return NULL;\n    }\n\n    //\n    // Copy the incoming string array if applicable.\n    //\n\n    if (CopyArray) {\n\n        StringArray = CopyStringArray(\n            StringTableAllocator,\n            StringArrayAllocator,\n            SourceStringArray,\n            FIELD_OFFSET(STRING_TABLE, StringArray),\n            sizeof(STRING_TABLE),\n            &StringTable\n        );\n\n        if (!StringArray) {\n            return NULL;\n        }\n\n    } else {\n\n        //\n        // We're not copying the array, so initialize StringArray to point at\n        // the caller's SourceStringArray, and StringTable to point at the\n        // array's StringTable field (which will be non-NULL if sufficient\n        // space has been allocated).\n        //\n\n        StringArray = SourceStringArray;\n        StringTable = StringArray-&gt;StringTable;\n\n    }\n\n    //\n    // If StringTable has no value, we've either been called with CopyArray set\n    // to FALSE, or CopyStringArray() wasn't able to allocate sufficient space\n    // for both the table and itself.  Either way, we need to allocate space for\n    // the table.\n    //\n\n    if (!StringTable) {\n\n        StringTable = (PSTRING_TABLE)(\n            StringTableAllocator-&gt;AlignedCalloc(\n                StringTableAllocator-&gt;Context,\n                1,\n                sizeof(STRING_TABLE),\n                STRING_TABLE_ALIGNMENT\n            )\n        );\n\n        if (!StringTable) {\n            return NULL;\n        }\n    }\n\n    //\n    // Make sure the fields that are sensitive to alignment are, in fact,\n    // aligned correctly.\n    //\n\n    if (!AssertStringTableFieldAlignment(StringTable)) {\n        DestroyStringTable(StringTableAllocator,\n                           StringArrayAllocator,\n                           StringTable);\n        return NULL;\n    }\n\n    //\n    // At this point, we have copied the incoming StringArray if necessary,\n    // and we've allocated sufficient space for the StringTable structure.\n    // Enumerate over all of the strings, set the continuation bit if the\n    // length &gt; 16, set the relevant slot length, set the relevant unique\n    // character entry, then move the first 16-bytes of the string into the\n    // relevant slot via an aligned SSE mov.\n    //\n\n    //\n    // Initialize pointers and counters, clear stack-based structures.\n    //\n\n    Slot = StringTable-&gt;Slots;\n    String = StringArray-&gt;Strings;\n\n    OccupiedBitmap = 0;\n    ContinuationBitmap = 0;\n    NumberOfElements = (BYTE)StringArray-&gt;NumberOfElements;\n    UniqueChars.CharsXmm = _mm_setzero_si128();\n    UniqueIndex.IndexXmm = _mm_setzero_si128();\n    LengthIndex.IndexXmm = _mm_setzero_si128();\n\n    //\n    // Set all the slot lengths to 0x7f up front instead of defaulting\n    // to zero.  This allows for simpler logic when searching for a prefix\n    // string, which involves broadcasting a search string's length to an XMM\n    // register, then doing _mm_cmpgt_epi8() against the lengths array and\n    // the string length.  If we left the lengths as 0 for unused slots, they\n    // would get included in the resulting comparison register (i.e. the high\n    // bits would be set to 1), so we'd have to do a subsequent masking of\n    // the result at some point using the OccupiedBitmap.  By defaulting the\n    // lengths to 0x7f, we ensure they'll never get included in any cmpgt-type\n    // SIMD matches.  (We use 0x7f instead of 0xff because the _mm_cmpgt_epi8()\n    // intrinsic assumes packed signed integers.)\n    //\n\n    Lengths.SlotsXmm = _mm_set1_epi8(0x7f);\n\n    ZeroStruct(LengthIndexTable);\n    ZeroStruct(SlotBitmaps);\n\n    for (Count = 0; Count &lt; NumberOfElements; Count++) {\n\n        XMMWORD CharsXmm;\n\n        //\n        // Set the string length for the slot.\n        //\n\n        Length = Lengths.Slots[Count] = (BYTE)String-&gt;Length;\n\n        //\n        // Set the appropriate bit in the continuation bitmap if the string is\n        // longer than 16 bytes.\n        //\n\n        if (Length &gt; 16) {\n            ContinuationBitmap |= (Count == 0 ? 1 : 1 &lt;&lt; (Count + 1));\n        }\n\n        if (Count == 0) {\n\n            Entry = &LengthIndexTable.Entry[0];\n            Entry-&gt;Index = 0;\n            Entry-&gt;Length = Length;\n\n        } else {\n\n            //\n            // Perform a linear scan of the length-index table in order to\n            // identify an appropriate insertion point.\n            //\n\n            for (Index = 0; Index &lt; Count; Index++) {\n                if (Length &lt; LengthIndexTable.Entry[Index].Length) {\n                    break;\n                }\n            }\n\n            if (Index != Count) {\n\n                //\n                // New entry doesn't go at the end of the table, so shuffle\n                // everything else down.\n                //\n\n                Rtl-&gt;RtlMoveMemory(&LengthIndexTable.Entry[Index + 1],\n                                   &LengthIndexTable.Entry[Index],\n                                   (Count - Index) * sizeof(*Entry));\n            }\n\n            Entry = &LengthIndexTable.Entry[Index];\n            Entry-&gt;Index = Count;\n            Entry-&gt;Length = Length;\n        }\n\n        //\n        // Copy the first 16-bytes of the string into the relevant slot.  We\n        // have taken care to ensure everything is 16-byte aligned by this\n        // stage, so we can use SSE intrinsics here.\n        //\n\n        CharsXmm = _mm_load_si128((PXMMWORD)String-&gt;Buffer);\n        _mm_store_si128(&(*Slot).CharsXmm, CharsXmm);\n\n        //\n        // Advance our pointers.\n        //\n\n        ++Slot;\n        ++String;\n\n    }\n\n    //\n    // Store the slot lengths.\n    //\n\n    _mm_store_si128(&(StringTable-&gt;Lengths.SlotsXmm), Lengths.SlotsXmm);\n\n    //\n    // Loop through the strings in order of shortest to longest and construct\n    // the uniquely-identifying character table with corresponding index.\n    //\n\n\n    for (Count = 0; Count &lt; NumberOfElements; Count++) {\n        Entry = &LengthIndexTable.Entry[Count];\n        Length = Entry-&gt;Length;\n        Slot = &StringTable-&gt;Slots[Entry-&gt;Index];\n\n        //\n        // Iterate over each character in the slot and find the first one\n        // without a corresponding bit set.\n        //\n\n        for (Index = 0; Index &lt; Length; Index++) {\n            Bitmap = &SlotBitmaps.Bitmap[Index];\n            Bits = (PULONG)&Bitmap-&gt;Bits[0];\n            Byte = Slot-&gt;Char[Index];\n            if (!BitTestAndSet(Bits, Byte)) {\n                break;\n            }\n        }\n\n        UniqueChars.Char[Count] = Byte;\n        UniqueIndex.Index[Count] = Index;\n        LengthIndex.Index[Count] = Entry-&gt;Index;\n    }\n\n    //\n    // Loop through the elements again such that the unique chars are stored\n    // in the order they appear in the table.\n    //\n\n    for (Count = 0; Count &lt; NumberOfElements; Count++) {\n        for (Index = 0; Index &lt; NumberOfElements; Index++) {\n            if (LengthIndex.Index[Index] == Count) {\n                StringTable-&gt;UniqueChars.Char[Count] = UniqueChars.Char[Index];\n                StringTable-&gt;UniqueIndex.Index[Count] = UniqueIndex.Index[Index];\n                break;\n            }\n        }\n    }\n\n    //\n    // Generate and store the occupied bitmap.  Each bit, from low to high,\n    // corresponds to the index of a slot.  When set, the slot is occupied.\n    // When clear, it is not.  So, fill bits from the highest bit set down.\n    //\n\n    HighestBit = (1 &lt;&lt; (StringArray-&gt;NumberOfElements-1));\n    OccupiedMask = _blsmsk_u32(HighestBit);\n    StringTable-&gt;OccupiedBitmap = (USHORT)OccupiedMask;\n\n    //\n    // Store the continuation bitmap.\n    //\n\n    StringTable-&gt;ContinuationBitmap = (USHORT)(ContinuationBitmap);\n\n    //\n    // Wire up the string array to the table.\n    //\n\n    StringTable-&gt;pStringArray = StringArray;\n\n    //\n    // And we're done, return the table.\n    //\n\n    return StringTable;\n}"
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#release-vs-pgo-oddities",
    "href": "articles/is-prefix-of-string-in-table/index.html#release-vs-pgo-oddities",
    "title": "Is Prefix Of String In Table?",
    "section": "Release vs PGO Oddities",
    "text": "Release vs PGO Oddities\nAll of the times in the graphs come from the profile-guided optimization (PGO) build of the StringTable component. The PGO build is faster than the normal release build in every case except one, where it is notably slower.\nIt’s… odd. I haven’t investigated it. The following graph depicts the affected function, IsPrefixOfStringInTable_1, and a few other versions for reference, showing the performance of the PGO build compared to the release build on the input strings \"$INDEX_ALLOCATION\" and \"$Bai123456789012\".\n\n\n\nBenchmark Release vs PGO\n\n\nOnly that function is affected, and the problem mainly manifests with the two example test strings shown. As this routine essentially serves as one of the initial baseline implementations, it would be misleading to compare all optimized PGO versions to the abnormally slow baseline implementation. Therefore, the release and PGO timings were blended into a single CSV, and the Excel PivotTables select the minimum time for a given function and test input.\nThus, you’re always looking at the PGO timings, except for this outlier case where the release versions are faster."
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#round1",
    "href": "articles/is-prefix-of-string-in-table/index.html#round1",
    "title": "Is Prefix Of String In Table?",
    "section": "Round 1",
    "text": "Round 1\nIn this section, we’ll take a look at the various implementations I experimented with on the first pass, prior to soliciting any feedback. I figured there were a couple of ways I could present this information. First, I could hand-pick what I choose to show and hide, creating a rosy picture that makes it seem like I effortlessly arrived at the fastest implementation without much actual effort whatsoever.\nOr I could show the gritty reality of how everything actually went down in chronological fashion, errors and all. And there were definitely some errors! For better or worse, I’ve chosen this route, so you’ll get to see some pretty tedious tweaks (changing a single line, for example) before the juicy stuff really kicks in.\nAdditionally, with the benefit of writing this section introduction retroactively, iterations 4 and 5 aren’t testing what I initially thought they were testing. I’ve left them in as is; if anything, it demonstrates the importance of only changing one thing at a time and making sure you’re testing what you think you’re testing. I’ll discuss the errors with those iterations later in the article.\n\nC Implementations\n\nIsPrefixOfCStrInArray\nIsPrefixOfStringInTable_1 →\nLet’s review the baseline implementation again, as that’s what we’re ultimately comparing ourselves against. This version enumerates the string array (and thus has a slightly different function signature than the STRING_TABLE-based functions) looking for prefix matches. No SIMD instructions are used. The timings captured should be proportional to the location of the test input string in the array. That is, it should take less time to prefix match strings that occur earlier in the array versus those that appear later.\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfCStrInArray(\n    PCSZ *StringArray,\n    PCSZ String,\n    PSTRING_MATCH Match\n    )\n{\n    PCSZ Left;\n    PCSZ Right;\n    PCSZ *Target;\n    ULONG Index = 0;\n    ULONG Count;\n\n    for (Target = StringArray; *Target != NULL; Target++, Index++) {\n        Count = 0;\n        Left = String;\n        Right = *Target;\n\n        while (*Left && *Right && *Left++ == *Right++) {\n            Count++;\n        }\n\n        if (Count &gt; 0 && !*Right) {\n            if (ARGUMENT_PRESENT(Match)) {\n                Match-&gt;Index = (BYTE)Index;\n                Match-&gt;NumberOfMatchedCharacters = (BYTE)Count;\n                Match-&gt;String = NULL;\n            }\n            return (STRING_TABLE_INDEX)Index;\n        }\n    }\n\n    return NO_MATCH_FOUND;\n}\n\n\nIsPrefixOfStringInTable_1\n← IsPrefixOfCStrInArray | IsPrefixOfStringInTable_2 →\nThis version is similar to the IsPrefixOfCStrInArray implementation, except it utilizes the slot length information provided by the STRING_ARRAY structure and conforms to our standard IsPrefixOfStringInTable function signature. It uses no SIMD instructions.\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_1(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This routine performs a simple linear scan of the string table looking for\n    a prefix match against each slot.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    BYTE Left;\n    BYTE Right;\n    ULONG Index;\n    ULONG Count;\n    PSTRING_ARRAY StringArray;\n    PSTRING TargetString;\n\n    //IACA_VC_START();\n\n    StringArray = StringTable-&gt;pStringArray;\n\n    if (StringArray-&gt;MinimumLength &gt; String-&gt;Length) {\n        return NO_MATCH_FOUND;\n    }\n\n    for (Count = 0; Count &lt; StringArray-&gt;NumberOfElements; Count++) {\n\n        TargetString = &StringArray-&gt;Strings[Count];\n\n        if (String-&gt;Length &lt; TargetString-&gt;Length) {\n            continue;\n        }\n\n        for (Index = 0; Index &lt; TargetString-&gt;Length; Index++) {\n            Left = String-&gt;Buffer[Index];\n            Right = TargetString-&gt;Buffer[Index];\n            if (Left != Right) {\n                break;\n            }\n        }\n\n        if (Index == TargetString-&gt;Length) {\n\n            if (ARGUMENT_PRESENT(Match)) {\n\n                Match-&gt;Index = (BYTE)Count;\n                Match-&gt;NumberOfMatchedCharacters = (BYTE)Index;\n                Match-&gt;String = TargetString;\n\n            }\n\n            return (STRING_TABLE_INDEX)Count;\n        }\n\n    }\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\nBenchmark 1\nHere’s the performance of these two baseline routines:\n\n\n\nBenchmark 1\n\n\nThat’s an interesting result! Even without using any SIMD instructions, version 1, the IsPrefixOfStringInTable_1 routine, is faster (in all but one case) than the baseline IsPrefixOfCStrInArray routine, thanks to a more sophisticated data structure.\n(And really, it’s not even using the sophisticated parts of the STRING_TABLE; it’s just leveraging the fact that we’ve captured the lengths of each string in the backing STRING_ARRAY structure by virtue of using the STRING structure to wrap our strings (instead of relying on the standard NULL-terminated C string approach).)\n\nBefore we look at IsPrefixOfStringInTable_2, which is the first of the routines to use SIMD instructions, it’s helpfu to know some backstory. The _2 version is based on the prefix matching routine I wrote for the first version of the StringTable component back in 2016. The layout of the STRING_TABLE struct differed in the first version; only the first character of each slot was used to do the initial exclusion (as opposed to the unique character), and lengths were unsigned shorts instead of chars (16 bits instead of 8 bits), so the match bitmap had to be constructed slightly differently.\nNone of those details really apply to our second attempt at the StringTable component, detailed in this article. Our lengths are 8 bits, and we use unique characters in the initial negative match fast-path. However, the first version used an elaborate AVX2 prefix match routine geared toward matching long strings, attempting to use non-temporal streaming load instructions where possible (which would only make sense for a large number of long strings in specific cache-thrashing scenarios).\nCompare our simpler implementation, IsPrefixMatch, used from version 3 onward, to the far more elaborate (and unnecessary) IsPrefixMatchAvx2:\n\n\nIsPrefixMatch\nFORCEINLINE\nBYTE\nIsPrefixMatch(\n    _In_ PCSTRING SearchString,\n    _In_ PCSTRING TargetString,\n    _In_ BYTE Offset\n    )\n{\n    PBYTE Left;\n    PBYTE Right;\n    BYTE Matched = 0;\n    BYTE Remaining = (SearchString-&gt;Length - Offset) + 1;\n\n    Left = (PBYTE)RtlOffsetToPointer(SearchString-&gt;Buffer, Offset);\n    Right = (PBYTE)RtlOffsetToPointer(TargetString-&gt;Buffer, Offset);\n\n    while (--Remaining && *Left++ == *Right++) {\n        Matched++;\n    }\n\n    Matched += Offset;\n    if (Matched != TargetString-&gt;Length) {\n        return NO_MATCH_FOUND;\n    }\n\n    return Matched;\n}\n\n\nIsPrefixMatchAvx2\nThe AVX2 routine is overkill, especially considering the emphasis we put on favoring short strings over longer ones in the requirements section. However, we want to put broad statements like that to the test, so let’s include it as our first SIMD implementation to see how it stacks up against the simpler versions.\nFORCEINLINE\nUSHORT\nIsPrefixMatchAvx2(\n    _In_ PCSTRING SearchString,\n    _In_ PCSTRING TargetString,\n    _In_ USHORT Offset\n    )\n{\n    USHORT SearchStringRemaining;\n    USHORT TargetStringRemaining;\n    ULONGLONG SearchStringAlignment;\n    ULONGLONG TargetStringAlignment;\n    USHORT CharactersMatched = Offset;\n\n    LONG Count;\n    LONG Mask;\n\n    PCHAR SearchBuffer;\n    PCHAR TargetBuffer;\n\n    STRING_SLOT SearchSlot;\n\n    XMMWORD SearchXmm;\n    XMMWORD TargetXmm;\n    XMMWORD ResultXmm;\n\n    YMMWORD SearchYmm;\n    YMMWORD TargetYmm;\n    YMMWORD ResultYmm;\n\n    SearchStringRemaining = SearchString-&gt;Length - Offset;\n    TargetStringRemaining = TargetString-&gt;Length - Offset;\n\n    SearchBuffer = (PCHAR)RtlOffsetToPointer(SearchString-&gt;Buffer, Offset);\n    TargetBuffer = (PCHAR)RtlOffsetToPointer(TargetString-&gt;Buffer, Offset);\n\n    //\n    // This routine is only called in the final stage of a prefix match when\n    // we've already verified the slot's corresponding original string length\n    // (referred in this routine as the target string) is less than or equal\n    // to the length of the search string.\n    //\n    // We attempt as many 32-byte comparisons as we can, then as many 16-byte\n    // comparisons as we can, then a final &lt; 16-byte comparison if necessary.\n    //\n    // We use aligned loads if possible, falling back to unaligned if not.\n    //\n\nStartYmm:\n\n    if (SearchStringRemaining &gt;= 32 && TargetStringRemaining &gt;= 32) {\n\n        //\n        // We have at least 32 bytes to compare for each string.  Check the\n        // alignment for each buffer and do an aligned streaming load (non-\n        // temporal hint) if our alignment is at a 32-byte boundary or better;\n        // reverting to an unaligned load when not.\n        //\n\n        SearchStringAlignment = GetAddressAlignment(SearchBuffer);\n        TargetStringAlignment = GetAddressAlignment(TargetBuffer);\n\n        if (SearchStringAlignment &lt; 32) {\n            SearchYmm = _mm256_loadu_si256((PYMMWORD)SearchBuffer);\n        } else {\n            SearchYmm = _mm256_stream_load_si256((PYMMWORD)SearchBuffer);\n        }\n\n        if (TargetStringAlignment &lt; 32) {\n            TargetYmm = _mm256_loadu_si256((PYMMWORD)TargetBuffer);\n        } else {\n            TargetYmm = _mm256_stream_load_si256((PYMMWORD)TargetBuffer);\n        }\n\n        //\n        // Compare the two vectors.\n        //\n\n        ResultYmm = _mm256_cmpeq_epi8(SearchYmm, TargetYmm);\n\n        //\n        // Generate a mask from the result of the comparison.\n        //\n\n        Mask = _mm256_movemask_epi8(ResultYmm);\n\n        //\n        // There were at least 32 characters remaining in each string buffer,\n        // thus, every character needs to have matched in order for this search\n        // to continue.  If there were less than 32 characters, we can terminate\n        // this prefix search here.  (-1 == 0xffffffff == all bits set == all\n        // characters matched.)\n        //\n\n        if (Mask != -1) {\n\n            //\n            // Not all characters were matched, terminate the prefix search.\n            //\n\n            return NO_MATCH_FOUND;\n        }\n\n        //\n        // All 32 characters were matched.  Update counters and pointers\n        // accordingly and jump back to the start of the 32-byte processing.\n        //\n\n        SearchStringRemaining -= 32;\n        TargetStringRemaining -= 32;\n\n        CharactersMatched += 32;\n\n        SearchBuffer += 32;\n        TargetBuffer += 32;\n\n        goto StartYmm;\n    }\n\n    //\n    // Intentional follow-on to StartXmm.\n    //\n\nStartXmm:\n\n    //\n    // Update the search string's alignment.\n    //\n\n    if (SearchStringRemaining &gt;= 16 && TargetStringRemaining &gt;= 16) {\n\n        //\n        // We have at least 16 bytes to compare for each string.  Check the\n        // alignment for each buffer and do an aligned streaming load (non-\n        // temporal hint) if our alignment is at a 16-byte boundary or better;\n        // reverting to an unaligned load when not.\n        //\n\n        SearchStringAlignment = GetAddressAlignment(SearchBuffer);\n\n        if (SearchStringAlignment &lt; 16) {\n            SearchXmm = _mm_loadu_si128((XMMWORD *)SearchBuffer);\n        } else {\n            SearchXmm = _mm_stream_load_si128((XMMWORD *)SearchBuffer);\n        }\n\n        TargetXmm = _mm_stream_load_si128((XMMWORD *)TargetBuffer);\n\n        //\n        // Compare the two vectors.\n        //\n\n        ResultXmm = _mm_cmpeq_epi8(SearchXmm, TargetXmm);\n\n        //\n        // Generate a mask from the result of the comparison.\n        //\n\n        Mask = _mm_movemask_epi8(ResultXmm);\n\n        //\n        // There were at least 16 characters remaining in each string buffer,\n        // thus, every character needs to have matched in order for this search\n        // to continue.  If there were less than 16 characters, we can terminate\n        // this prefix search here.  (-1 == 0xffff -&gt; all bits set -&gt; all chars\n        // matched.)\n        //\n\n        if ((SHORT)Mask != (SHORT)-1) {\n\n            //\n            // Not all characters were matched, terminate the prefix search.\n            //\n\n            return NO_MATCH_FOUND;\n        }\n\n        //\n        // All 16 characters were matched.  Update counters and pointers\n        // accordingly and jump back to the start of the 16-byte processing.\n        //\n\n        SearchStringRemaining -= 16;\n        TargetStringRemaining -= 16;\n\n        CharactersMatched += 16;\n\n        SearchBuffer += 16;\n        TargetBuffer += 16;\n\n        goto StartXmm;\n    }\n\n    if (TargetStringRemaining == 0) {\n\n        //\n        // We'll get here if we successfully prefix matched the search string\n        // and all our buffers were aligned (i.e. we don't have a trailing\n        // &lt; 16 bytes comparison to perform).\n        //\n\n        return CharactersMatched;\n    }\n\n    //\n    // If we get here, we have less than 16 bytes to compare.  Our target\n    // strings are guaranteed to be 16-byte aligned, so we can load them\n    // using an aligned stream load as in the previous cases.\n    //\n\n    TargetXmm = _mm_stream_load_si128((PXMMWORD)TargetBuffer);\n\n    //\n    // Loading the remainder of our search string's buffer is a little more\n    // complicated.  It could reside within 15 bytes of the end of the page\n    // boundary, which would mean that a 128-bit load would cross a page\n    // boundary.\n    //\n    // At best, the page will belong to our process and we'll take a performance\n    // hit.  At worst, we won't own the page, and we'll end up triggering a hard\n    // page fault.\n    //\n    // So, see if the current search buffer address plus 16 bytes crosses a page\n    // boundary.  If it does, take the safe but slower approach of a ranged\n    // memcpy (movsb) into a local stack-allocated STRING_SLOT structure.\n    //\n\n    if (!PointerToOffsetCrossesPageBoundary(SearchBuffer, 16)) {\n\n        //\n        // No page boundary is crossed, so just do an unaligned 128-bit move\n        // into our Xmm register.  (We could do the aligned/unaligned dance\n        // here, but it's the last load we'll be doing (i.e. it's not\n        // potentially on a loop path), so I don't think it's worth the extra\n        // branch cost, although I haven't measured this empirically.)\n        //\n\n        SearchXmm = _mm_loadu_si128((XMMWORD *)SearchBuffer);\n\n    } else {\n\n        //\n        // We cross a page boundary, so only copy the the bytes we need via\n        // __movsb(), then do an aligned stream load into the Xmm register\n        // we'll use in the comparison.\n        //\n\n        __movsb((PBYTE)&SearchSlot.Char,\n                (PBYTE)SearchBuffer,\n                SearchStringRemaining);\n\n        SearchXmm = _mm_stream_load_si128(&SearchSlot.CharsXmm);\n    }\n\n    //\n    // Compare the final vectors.\n    //\n\n    ResultXmm = _mm_cmpeq_epi8(SearchXmm, TargetXmm);\n\n    //\n    // Generate a mask from the result of the comparison, but mask off (zero\n    // out) high bits from the target string's remaining length.\n    //\n\n    Mask = _bzhi_u32(_mm_movemask_epi8(ResultXmm), TargetStringRemaining);\n\n    //\n    // Count how many characters were matched and determine if we were a\n    // successful prefix match or not.\n    //\n\n    Count = __popcnt(Mask);\n\n    if ((USHORT)Count == TargetStringRemaining) {\n\n        //\n        // If we matched the same amount of characters as remaining in the\n        // target string, we've successfully prefix matched the search string.\n        // Return the total number of characters we matched.\n        //\n\n        CharactersMatched += (USHORT)Count;\n        return CharactersMatched;\n    }\n\n    //\n    // After all that work, our string match failed at the final stage!  Return\n    // to the caller indicating we were unable to make a prefix match.\n    //\n\n    return NO_MATCH_FOUND;\n}\n\n\nIsPrefixOfStringInTable_2\n← IsPrefixOfStringInTable_1 | IsPrefixOfStringInTable_3 →\n\n\n\n\n\n\nNote\n\n\n\nThis is is the first time we’re seeing the full body of the SIMD-style IsPrefixOfStringInTable implementation. It’s heavily commented, and generally, the core algorithm doesn’t fundamentally change across iterations (just slight tweaks). I’d recommend reading through it thoroughly to build a mental model of how the matching algorithm works. It’s straightforward, and the subsequent iterations will make much more sense, as they’re typically presented as diffs against the previous version.\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_2(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This is our first AVX-optimized version of the routine.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    PSTRING_ARRAY StringArray;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlotsByLength;\n    XMMWORD IncludeSlots;\n    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n    StringArray = StringTable-&gt;pStringArray;\n\n    //\n    // If the minimum length of the string array is greater than the length of\n    // our search string, there can't be a prefix match.\n    //\n\n    if (StringArray-&gt;MinimumLength &gt; String-&gt;Length) {\n        goto NoMatch;\n    }\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    LoadSearchStringIntoXmmRegister(Search, String, SearchLength);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we invert the mask shortly after.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // Invert the result of the comparison; we want 0xff for slots to include\n    // and 0x0 for slots to ignore (it's currently the other way around).  We\n    // can achieve this by XOR'ing the result against our all-ones XMM register.\n    //\n\n    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n\n    //\n    // We're now ready to intersect the two XMM registers to determine which\n    // slots should still be included in the comparison (i.e. which slots have\n    // the exact same unique character as the string and a length less than or\n    // equal to the length of the search string).\n    //\n\n    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n                                 IncludeSlotsByLength);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    if (!Bitmap) {\n\n        //\n        // No bits were set, so there are no strings in this table starting\n        // with the same character and of a lesser or equal length as the\n        // search string.\n        //\n\n        goto NoMatch;\n    }\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched == 16 && Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatchAvx2(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n\n            } else {\n\n                //\n                // We successfully prefix matched the search string against\n                // this slot.  The code immediately following us deals with\n                // handling a successful prefix match at the initial slot\n                // level; let's avoid an unnecessary branch and just jump\n                // directly into it.\n                //\n\n                goto FoundMatch;\n            }\n        }\n\n        if ((USHORT)CharactersMatched == Length) {\n\nFoundMatch:\n\n            //\n            // This slot is a prefix match.  Fill out the Match structure if the\n            // caller provided a non-NULL pointer, then return the index of the\n            // match.\n            //\n\n\n            if (ARGUMENT_PRESENT(Match)) {\n\n                Match-&gt;Index = (BYTE)Index;\n                Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n                Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            }\n\n            return (STRING_TABLE_INDEX)Index;\n        }\n\n        //\n        // Not enough characters matched, so continue the loop.\n        //\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\nNoMatch:\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\nBenchmark 2\nLet’s see how version 2, our first SIMD attempt, performs in comparison to the two baselines.\n\n\n\nBenchmark 2\n\n\nEek! Our first SIMD attempt actually has worse prefix matching performance in most cases! The only area where it shows a performance improvement is in negative matching.\n\n\nIsPrefixOfStringInTable_3\n← IsPrefixOfStringInTable_2 | IsPrefixOfStringInTable_4 →\nFor version 3, let’s replace the call to IsPrefixMatchAvx2 with our simpler version, IsPrefixMatch:\n\nDiffFull\n\n\n% diff -u IsPrefixOfStringInTable_2.c IsPrefixOfStringInTable_3.c\n--- IsPrefixOfStringInTable_2.c 2018-04-15 22:35:55.458773500 -0400\n+++ IsPrefixOfStringInTable_3.c 2018-04-15 22:35:55.456274700 -0400\n@@ -18,7 +18,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_2(\n+IsPrefixOfStringInTable_3(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -278,7 +278,7 @@\n\n             TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n-            CharactersMatched = IsPrefixMatchAvx2(String, TargetString, 16);\n+            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n             if (CharactersMatched == NO_MATCH_FOUND) {\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_3(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This is our first AVX-optimized version of the routine.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    PSTRING_ARRAY StringArray;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlotsByLength;\n    XMMWORD IncludeSlots;\n    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n    StringArray = StringTable-&gt;pStringArray;\n\n    //\n    // If the minimum length of the string array is greater than the length of\n    // our search string, there can't be a prefix match.\n    //\n\n    if (StringArray-&gt;MinimumLength &gt; String-&gt;Length) {\n        goto NoMatch;\n    }\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    LoadSearchStringIntoXmmRegister(Search, String, SearchLength);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we invert the mask shortly after.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // Invert the result of the comparison; we want 0xff for slots to include\n    // and 0x0 for slots to ignore (it's currently the other way around).  We\n    // can achieve this by XOR'ing the result against our all-ones XMM register.\n    //\n\n    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n\n    //\n    // We're now ready to intersect the two XMM registers to determine which\n    // slots should still be included in the comparison (i.e. which slots have\n    // the exact same unique character as the string and a length less than or\n    // equal to the length of the search string).\n    //\n\n    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n                                 IncludeSlotsByLength);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    if (!Bitmap) {\n\n        //\n        // No bits were set, so there are no strings in this table starting\n        // with the same character and of a lesser or equal length as the\n        // search string.\n        //\n\n        goto NoMatch;\n    }\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched == 16 && Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n\n            } else {\n\n                //\n                // We successfully prefix matched the search string against\n                // this slot.  The code immediately following us deals with\n                // handling a successful prefix match at the initial slot\n                // level; let's avoid an unnecessary branch and just jump\n                // directly into it.\n                //\n\n                goto FoundMatch;\n            }\n        }\n\n        if ((USHORT)CharactersMatched == Length) {\n\nFoundMatch:\n\n            //\n            // This slot is a prefix match.  Fill out the Match structure if the\n            // caller provided a non-NULL pointer, then return the index of the\n            // match.\n            //\n\n\n            if (ARGUMENT_PRESENT(Match)) {\n\n                Match-&gt;Index = (BYTE)Index;\n                Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n                Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            }\n\n            return (STRING_TABLE_INDEX)Index;\n        }\n\n        //\n        // Not enough characters matched, so continue the loop.\n        //\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\nNoMatch:\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\n\n\nBenchmark 3\n\n\n\nBenchmark 3\n\n\nPhew! We finally see superior performance across the board. This ends the short-lived tenure of version 2, which is demonstrably worse in every case.\nWe’ll also omit the IsPrefixOfCStrInArray routine from the graphs for now (for the most part), as it has served its initial baseline purpose.\n\n\nIsPrefixOfStringInTable_4\n← IsPrefixOfStringInTable_3 | IsPrefixOfStringInTable_5 →\nWhen I first wrote the initial string table code, I was experimenting with different strategies for loading the initial search string buffer. That resulted in the file StringLoadStoreOperations.h, which defined a bunch of helper macros. I’ve included them below, but don’t spend too much time absorbing them—they’re not good practice, and they all become irrelevant as soon as we switch to _mm_loadu_si128() in a few versions. I’m including them because they set the scene for versions 4, 5, and 6.\n/*++\n\n    VOID\n    LoadSearchStringIntoXmmRegister_SEH(\n        _In_ STRING_SLOT Slot,\n        _In_ PSTRING String,\n        _In_ USHORT LengthVar\n        );\n\nRoutine Description:\n\n    Attempts an aligned 128-bit load of String-&gt;Buffer into Slot.CharXmm via\n    the _mm_load_si128() intrinsic.  The intrinsic is surrounded in a __try/\n    __except block that catches EXCEPTION_ACCESS_VIOLATION exceptions.\n\n    If such an exception is caught, the routine will check to see if the string\n    buffer's address will cross a page boundary if 16-bytes are loaded.  If a\n    page boundary would be crossed, a __movsb() intrinsic is used to copy only\n    the bytes specified by String-&gt;Length, otherwise, an unaligned 128-bit load\n    is attemped via the _mm_loadu_si128() intrinsic.\n\nArguments:\n\n    Slot - Supplies the STRING_SLOT local variable name within the calling\n        function that will receive the results of the load operation.\n\n    String - Supplies the name of the PSTRING variable that is to be loaded\n        into the slot.  This will usually be one of the function parameters.\n\n    LengthVar - Supplies the name of a USHORT local variable that will receive\n        the value of min(String-&gt;Length, 16).\n\nReturn Value:\n\n    None.\n\n--*/\n#define LoadSearchStringIntoXmmRegister_SEH(Slot, String, LengthVar)   \\\n    LengthVar = min(String-&gt;Length, 16);                               \\\n    TRY_SSE42_ALIGNED {                                                \\\n        Slot.CharsXmm = _mm_load_si128((PXMMWORD)String-&gt;Buffer);      \\\n    } CATCH_EXCEPTION_ACCESS_VIOLATION {                               \\\n        if (PointerToOffsetCrossesPageBoundary(String-&gt;Buffer, 16)) {  \\\n            __movsb(Slot.Char, String-&gt;Buffer, LengthVar);             \\\n        } else {                                                       \\\n            Slot.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer); \\\n        }                                                              \\\n    }\n\n/*++\n\n    VOID\n    LoadSearchStringIntoXmmRegister_AlignmentCheck(\n        _In_ STRING_SLOT Slot,\n        _In_ PSTRING String,\n        _In_ USHORT LengthVar\n        );\n\nRoutine Description:\n\n    This routine checks to see if a page boundary will be crossed if 16-bytes\n    are loaded from the address supplied by String-&gt;Buffer.  If a page boundary\n    will be crossed, a __movsb() intrinsic is used to only copy String-&gt;Length\n    bytes into the given Slot.\n\n    If no page boundary will be crossed by a 128-bit load, the alignment of\n    the address supplied by String-&gt;Buffer is checked.  If the alignment isn't\n    at least on a 16-byte boundary, an unaligned load will be issued via the\n    _mm_loadu_si128() intrinsic, otherwise, an _mm_load_si128() will be used.\n\nArguments:\n\n    Slot - Supplies the STRING_SLOT local variable name within the calling\n        function that will receive the results of the load operation.\n\n    String - Supplies the name of the PSTRING variable that is to be loaded\n        into the slot.  This will usually be one of the function parameters.\n\n    LengthVar - Supplies the name of a USHORT local variable that will receive\n        the value of min(String-&gt;Length, 16).\n\nReturn Value:\n\n    None.\n\n--*/\n#define LoadSearchStringIntoXmmRegister_AlignmentCheck(Slot, String,LengthVar) \\\n    LengthVar = min(String-&gt;Length, 16);                                       \\\n    if (PointerToOffsetCrossesPageBoundary(String-&gt;Buffer, 16)) {              \\\n        __movsb(Slot.Char, String-&gt;Buffer, LengthVar);                         \\\n    } else if (GetAddressAlignment(String-&gt;Buffer) &lt; 16) {                     \\\n        Slot.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);             \\\n    } else {                                                                   \\\n        Slot.CharsXmm = _mm_load_si128((PXMMWORD)String-&gt;Buffer);              \\\n    }\n\n/*++\n\n    VOID\n    LoadSearchStringIntoXmmRegister_AlwaysUnaligned(\n        _In_ STRING_SLOT Slot,\n        _In_ PSTRING String,\n        _In_ USHORT LengthVar\n        );\n\nRoutine Description:\n\n    This routine performs an unaligned 128-bit load of the address supplied by\n    String-&gt;Buffer into the given Slot via the _mm_loadu_si128() intrinsic.\n    No checks are done regarding whether or not a page boundary will be crossed.\n\nArguments:\n\n    Slot - Supplies the STRING_SLOT local variable name within the calling\n        function that will receive the results of the load operation.\n\n    String - Supplies the name of the PSTRING variable that is to be loaded\n        into the slot.  This will usually be one of the function parameters.\n\n    LengthVar - Supplies the name of a USHORT local variable that will receive\n        the value of min(String-&gt;Length, 16).\n\nReturn Value:\n\n    None.\n\n--*/\n#define LoadSearchStringIntoXmmRegister_Unaligned(Slot, String, LengthVar) \\\n    LengthVar = min(String-&gt;Length, 16);                                   \\\n    if (PointerToOffsetCrossesPageBoundary(String-&gt;Buffer, 16)) {          \\\n        __movsb(Slot.Char, String-&gt;Buffer, LengthVar);                     \\\n    } else if (GetAddressAlignment(String-&gt;Buffer) &lt; 16) {                 \\\n        Slot.CharsXmm = _mm_loadu_si128(String-&gt;Buffer);                   \\\n    } else {                                                               \\\n        Slot.CharsXmm = _mm_load_si128(String-&gt;Buffer);                    \\\n    }\n\n/*++\n\n    VOID\n    LoadSearchStringIntoXmmRegister_AlwaysMovsb(\n        _In_ STRING_SLOT Slot,\n        _In_ PSTRING String,\n        _In_ USHORT LengthVar\n        );\n\nRoutine Description:\n\n    This routine copies min(String-&gt;Length, 16) bytes from String-&gt;Buffer\n    into the given Slot via the __movsb() intrinsic.  The memory referenced by\n    the Slot is not cleared first via SecureZeroMemory().\n\nArguments:\n\n    Slot - Supplies the STRING_SLOT local variable name within the calling\n        function that will receive the results of the load operation.\n\n    String - Supplies the name of the PSTRING variable that is to be loaded\n        into the slot.  This will usually be one of the function parameters.\n\n    LengthVar - Supplies the name of a USHORT local variable that will receive\n        the value of min(String-&gt;Length, 16).\n\nReturn Value:\n\n    None.\n\n--*/\n#define LoadSearchStringIntoXmmRegister_AlwaysMovsb(Slot, String, LengthVar) \\\n    LengthVar = min(String-&gt;Length, 16);                                     \\\n    __movsb(Slot.Char, String-&gt;Buffer, LengthVar);\nIn our StringTable2.vcxproj file, we have the following:\n\n  &lt;PropertyGroup Label=\"Globals\"&gt;\n    ...\n    &lt;LoadSearchStringStrategy&gt;AlwaysMovsb&lt;/LoadSearchStringStrategy&gt;\n    &lt;!--\n    &lt;LoadSearchStringStrategy&gt;SEH&lt;/LoadSearchStringStrategy&gt;\n    &lt;LoadSearchStringStrategy&gt;AlignmentCheck&lt;/LoadSearchStringStrategy&gt;\n    &lt;LoadSearchStringStrategy&gt;AlwaysUnaligned&lt;/LoadSearchStringStrategy&gt;\n    --&gt;\nThis setup allowed me to toggle which strategy I wanted to use for loading the search string into an XMM register. As shown above, the default is to use the AlwaysMovsb approach*; so, for version 4, let’s swap that out for the SEH approach, which wraps the aligned load in a structured exception handler that falls back to __movsb() if the aligned load fails and the pointer plus 16 bytes crosses a page boundary.\n [*]: Or was it?\nNarrator: it wasn’t.\n\n\nDiffFull\n\n\n% diff -u IsPrefixOfStringInTable_4.c IsPrefixOfStringInTable_3.c\n--- IsPrefixOfStringInTable_3.c 2018-04-15 22:35:55.456274700 -0400\n+++ IsPrefixOfStringInTable_4.c 2018-04-15 22:35:55.453274200 -0400\n@@ -18,7 +18,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_3(\n+IsPrefixOfStringInTable_4(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -31,7 +31,8 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This is our first AVX-optimized version of the routine.\n+    This routine is a variant of version 3 that uses a structured exception\n+    handler for loading the initial search string.\n\n Arguments:\n\n@@ -123,7 +124,7 @@\n     // Load the first 16-bytes of the search string into an XMM register.\n     //\n\n-    LoadSearchStringIntoXmmRegister(Search, String, SearchLength);\n+    LoadSearchStringIntoXmmRegister_SEH(Search, String, SearchLength);\n\n     //\n     // Broadcast the search string's unique characters according to the string\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_4(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This routine is a variant of version 3 that uses a structured exception\n    handler for loading the initial search string.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    PSTRING_ARRAY StringArray;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlotsByLength;\n    XMMWORD IncludeSlots;\n    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n    StringArray = StringTable-&gt;pStringArray;\n\n    //\n    // If the minimum length of the string array is greater than the length of\n    // our search string, there can't be a prefix match.\n    //\n\n    if (StringArray-&gt;MinimumLength &gt; String-&gt;Length) {\n        goto NoMatch;\n    }\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    LoadSearchStringIntoXmmRegister_SEH(Search, String, SearchLength);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we invert the mask shortly after.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // Invert the result of the comparison; we want 0xff for slots to include\n    // and 0x0 for slots to ignore (it's currently the other way around).  We\n    // can achieve this by XOR'ing the result against our all-ones XMM register.\n    //\n\n    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n\n    //\n    // We're now ready to intersect the two XMM registers to determine which\n    // slots should still be included in the comparison (i.e. which slots have\n    // the exact same unique character as the string and a length less than or\n    // equal to the length of the search string).\n    //\n\n    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n                                 IncludeSlotsByLength);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    if (!Bitmap) {\n\n        //\n        // No bits were set, so there are no strings in this table starting\n        // with the same character and of a lesser or equal length as the\n        // search string.\n        //\n\n        goto NoMatch;\n    }\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched == 16 && Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n\n            } else {\n\n                //\n                // We successfully prefix matched the search string against\n                // this slot.  The code immediately following us deals with\n                // handling a successful prefix match at the initial slot\n                // level; let's avoid an unnecessary branch and just jump\n                // directly into it.\n                //\n\n                goto FoundMatch;\n            }\n        }\n\n        if ((USHORT)CharactersMatched == Length) {\n\nFoundMatch:\n\n            //\n            // This slot is a prefix match.  Fill out the Match structure if the\n            // caller provided a non-NULL pointer, then return the index of the\n            // match.\n            //\n\n\n            if (ARGUMENT_PRESENT(Match)) {\n\n                Match-&gt;Index = (BYTE)Index;\n                Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n                Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            }\n\n            return (STRING_TABLE_INDEX)Index;\n        }\n\n        //\n        // Not enough characters matched, so continue the loop.\n        //\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\nNoMatch:\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\n\n\nBenchmark 4\nThe performance of version 4 was slightly worse than 3 in every case:\n\n\n\nBenchmark 4\n\n\nVersion 3 is still in the lead with the AlwaysMovsb-based search string loading approach.\n Narrator: except the AlignmentCheck macro was actually active, not the AlwaysMovsb one. \n\n\nIsPrefixOfStringInTable_5\n← IsPrefixOfStringInTable_4 | IsPrefixOfStringInTable_6 →\nVersion 5 is an interesting one. It’s the first time we attempt to validate our claim that it’s more efficient to give the CPU a bunch of independent things to do up front, rather than adding more branches and attempting to terminate as early as possible.\nNote: we’ll also explicitly use the LoadSearchStringIntoXmmRegister_AlwaysMovsb macro here, instead of LoadSearchStringIntoXmmRegister, to make it clear that we’re actually relying on the __movsb()-based string loading routine.\n Narrator: can anyone spot the mistake with this logic? \n\nDiffFull\n\n\n% diff -u IsPrefixOfStringInTable_3.c IsPrefixOfStringInTable_5.c\n--- IsPrefixOfStringInTable_3.c 2018-04-15 22:35:55.456274700 -0400\n+++ IsPrefixOfStringInTable_5.c 2018-04-15 13:24:52.480972900 -0400\n@@ -16,9 +16,13 @@\n\n #include \"stdafx.h\"\n\n+//\n+// Variant of v3 with early-exits.\n+//\n+\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_3(\n+IsPrefixOfStringInTable_5(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -31,7 +35,11 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This is our first AVX-optimized version of the routine.\n+    This routine is a variant of version 3 that uses early exits (i.e.\n+    returning NO_MATCH_FOUND as early as we can).  It is designed to evaluate\n+    the assertion we've been making that it's more optimal to give the CPU\n+    to do a bunch of things up front versus doing something, then potentially\n+    branching, doing the next thing, potentially branching, etc.\n\n Arguments:\n\n@@ -51,6 +59,8 @@\n --*/\n {\n     ULONG Bitmap;\n+    ULONG CharBitmap;\n+    ULONG LengthBitmap;\n     ULONG Mask;\n     ULONG Count;\n     ULONG Length;\n@@ -71,7 +81,6 @@\n     XMMWORD IncludeSlotsByUniqueChar;\n     XMMWORD IgnoreSlotsByLength;\n     XMMWORD IncludeSlotsByLength;\n-    XMMWORD IncludeSlots;\n     const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n     StringArray = StringTable-&gt;pStringArray;\n@@ -123,7 +132,7 @@\n     // Load the first 16-bytes of the search string into an XMM register.\n     //\n\n-    LoadSearchStringIntoXmmRegister(Search, String, SearchLength);\n+    LoadSearchStringIntoXmmRegister_AlwaysMovsb(Search, String, SearchLength);\n\n     //\n     // Broadcast the search string's unique characters according to the string\n@@ -133,11 +142,6 @@\n     UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                   StringTable-&gt;UniqueIndex.IndexXmm);\n\n-    //\n-    // Load the slot length array into an XMM register.\n-    //\n-\n-    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n     //\n     // Load the string table's unique character array into an XMM register.\n@@ -146,13 +150,6 @@\n     TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n     //\n-    // Broadcast the search string's length into an XMM register.\n-    //\n-\n-    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n-    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n-\n-    //\n     // Compare the search string's unique character with all of the unique\n     // characters of strings in the table, saving the results into an XMM\n     // register.  This comparison will indicate which slots we can ignore\n@@ -162,6 +159,25 @@\n\n     IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n+    CharBitmap = _mm_movemask_epi8(IncludeSlotsByUniqueChar);\n+\n+    if (!CharBitmap) {\n+        return NO_MATCH_FOUND;\n+    }\n+\n+    //\n+    // Load the slot length array into an XMM register.\n+    //\n+\n+    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n+\n+    //\n+    // Broadcast the search string's length into an XMM register.\n+    //\n+\n+    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n+    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n+\n     //\n     // Find all slots that are longer than the incoming string length, as these\n     // are the ones we're going to exclude from any prefix match.\n@@ -182,31 +198,16 @@\n\n     IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n\n-    //\n-    // We're now ready to intersect the two XMM registers to determine which\n-    // slots should still be included in the comparison (i.e. which slots have\n-    // the exact same unique character as the string and a length less than or\n-    // equal to the length of the search string).\n-    //\n-\n-    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n-                                 IncludeSlotsByLength);\n+    LengthBitmap = _mm_movemask_epi8(IncludeSlotsByLength);\n\n-    //\n-    // Generate a mask.\n-    //\n+    if (!LengthBitmap) {\n+        return NO_MATCH_FOUND;\n+    }\n\n-    Bitmap = _mm_movemask_epi8(IncludeSlots);\n+    Bitmap = CharBitmap & LengthBitmap;\n\n     if (!Bitmap) {\n-\n-        //\n-        // No bits were set, so there are no strings in this table starting\n-        // with the same character and of a lesser or equal length as the\n-        // search string.\n-        //\n-\n-        goto NoMatch;\n+        return NO_MATCH_FOUND;\n     }\n\n     //\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_5(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This routine is a variant of version 3 that uses early exits (i.e.\n    returning NO_MATCH_FOUND as early as we can).  It is designed to evaluate\n    the assertion we've been making that it's more optimal to give the CPU\n    to do a bunch of things up front versus doing something, then potentially\n    branching, doing the next thing, potentially branching, etc.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG CharBitmap;\n    ULONG LengthBitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    PSTRING_ARRAY StringArray;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlotsByLength;\n    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n    StringArray = StringTable-&gt;pStringArray;\n\n    //\n    // If the minimum length of the string array is greater than the length of\n    // our search string, there can't be a prefix match.\n    //\n\n    if (StringArray-&gt;MinimumLength &gt; String-&gt;Length) {\n        goto NoMatch;\n    }\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    LoadSearchStringIntoXmmRegister_AlwaysMovsb(Search, String, SearchLength);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    CharBitmap = _mm_movemask_epi8(IncludeSlotsByUniqueChar);\n\n    if (!CharBitmap) {\n        return NO_MATCH_FOUND;\n    }\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we invert the mask shortly after.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // Invert the result of the comparison; we want 0xff for slots to include\n    // and 0x0 for slots to ignore (it's currently the other way around).  We\n    // can achieve this by XOR'ing the result against our all-ones XMM register.\n    //\n\n    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n\n    LengthBitmap = _mm_movemask_epi8(IncludeSlotsByLength);\n\n    if (!LengthBitmap) {\n        return NO_MATCH_FOUND;\n    }\n\n    Bitmap = CharBitmap & LengthBitmap;\n\n    if (!Bitmap) {\n        return NO_MATCH_FOUND;\n    }\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched == 16 && Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n\n            } else {\n\n                //\n                // We successfully prefix matched the search string against\n                // this slot.  The code immediately following us deals with\n                // handling a successful prefix match at the initial slot\n                // level; let's avoid an unnecessary branch and just jump\n                // directly into it.\n                //\n\n                goto FoundMatch;\n            }\n        }\n\n        if ((USHORT)CharactersMatched == Length) {\n\nFoundMatch:\n\n            //\n            // This slot is a prefix match.  Fill out the Match structure if the\n            // caller provided a non-NULL pointer, then return the index of the\n            // match.\n            //\n\n\n            if (ARGUMENT_PRESENT(Match)) {\n\n                Match-&gt;Index = (BYTE)Index;\n                Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n                Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            }\n\n            return (STRING_TABLE_INDEX)Index;\n        }\n\n        //\n        // Not enough characters matched, so continue the loop.\n        //\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\nNoMatch:\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\n\n\nBenchmark 5\nIf our theory is correct, the performance of this version should be worse, due to all the extra branches in the initial test. Let’s see if we’re right:\n\n\n\nBenchmark 5\n\n\nHoly smokes, version 5 is bad! It’s so bad it’s actually closest in performance to the failed version 2 with the elaborate AVX2 prefix matching routine.\n\n\n\n\n\n\nNote\n\n\n\nIt was actually so close I double-checked the two routines to ensure they were correct; they were, so this is just a coincidence.\n\n\nThat’s good news, though, as it validates the assumption we’ve been working with since inception:\n//\n// We do all five of these operations up front regardless of whether or not\n// they're strictly necessary.  That is, if the unique character isn't in\n// the unique character array, we don't need to load array lengths -- and\n// vice versa.  However, we assume the benefits afforded by giving the CPU\n// a bunch of independent things to do unconditionally up-front outweigh\n// the cost of putting in branches and conditionally loading things if\n// necessary.\n//\nThat’s the end of version 5’s tenure. TL;DR: fewer branches &gt; more branches.\n Narrator: more accurate TL;DR: __movsb() is slow, and always make sure you’re testing what you think you’re testing.] \n\n\nIsPrefixOfStringInTable_6\n← IsPrefixOfStringInTable_5 | IsPrefixOfStringInTable_7 →\nVersion 6 is boring. We tweak the initial loading of the search string, explicitly loading it via an unaligned load. If the underlying buffer is aligned on a 16-byte boundary, this is just as fast as an aligned load. If not, at least it doesn’t crash—it’s just slow.\n\n\n\n\n\n\nTip\n\n\n\nIf you attempt an aligned load on an address that isn’t aligned at a 16-byte boundary, the processor will generate an exception, causing your program to crash (assuming you don’t have any structured exception handlers in place to catch the error).\n\n\n\nDiffFull\n\n\n% diff -u IsPrefixOfStringInTable_3.c IsPrefixOfStringInTable_6.c\n--- IsPrefixOfStringInTable_3.c 2018-04-15 22:35:55.456274700 -0400\n+++ IsPrefixOfStringInTable_6.c 2018-04-26 18:29:40.594556800 -0400\n@@ -18,7 +18,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_3(\n+IsPrefixOfStringInTable_6(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -31,7 +31,8 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This is our first AVX-optimized version of the routine.\n+    This routine differs from version 3 in that we do an unaligned load of\n+    the search string buffer without any SEH wrappers or alignment checks.\n\n Arguments:\n\n@@ -123,7 +124,8 @@\n     // Load the first 16-bytes of the search string into an XMM register.\n     //\n\n-    LoadSearchStringIntoXmmRegister(Search, String, SearchLength);\n+    SearchLength = min(String-&gt;Length, 16);\n+    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n     //\n     // Broadcast the search string's unique characters according to the string\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_6(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This routine differs from version 3 in that we do an unaligned load of\n    the search string buffer without any SEH wrappers or alignment checks.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    PSTRING_ARRAY StringArray;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlotsByLength;\n    XMMWORD IncludeSlots;\n    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n    StringArray = StringTable-&gt;pStringArray;\n\n    //\n    // If the minimum length of the string array is greater than the length of\n    // our search string, there can't be a prefix match.\n    //\n\n    if (StringArray-&gt;MinimumLength &gt; String-&gt;Length) {\n        goto NoMatch;\n    }\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    SearchLength = min(String-&gt;Length, 16);\n    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we invert the mask shortly after.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // Invert the result of the comparison; we want 0xff for slots to include\n    // and 0x0 for slots to ignore (it's currently the other way around).  We\n    // can achieve this by XOR'ing the result against our all-ones XMM register.\n    //\n\n    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n\n    //\n    // We're now ready to intersect the two XMM registers to determine which\n    // slots should still be included in the comparison (i.e. which slots have\n    // the exact same unique character as the string and a length less than or\n    // equal to the length of the search string).\n    //\n\n    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n                                 IncludeSlotsByLength);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    if (!Bitmap) {\n\n        //\n        // No bits were set, so there are no strings in this table starting\n        // with the same character and of a lesser or equal length as the\n        // search string.\n        //\n\n        goto NoMatch;\n    }\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched == 16 && Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n\n            } else {\n\n                //\n                // We successfully prefix matched the search string against\n                // this slot.  The code immediately following us deals with\n                // handling a successful prefix match at the initial slot\n                // level; let's avoid an unnecessary branch and just jump\n                // directly into it.\n                //\n\n                goto FoundMatch;\n            }\n        }\n\n        if ((USHORT)CharactersMatched == Length) {\n\nFoundMatch:\n\n            //\n            // This slot is a prefix match.  Fill out the Match structure if the\n            // caller provided a non-NULL pointer, then return the index of the\n            // match.\n            //\n\n\n            if (ARGUMENT_PRESENT(Match)) {\n\n                Match-&gt;Index = (BYTE)Index;\n                Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n                Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            }\n\n            return (STRING_TABLE_INDEX)Index;\n        }\n\n        //\n        // Not enough characters matched, so continue the loop.\n        //\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\nNoMatch:\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\n\n\nBenchmark 6\nVersion 6 should be faster than version 3; we omit alignment checks, all of our input buffers are aligned at 32 bytes, and an unaligned XMM load of an aligned buffer should definitely be faster than a __movsb(). Let’s see:\n\n\n\nBenchmark 6\n\n\nWe have a new winner! Version 3 had a good run, but it’s time to retire. Let’s tweak version 6 going forward.\n Narrator: this is actually testing _mm_loadu_si128() against the AlignmentCheck routine, which first calls PointerToOffsetCrossesPageBoundary(), and then checks the address alignment before calling _mm_load_si128(). Since unaligned loads are just as fast as aligned loads as long as the underlying buffer is aligned, all this shows is that it’s slightly faster to skip the pointer boundary and address alignment checks, which isn’t too surprising. \n\n\nIsPrefixOfStringInTable_7\n← IsPrefixOfStringInTable_6 | IsPrefixOfStringInTable_8 →\nVersion 7 tweaks version 6 a little bit. We don’t need the search string length calculated so early in the routine. Let’s move it to later.\n\nDiffFull\n\n\n% diff -u IsPrefixOfStringInTable_6.c IsPrefixOfStringInTable_7.c\n--- IsPrefixOfStringInTable_6.c 2018-04-15 22:35:55.450273700 -0400\n+++ IsPrefixOfStringInTable_7.c 2018-04-26 10:00:53.905933700 -0400\n@@ -18,7 +18,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_6(\n+IsPrefixOfStringInTable_7(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -31,9 +31,10 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This routine differs from version 3 in that we do an aligned load of the\n-    search string buffer without any SEH wrappers or alignment checks.  (Thus,\n-    this routine will fault if the buffer is unaligned.)\n+    This routine is based off version 6, but alters when we calculate the\n+    \"search length\" for the given string, which is done via the expression\n+    'min(String-&gt;Length, 16)'.  We don't need this value until later in the\n+    routine, when we're ready to start comparing strings.\n\n Arguments:\n\n@@ -125,7 +126,6 @@\n     // Load the first 16-bytes of the search string into an XMM register.\n     //\n\n-    SearchLength = min(String-&gt;Length, 16);\n     Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n     //\n@@ -213,6 +213,13 @@\n     }\n\n     //\n+    // Calculate the \"search length\" of the incoming string, which ensures we\n+    // only compare up to the first 16 characters.\n+    //\n+\n+    SearchLength = min(String-&gt;Length, 16);\n+\n+    //\n     // A popcount against the mask will tell us how many slots we matched, and\n     // thus, need to compare.\n     //\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_7(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This routine is based off version 6, but alters when we calculate the\n    \"search length\" for the given string, which is done via the expression\n    'min(String-&gt;Length, 16)'.  We don't need this value until later in the\n    routine, when we're ready to start comparing strings.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    PSTRING_ARRAY StringArray;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlotsByLength;\n    XMMWORD IncludeSlots;\n    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n    StringArray = StringTable-&gt;pStringArray;\n\n    //\n    // If the minimum length of the string array is greater than the length of\n    // our search string, there can't be a prefix match.\n    //\n\n    if (StringArray-&gt;MinimumLength &gt; String-&gt;Length) {\n        goto NoMatch;\n    }\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we invert the mask shortly after.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // Invert the result of the comparison; we want 0xff for slots to include\n    // and 0x0 for slots to ignore (it's currently the other way around).  We\n    // can achieve this by XOR'ing the result against our all-ones XMM register.\n    //\n\n    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n\n    //\n    // We're now ready to intersect the two XMM registers to determine which\n    // slots should still be included in the comparison (i.e. which slots have\n    // the exact same unique character as the string and a length less than or\n    // equal to the length of the search string).\n    //\n\n    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n                                 IncludeSlotsByLength);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    if (!Bitmap) {\n\n        //\n        // No bits were set, so there are no strings in this table starting\n        // with the same character and of a lesser or equal length as the\n        // search string.\n        //\n\n        goto NoMatch;\n    }\n\n    //\n    // Calculate the \"search length\" of the incoming string, which ensures we\n    // only compare up to the first 16 characters.\n    //\n\n    SearchLength = min(String-&gt;Length, 16);\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched == 16 && Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n\n            } else {\n\n                //\n                // We successfully prefix matched the search string against\n                // this slot.  The code immediately following us deals with\n                // handling a successful prefix match at the initial slot\n                // level; let's avoid an unnecessary branch and just jump\n                // directly into it.\n                //\n\n                goto FoundMatch;\n            }\n        }\n\n        if ((USHORT)CharactersMatched == Length) {\n\nFoundMatch:\n\n            //\n            // This slot is a prefix match.  Fill out the Match structure if the\n            // caller provided a non-NULL pointer, then return the index of the\n            // match.\n            //\n\n\n            if (ARGUMENT_PRESENT(Match)) {\n\n                Match-&gt;Index = (BYTE)Index;\n                Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n                Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            }\n\n            return (STRING_TABLE_INDEX)Index;\n        }\n\n        //\n        // Not enough characters matched, so continue the loop.\n        //\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\nNoMatch:\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\nThis is a tiny change; if it shows any performance difference, it should lean towards a positive change, although it’s possible the compiler deferred scheduling until after the initial negative match logic since the expression wasn’t used immediately. Let’s see.\n\n\nBenchmark 7\n\n\n\nBenchmark 7\n\n\nTiny change, tiny performance improvement! Looks like this saves a couple of cycles, thus ending the short-lived reign of version 6.\n\n\nIsPrefixOfStringInTable_8\n← IsPrefixOfStringInTable_7 | IsPrefixOfStringInTable_9 →\nVersion 8 is based off version 7, but omits the initial length test. Again, it’s another small change, but if version 5 was anything to go off, the less branches, the better.\n\nDiffFull\n\n\n\n% diff -u IsPrefixOfStringInTable_7.c IsPrefixOfStringInTable_8.c\n--- IsPrefixOfStringInTable_7.c 2018-04-26 10:21:43.253466500 -0400\n+++ IsPrefixOfStringInTable_8.c 2018-04-26 10:21:27.109761800 -0400\n@@ -18,7 +18,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_7(\n+IsPrefixOfStringInTable_8(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -31,10 +31,8 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This routine is based off version 6, but alters when we calculate the\n-    \"search length\" for the given string, which is done via the expression\n-    'min(String-&gt;Length, 16)'.  We don't need this value until later in the\n-    routine, when we're ready to start comparing strings.\n+    This routine is based off version 7, but omits the initial minimum\n+    length test of the string array.\n\n Arguments:\n\n@@ -63,7 +61,6 @@\n     ULONG NumberOfTrailingZeros;\n     ULONG SearchLength;\n     PSTRING TargetString;\n-    PSTRING_ARRAY StringArray;\n     STRING_SLOT Slot;\n     STRING_SLOT Search;\n     STRING_SLOT Compare;\n@@ -77,17 +74,6 @@\n     XMMWORD IncludeSlots;\n     const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n-    StringArray = StringTable-&gt;pStringArray;\n-\n-    //\n-    // If the minimum length of the string array is greater than the length of\n-    // our search string, there can't be a prefix match.\n-    //\n-\n-    if (StringArray-&gt;MinimumLength &gt; String-&gt;Length) {\n-        goto NoMatch;\n-    }\n-\n     //\n     // Unconditionally do the following five operations before checking any of\n     // the results and determining how the search should proceed:\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_8(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This routine is based off version 7, but omits the initial minimum\n    length test of the string array.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlotsByLength;\n    XMMWORD IncludeSlots;\n    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we invert the mask shortly after.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // Invert the result of the comparison; we want 0xff for slots to include\n    // and 0x0 for slots to ignore (it's currently the other way around).  We\n    // can achieve this by XOR'ing the result against our all-ones XMM register.\n    //\n\n    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n\n    //\n    // We're now ready to intersect the two XMM registers to determine which\n    // slots should still be included in the comparison (i.e. which slots have\n    // the exact same unique character as the string and a length less than or\n    // equal to the length of the search string).\n    //\n\n    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n                                 IncludeSlotsByLength);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    if (!Bitmap) {\n\n        //\n        // No bits were set, so there are no strings in this table starting\n        // with the same character and of a lesser or equal length as the\n        // search string.\n        //\n\n        goto NoMatch;\n    }\n\n    //\n    // Calculate the \"search length\" of the incoming string, which ensures we\n    // only compare up to the first 16 characters.\n    //\n\n    SearchLength = min(String-&gt;Length, 16);\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched == 16 && Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n\n            } else {\n\n                //\n                // We successfully prefix matched the search string against\n                // this slot.  The code immediately following us deals with\n                // handling a successful prefix match at the initial slot\n                // level; let's avoid an unnecessary branch and just jump\n                // directly into it.\n                //\n\n                goto FoundMatch;\n            }\n        }\n\n        if ((USHORT)CharactersMatched == Length) {\n\nFoundMatch:\n\n            //\n            // This slot is a prefix match.  Fill out the Match structure if the\n            // caller provided a non-NULL pointer, then return the index of the\n            // match.\n            //\n\n\n            if (ARGUMENT_PRESENT(Match)) {\n\n                Match-&gt;Index = (BYTE)Index;\n                Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n                Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            }\n\n            return (STRING_TABLE_INDEX)Index;\n        }\n\n        //\n        // Not enough characters matched, so continue the loop.\n        //\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\nNoMatch:\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\n\n\nBenchmark 8\n\n\n\nBenchmark 8\n\n\nHey, look at that, another win across the board! Omitting the length test shaves off a few more cycles for both prefix and negative matching. Version 7’s one-round reign has come to a timely end.\n\n\nIsPrefixOfStringInTable_9\n← IsPrefixOfStringInTable_8 | IsPrefixOfStringInTable_10 →\nVersion 9 tweaks version 8 by simply using return NO_MATCH_FOUND after the initial bitmap check instead of goto NoMatch. (The use of goto was a bit peculiar there anyway. We’re going to rewrite the body similarly for version 10, but let’s try to stick to making one change at a time.)\n\nDiffFull\n\n\n--- IsPrefixOfStringInTable_8.c 2018-04-26 10:30:52.337935400 -0400\n+++ IsPrefixOfStringInTable_9.c 2018-04-26 10:32:04.986734400 -0400\n@@ -18,7 +18,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_8(\n+IsPrefixOfStringInTable_9(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -31,8 +31,8 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This routine is based off version 7, but omits the initial minimum\n-    length test of the string array.\n+    This is a tweaked version of version 8 that does 'return NO_MATCH_FOUND'\n+    after the initial bitmap check versus 'goto NoMatch'.\n\n Arguments:\n\n@@ -195,7 +195,7 @@\n         // search string.\n         //\n\n-        goto NoMatch;\n+        return NO_MATCH_FOUND;\n     }\n\n     //\n@@ -330,8 +330,6 @@\n     // If we get here, we didn't find a match.\n     //\n\n-NoMatch:\n-\n     //IACA_VC_END();\n\n     return NO_MATCH_FOUND;\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_9(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This is a tweaked version of version 9 that does 'return NO_MATCH_FOUND'\n    after the initial bitmap check versus 'goto NoMatch'.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlotsByLength;\n    XMMWORD IncludeSlots;\n    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we invert the mask shortly after.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // Invert the result of the comparison; we want 0xff for slots to include\n    // and 0x0 for slots to ignore (it's currently the other way around).  We\n    // can achieve this by XOR'ing the result against our all-ones XMM register.\n    //\n\n    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n\n    //\n    // We're now ready to intersect the two XMM registers to determine which\n    // slots should still be included in the comparison (i.e. which slots have\n    // the exact same unique character as the string and a length less than or\n    // equal to the length of the search string).\n    //\n\n    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n                                 IncludeSlotsByLength);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    if (!Bitmap) {\n\n        //\n        // No bits were set, so there are no strings in this table starting\n        // with the same character and of a lesser or equal length as the\n        // search string.\n        //\n\n        return NO_MATCH_FOUND;\n    }\n\n    //\n    // Calculate the \"search length\" of the incoming string, which ensures we\n    // only compare up to the first 16 characters.\n    //\n\n    SearchLength = min(String-&gt;Length, 16);\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched == 16 && Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n\n            } else {\n\n                //\n                // We successfully prefix matched the search string against\n                // this slot.  The code immediately following us deals with\n                // handling a successful prefix match at the initial slot\n                // level; let's avoid an unnecessary branch and just jump\n                // directly into it.\n                //\n\n                goto FoundMatch;\n            }\n        }\n\n        if ((USHORT)CharactersMatched == Length) {\n\nFoundMatch:\n\n            //\n            // This slot is a prefix match.  Fill out the Match structure if the\n            // caller provided a non-NULL pointer, then return the index of the\n            // match.\n            //\n\n\n            if (ARGUMENT_PRESENT(Match)) {\n\n                Match-&gt;Index = (BYTE)Index;\n                Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n                Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            }\n\n            return (STRING_TABLE_INDEX)Index;\n        }\n\n        //\n        // Not enough characters matched, so continue the loop.\n        //\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\n\n\nBenchmark 9\n\n\n\nBenchmark 09\n\n\nThis is an interesting one. The return versus goto appears to have cost us a tiny bit with the first few test inputs—only about 0.2 more cycles, which is negligible in the grand scheme of things. (Though let’s not pull on that thread too much, or the entire premise of the article might start to unravel!)\nVersion 9 improves the negative match performance by a few cycles, so let’s keep it.\n\n\nIsPrefixOfStringInTable_10\n← IsPrefixOfStringInTable_9 | IsPrefixOfStringInTable_11 →\nAt this point, we’ve exhausted all the small, easy tweaks. Let’s rewrite the inner loop that performs the character comparison and see how that affects performance.\nThis should be an interesting one because the way it’s written now is… a bit odd. (I’ve clearly made some assumptions about optimal branch organization, to say the least.)\n\nDiffFull\n\n\n% diff -u IsPrefixOfStringInTable_9.c IsPrefixOfStringInTable_10.c\n--- IsPrefixOfStringInTable_9.c 2018-04-26 10:32:04.986734400 -0400\n+++ IsPrefixOfStringInTable_10.c        2018-04-26 10:38:09.357890400 -0400\n@@ -18,7 +18,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_9(\n+IsPrefixOfStringInTable_10(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -31,8 +31,8 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This is a tweaked version of version 8 that does 'return NO_MATCH_FOUND'\n-    after the initial bitmap check versus 'goto NoMatch'.\n+    This version is based off version 9, but rewrites the inner loop that\n+    checks for comparisons.\n\n Arguments:\n\n@@ -264,7 +264,17 @@\n\n         CharactersMatched = __popcnt(Mask);\n\n-        if ((USHORT)CharactersMatched == 16 && Length &gt; 16) {\n+        if ((USHORT)CharactersMatched &lt; Length && Length &lt;= 16) {\n+\n+            //\n+            // The slot length is longer than the number of characters matched\n+            // from the search string; this isn't a prefix match.  Continue.\n+            //\n+\n+            continue;\n+        }\n+\n+        if (Length &gt; 16) {\n\n             //\n             // The first 16 characters in the string matched against this\n@@ -283,46 +293,24 @@\n                 //\n\n                 continue;\n-\n-            } else {\n-\n-                //\n-                // We successfully prefix matched the search string against\n-                // this slot.  The code immediately following us deals with\n-                // handling a successful prefix match at the initial slot\n-                // level; let's avoid an unnecessary branch and just jump\n-                // directly into it.\n-                //\n-\n-                goto FoundMatch;\n             }\n         }\n\n-        if ((USHORT)CharactersMatched == Length) {\n-\n-FoundMatch:\n-\n-            //\n-            // This slot is a prefix match.  Fill out the Match structure if the\n-            // caller provided a non-NULL pointer, then return the index of the\n-            // match.\n-            //\n-\n-\n-            if (ARGUMENT_PRESENT(Match)) {\n+        //\n+        // This slot is a prefix match.  Fill out the Match structure if the\n+        // caller provided a non-NULL pointer, then return the index of the\n+        // match.\n+        //\n\n-                Match-&gt;Index = (BYTE)Index;\n-                Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n-                Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n+        if (ARGUMENT_PRESENT(Match)) {\n\n-            }\n+            Match-&gt;Index = (BYTE)Index;\n+            Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n+            Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n-            return (STRING_TABLE_INDEX)Index;\n         }\n\n-        //\n-        // Not enough characters matched, so continue the loop.\n-        //\n+        return (STRING_TABLE_INDEX)Index;\n\n     } while (--Count);\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_10(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This version is based off version 8, but rewrites the inner loop that\n    checks for comparisons.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlotsByLength;\n    XMMWORD IncludeSlots;\n    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we invert the mask shortly after.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // Invert the result of the comparison; we want 0xff for slots to include\n    // and 0x0 for slots to ignore (it's currently the other way around).  We\n    // can achieve this by XOR'ing the result against our all-ones XMM register.\n    //\n\n    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n\n    //\n    // We're now ready to intersect the two XMM registers to determine which\n    // slots should still be included in the comparison (i.e. which slots have\n    // the exact same unique character as the string and a length less than or\n    // equal to the length of the search string).\n    //\n\n    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n                                 IncludeSlotsByLength);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    if (!Bitmap) {\n\n        //\n        // No bits were set, so there are no strings in this table starting\n        // with the same character and of a lesser or equal length as the\n        // search string.\n        //\n\n        return NO_MATCH_FOUND;\n    }\n\n    //\n    // Calculate the \"search length\" of the incoming string, which ensures we\n    // only compare up to the first 16 characters.\n    //\n\n    SearchLength = min(String-&gt;Length, 16);\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched &lt; Length && Length &lt;= 16) {\n\n            //\n            // The slot length is longer than the number of characters matched\n            // from the search string; this isn't a prefix match.  Continue.\n            //\n\n            continue;\n        }\n\n        if (Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n            }\n        }\n\n        //\n        // This slot is a prefix match.  Fill out the Match structure if the\n        // caller provided a non-NULL pointer, then return the index of the\n        // match.\n        //\n\n        if (ARGUMENT_PRESENT(Match)) {\n\n            Match-&gt;Index = (BYTE)Index;\n            Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n            Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n        }\n\n        return (STRING_TABLE_INDEX)Index;\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\nThat’s a nicer bit of logic—more C-like, less assembly-like, and arguably clearer. Let’s see how they compare. (This is an interesting one, as I genuinely don’t have a strong hunch about what kind of performance impact this will have; obviously, I thought the initial way of structuring the loop was optimal, and I had it in place for two years before deciding to embark on this article, which led to the rework we just saw. )\n\n\nBenchmark 10\n\n\n\nBenchmark 10\n\n\nHey, look at that! We’ve shaved off a few more cycles in most cases, especially for the negative matches!\n\n\n\nSpeeding Up Negative Matches with Assembly\n\n\n\n\n\n\nNote\n\n\n\n\nIf you build the Tracer project, you can run a helper batch file in the root directory called cdb-simple.bat, which uses cdb to launch one of the project’s executables, ModuleLoader.exe. This will start up, load all of our tracing project’s DLLs, then allow the debugger to break in, yielding a debugger prompt from which we can easily disassemble functions, inspect runtime function entries, etc. This is the approach I used for capturing the output over the next couple of sections.\n\n\n\nNow for the fun part! Let’s take a look at the disassembly of the initial part of version 10 responsible for the negative match logic and see if there are any improvements we can make.\n0:000&gt; uf StringTable2!IsPrefixOfStringInTable_10\nStringTable2!IsPrefixOfStringInTable_10:\n00007fff`f69c1df0 48896c2418      mov     qword ptr [rsp+18h],rbp\n00007fff`f69c1df5 4889742420      mov     qword ptr [rsp+20h],rsi\n00007fff`f69c1dfa 4155            push    r13\n00007fff`f69c1dfc 4156            push    r14\n00007fff`f69c1dfe 4157            push    r15\n00007fff`f69c1e00 4883ec20        sub     rsp,20h\n00007fff`f69c1e04 c5fa6f5920      vmovdqu xmm3,xmmword ptr [rcx+20h]\n00007fff`f69c1e09 4c8b6a08        mov     r13,qword ptr [rdx+8]\n00007fff`f69c1e0d 4d8bf0          mov     r14,r8\n00007fff`f69c1e10 440fb63a        movzx   r15d,byte ptr [rdx]\n00007fff`f69c1e14 33ed            xor     ebp,ebp\n00007fff`f69c1e16 44883c24        mov     byte ptr [rsp],r15b\n00007fff`f69c1e1a 488bf1          mov     rsi,rcx\n00007fff`f69c1e1d c4e279780c24    vpbroadcastb xmm1,byte ptr [rsp]\n00007fff`f69c1e23 c4c17a6f6500    vmovdqu xmm4,xmmword ptr [r13]\n00007fff`f69c1e29 c4e259004110    vpshufb xmm0,xmm4,xmmword ptr [rcx+10h]\n00007fff`f69c1e2f c5f97411        vpcmpeqb xmm2,xmm0,xmmword ptr [rcx]\n00007fff`f69c1e33 c5e164c9        vpcmpgtb xmm1,xmm3,xmm1\n00007fff`f69c1e37 c5f1ef0d41320000 vpxor   xmm1,xmm1,xmmword ptr [StringTable2!_xmmffffffffffffffffffffffffffffffff (00007fff`f69c5080)]\n00007fff`f69c1e3f c5e9dbd1        vpand   xmm2,xmm2,xmm1\n00007fff`f69c1e43 c579d7c2        vpmovmskb r8d,xmm2\n00007fff`f69c1e47 c5fa7f5c2410    vmovdqu xmmword ptr [rsp+10h],xmm3\n00007fff`f69c1e4d 4585c0          test    r8d,r8d\n00007fff`f69c1e50 0f849a000000    je      StringTable2!IsPrefixOfStringInTable_10+0x100 (00007fff`f69c1ef0)\nThere’s a bit of cruft at the start regarding setting up the function’s prologue (pushing non-volatile registers to the stack, etc. ). That’s to be expected for C (and C++, and basically every language); as the programmer, you don’t have any direct control over how many registers a compiler uses for a routine, how much stack space it uses, which registers it uses when, etc.\nHowever, with assembly, we’re on the opposite end of the spectrum: we can control everything! We also have a little trick up our sleeves: the venerable LEAF_ENTRY.\n\nWindows x64 ABI Calling Conventions\nFirst, some background. The Windows x64 ABI and calling convention dictate two types of functions: NESTED_ENTRY and LEAF_ENTRY.\n\nNESTED_ENTRY\nNESTED_ENTRY is by far the most common; C and C++ functions are all implicitly NESTED_ENTRY functions. (The LEAF_ENTRY and NESTED_ENTRY symbols are MASM (ml64.exe) macro names, but the concept applies to all languages.)\n\n\nLEAF_ENTRY\nA LEAF_ENTRY can only be implemented in assembly. It is constrained in that it may not manipulate any of the non-volatile x64 registers (rbx, rdi, rsi, rsp, rbp, r12, r13, r14, r15, xmm6-15), nor may it call any other functions (since call implicitly modifies the stack pointer), nor may it have a structured exception handler (since handling an exception for a given stack frame also manipulates the stack pointer).\nThe reason for these constraints is that LEAF_ENTRY routines do not have any unwind information generated for them in their runtime function entries. Unwind information is used by the kernel to, well, unwind the modifications made to non-volatile registers while traversing back up through the call stack looking for an exception handler in the event of an exception.\nFor example, here’s the function entry and associated unwind information for the PGO build of the IsPrefixOfStringInTable_10 function:\n0:000&gt; .fnent StringTable2!IsPrefixOfStringInTable_10\nDebugger function entry 000001d8`2ea03cf8 for:\n(00007fff`f8411df0)   StringTable2!IsPrefixOfStringInTable_10\nExact matches:\n    StringTable2!IsPrefixOfStringInTable_10 (struct _STRING_TABLE *,\n                                             struct _STRING *,\n                                             struct _STRING_MATCH *)\n\nBeginAddress      = 00000000`00001df0\nEndAddress        = 00000000`00001e59\nUnwindInfoAddress = 00000000`000054f8\n\nUnwind info at 00007fff`f84154f8, 14 bytes\n  version 1, flags 0, prolog 14, codes 8\n  00: offs 14, unwind op 4, op info 6   UWOP_SAVE_NONVOL FrameOffset: 58 reg: rsi.\n  02: offs 14, unwind op 4, op info 5   UWOP_SAVE_NONVOL FrameOffset: 50 reg: rbp.\n  04: offs 14, unwind op 2, op info 3   UWOP_ALLOC_SMALL.\n  05: offs 10, unwind op 0, op info f   UWOP_PUSH_NONVOL reg: r15.\n  06: offs e, unwind op 0, op info e    UWOP_PUSH_NONVOL reg: r14.\n  07: offs c, unwind op 0, op info d    UWOP_PUSH_NONVOL reg: r13.\nWe can see that this routine manipulates six non-volatile registers in total, including the stack pointer. The first instructions of the routine constitute the function’s prologue; in the disassembly, you can see that three of the rxx registers are pushed to the stack, followed by the allocation of 0x20 (32) bytes of stack space:\n0:000&gt; uf StringTable2!IsPrefixOfStringInTable_10\nStringTable2!IsPrefixOfStringInTable_10:\n00007fff`f69c1df0 48896c2418      mov     qword ptr [rsp+18h],rbp\n00007fff`f69c1df5 4889742420      mov     qword ptr [rsp+20h],rsi\n00007fff`f69c1dfa 4155            push    r13\n00007fff`f69c1dfc 4156            push    r14\n00007fff`f69c1dfe 4157            push    r15\n00007fff`f69c1e00 4883ec20        sub     rsp,20h\nIt also cheekily uses the home parameter space for stashing rbp and rsi instead of pushing them to the stack. That’s fair game, though—this is the PGO build, so I’d expect it to use some extra tricks to shave off a few cycles here and there. I’d do the same if I were writing assembly. (Side note: if you view the source of this page, there’s a commented-out section below that shows the runtime function entry for the release build of version 10; it uses nine registers instead of six and 40 bytes of stack space instead of 32. I wrote it before switching to using the PGO build for everything.)\nThe home parameter space is a 32-byte area that immediately follows the return address (i.e., the value of rsp when the function is entered); it is mandated by the x64 calling convention on Windows and is primarily intended to provide scratch space for a routine to home its parameter registers (i.e., the registers used for the first four arguments of a function: rcx, rdx, r8, and r9). This allows the four volatile registers to be repurposed within a routine while still providing a way to refer to the parameters if needed. That’s its intended use—however, it’s not strictly enforced, so you can essentially treat this area as a free 32-byte scratch space if you’re writing assembly.\n\n\n\n\n\n\nNote\n\n\n\nOn a semi-related note, I’d highly recommend reading A History of Modern 64-bit Computing if you have some spare time. It’s a fascinating insight into contemporary x64 conventions we often take for granted, drawing on numerous interviews with industry luminaries like Dave Cutler and Linus Torvalds. I found it incredibly useful for understanding the why behind concepts like home parameter space, structured exception handling, runtime function entries, and why you can’t write inline assembly for x64 with MSVC anymore—apparently, it provides a direct vector for disrupting the mechanisms relied upon by the kernel stack unwinding functionality. (At least, I think that’s the reason—can anyone from Microsoft confirm?))\n\n\n\n\n\n\n\n\nAssembly Implementations\n\nIsPrefixOfStringInTable_x64_1\nIsPrefixOfStringInTable_x64_2 →\nSo, knowing what we now know about the venerable little LEAF_ENTRY trick, let’s see if we can construct a simple routine in assembly that just deals with the negative match case.\n;++\n;\n; STRING_TABLE_INDEX\n; IsPrefixOfStringInTable_x64_*(\n;     _In_ PSTRING_TABLE StringTable,\n;     _In_ PSTRING String,\n;     _Out_opt_ PSTRING_MATCH Match\n;     )\n;\n; Routine Description:\n;\n;   Searches a string table to see if any strings \"prefix match\" the given\n;   search string.  That is, whether any string in the table \"starts with\n;   or is equal to\" the search string.\n;\n; Arguments:\n;\n;   StringTable - Supplies a pointer to a STRING_TABLE struct.\n;\n;   String - Supplies a pointer to a STRING struct that contains the string to\n;       search for.\n;\n;   Match - Optionally supplies a pointer to a variable that contains the\n;       address of a STRING_MATCH structure.  This will be populated with\n;       additional details about the match if a non-NULL pointer is supplied.\n;\n; Return Value:\n;\n;   Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n;\n;--\n\n        LEAF_ENTRY IsPrefixOfStringInTable_x64_1, _TEXT$00\n\n        ;IACA_VC_START\n\n;\n; Load the string buffer into xmm0, and the unique indexes from the string table\n; into xmm1.  Shuffle the buffer according to the unique indexes, and store the\n; result back into xmm0.\n;\n\n        mov     rax, String.Buffer[rdx]\n        vmovdqu xmm0, xmmword ptr [rax]                 ; Load search buffer.\n        vmovdqa xmm1, xmmword ptr StringTable.UniqueIndex[rcx] ; Load indexes.\n        vpshufb xmm0, xmm0, xmm1\n\n;\n; Load the string table's unique character array into xmm2, and the lengths for\n; each string slot into xmm3.\n;\n\n        vmovdqa xmm2, xmmword ptr StringTable.UniqueChars[rcx]  ; Load chars.\n        vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]      ; Load lengths.\n\n;\n; Set xmm5 to all ones.  This is used later.\n;\n\n        vpcmpeqq    xmm5, xmm5, xmm5                    ; Set xmm5 to all ones.\n\n;\n; Broadcast the byte-sized string length into xmm4.\n;\n\n        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.\n\n;\n; Compare the search string's unique character array (xmm0) against the string\n; table's unique chars (xmm2), saving the result back into xmm0.\n;\n\n        vpcmpeqb    xmm0, xmm0, xmm2            ; Compare unique chars.\n\n;\n; Compare the search string's length, which we've broadcasted to all 8-byte\n; elements of the xmm4 register, to the lengths of the slots in the string\n; table, to find those that are greater in length.  Invert the result, such\n; that we're left with a masked register where each 0xff element indicates\n; a slot with a length less than or equal to our search string's length.\n;\n\n        vpcmpgtb    xmm1, xmm4, xmm3            ; Identify long slots.\n        vpxor       xmm1, xmm1, xmm5            ; Invert the result.\n\n;\n; Intersect-via-test xmm0 and xmm1 to identify string slots of a suitable\n; length with a matching unique character.\n;\n\n        vptest      xmm0, xmm1                  ; Check for no match.\n        ;jnz        short @F                    ; There was a match.\n                                                ; (Not yet implemented.)\n\n;\n; No match, set rax to -1 and return.\n;\n\n        xor         eax, eax                    ;\n        not         al                          ; rax = -1\n        ret\n\n        ;IACA_VC_END\n\n        LEAF_END   IsPrefixOfStringInTable_x64_1, _TEXT$00\n\n; vim:set tw=80 ts=8 sw=4 sts=4 et syntax=masm fo=croql comments=\\:;           :\nNote how we don’t need to push anything to the stack since we didn’t manipulate any non-volatile registers. If an exception occurs within the body of our implementation (say we dereference a NULL pointer), the kernel knows it doesn’t have to undo any non-volatile register modifications (using offsets specified by the unwind information) because there isn’t any unwind information. It can simply advance to the frame before us (e. g. , rsp at the time of the fault, minus 8 bytes) as it continues its search for runtime function entries and associated unwind information. As you can see, the unwind info is effectively empty:\n0:000&gt; .fnent StringTable2!IsPrefixOfStringInTable_x64_1\nDebugger function entry 000001f9`048edf98 for:\nExact matches:\n    StringTable2!IsPrefixOfStringInTable_x64_1 (void)\n\nBeginAddress      = 00000000`00003290\nEndAddress        = 00000000`000032cb\nUnwindInfoAddress = 00000000`00004468\n\nUnwind info at 00007ffd`15594468, 4 bytes\n  version 1, flags 0, prolog 0, codes 0\n\n\nBenchmark x64 1\nLet’s see how this scrappy little fellow (who always returns NO_MATCH_FOUND but still mimics the steps required to successfully negative match) does against the leading C implementation at this point, version 10:\n\n\n\nBenchmark x64 1\n\n\nFwoah, look at that, we’ve shaved about three cycles off the C version!\n (Note that when I first wrote this, I was comparing the assembly version against the release build (not the PGO build), which was clocking in at about 13-14 cycles for negative matching. So getting it down to ~7.5 from 13-14 was a bit more exciting. Damn the PGO build and its 10.9-ish cycles for negative matching!) \nThe good news is that our theory about the performance of the LEAF_ENTRY looks like it’s paid off: we can reliably get about 7.5 cycles for negative matching.\n\n\nIsPrefixOfStringInTable_x64_2\n← IsPrefixOfStringInTable_x64_1 | IsPrefixOfStringInTable_x64_3 →\nThe bad news is that we now need to implement the rest of the functionality within the constraints of a LEAF_ENTRY!\nThe problem with a LEAF_ENTRY for anything more than a trivial bit of code is that you only have a handful of volatile registers to work with, and no stack space can be used for register spilling or temporaries. (Technically I could use the home parameter space, but, eh, we’re already avoiding stack spills, why not make life harder for ourselves and try to avoid all memory spilling.)\nIf you can’t spill to memory, your only option is really spilling to XMM registers via vpinsr and vpextr combinations, which, as you can see in the implementation of version 2 below, I have to do a lot.\n (Also note: when I wrote this version, I didn’t use the disassembly from the C routines for guidance. I find that as soon as you start to grok the disassembly for a given routine, it becomes harder to think of ways to approach it from a fresh angle. Also, the LEAF_ENTRY aspect significantly limited what I could do anyway, so I figured I may as well just give it a crack from scratch and see what I could come up with. It would be an interesting point of reference compared to a future iteration that tries to improve on the disassembly of an optimized PGO version, for example.) \nThe diff view for this routine is less useful given the vast majority of the code is new, so I’ve put the full version of the code first. It’s based more or less on the approach used by version 8 of the C routine (I actually wrote it after I wrote version 8; versions 9 and 10 of the C routine (with the latter having the improved loop logic) came after).\n\nFullDiff\n\n\n;++\n;\n; STRING_TABLE_INDEX\n; IsPrefixOfStringInTable_x64_*(\n;     _In_ PSTRING_TABLE StringTable,\n;     _In_ PSTRING String,\n;     _Out_opt_ PSTRING_MATCH Match\n;     )\n;\n; Routine Description:\n;\n;   Searches a string table to see if any strings \"prefix match\" the given\n;   search string.  That is, whether any string in the table \"starts with\n;   or is equal to\" the search string.\n;\n; Arguments:\n;\n;   StringTable - Supplies a pointer to a STRING_TABLE struct.\n;\n;   String - Supplies a pointer to a STRING struct that contains the string to\n;       search for.\n;\n;   Match - Optionally supplies a pointer to a variable that contains the\n;       address of a STRING_MATCH structure.  This will be populated with\n;       additional details about the match if a non-NULL pointer is supplied.\n;\n; Return Value:\n;\n;   Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n;\n;--\n\n        LEAF_ENTRY IsPrefixOfStringInTable_x64_2, _TEXT$00\n\n;\n; Load the string buffer into xmm0, and the unique indexes from the string table\n; into xmm1.  Shuffle the buffer according to the unique indexes, and store the\n; result into xmm5.\n;\n\n        ;IACA_VC_START\n\n        mov     rax, String.Buffer[rdx]\n        vmovdqu xmm0, xmmword ptr [rax]                 ; Load search buffer.\n        vmovdqa xmm1, xmmword ptr StringTable.UniqueIndex[rcx] ; Load indexes.\n        vpshufb xmm5, xmm0, xmm1\n\n;\n; Load the string table's unique character array into xmm2.\n\n        vmovdqa xmm2, xmmword ptr StringTable.UniqueChars[rcx]  ; Load chars.\n\n;\n; Compare the search string's unique character array (xmm5) against the string\n; table's unique chars (xmm2), saving the result back into xmm5.\n;\n\n        vpcmpeqb    xmm5, xmm5, xmm2            ; Compare unique chars.\n\n;\n; Load the lengths of each string table slot into xmm3.\n;\n        vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]      ; Load lengths.\n\n;\n; Set xmm2 to all ones.  We use this later to invert the length comparison.\n;\n\n        vpcmpeqq    xmm2, xmm2, xmm2            ; Set xmm2 to all ones.\n\n;\n; Broadcast the byte-sized string length into xmm4.\n;\n\n        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.\n\n;\n; Compare the search string's length, which we've broadcasted to all 8-byte\n; elements of the xmm4 register, to the lengths of the slots in the string\n; table, to find those that are greater in length.  Invert the result, such\n; that we're left with a masked register where each 0xff element indicates\n; a slot with a length less than or equal to our search string's length.\n;\n\n        vpcmpgtb    xmm1, xmm3, xmm4            ; Identify long slots.\n        vpxor       xmm1, xmm1, xmm2            ; Invert the result.\n\n;\n; Intersect-and-test the unique character match xmm mask register (xmm5) with\n; the length match mask xmm register (xmm1).  This affects flags, allowing us\n; to do a fast-path exit for the no-match case (where ZF = 1).\n;\n\n        vptest      xmm5, xmm1                  ; Check for no match.\n        jnz         short Pfx10                 ; There was a match.\n\n;\n; No match, set rax to -1 and return.\n;\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        ret                                     ; Return.\n\n        ;IACA_VC_END\n\n;\n; (There was at least one match, continue with processing.)\n;\n\n;\n; Calculate the \"search length\" for the incoming search string, which is\n; equivalent of 'min(String-&gt;Length, 16)'.  (The search string's length\n; currently lives in xmm4, albeit as a byte-value broadcasted across the\n; entire register, so extract that first.)\n;\n; Once the search length is calculated, deposit it back at the second byte\n; location of xmm4.\n;\n;   r10 and xmm4[15:8] - Search length (min(String-&gt;Length, 16))\n;\n;   r11 - String length (String-&gt;Length)\n;\n\nPfx10:  vpextrb     r11, xmm4, 0                ; Load length.\n        mov         rax, 16                     ; Load 16 into rax.\n        mov         r10, r11                    ; Copy into r10.\n        cmp         r10w, ax                    ; Compare against 16.\n        cmova       r10w, ax                    ; Use 16 if length is greater.\n        vpinsrb     xmm4, xmm4, r10d, 1         ; Save back to xmm4b[1].\n\n;\n; Home our parameter registers into xmm registers instead of their stack-backed\n; location, to avoid memory writes.\n;\n\n        vpxor       xmm2, xmm2, xmm2            ; Clear xmm2.\n        vpinsrq     xmm2, xmm2, rcx, 0          ; Save rcx into xmm2q[0].\n        vpinsrq     xmm2, xmm2, rdx, 1          ; Save rdx into xmm2q[1].\n\n;\n; Intersect xmm5 and xmm1 (as we did earlier with the 'vptest xmm5, xmm1'),\n; yielding a mask identifying indices we need to perform subsequent matches\n; upon.  Convert this into a bitmap and save in xmm2d[2].\n;\n\n        vpand       xmm5, xmm5, xmm1            ; Intersect unique + lengths.\n        vpmovmskb   edx, xmm5                   ; Generate a bitmap from mask.\n\n;\n; We're finished with xmm5; repurpose it in the same vein as xmm2 above.\n;\n\n        vpxor       xmm5, xmm5, xmm5            ; Clear xmm5.\n        vpinsrq     xmm5, xmm5, r8, 0           ; Save r8 into xmm5q[0].\n\n;\n; Summary of xmm register stashing for the rest of the routine:\n;\n; xmm2:\n;        0:63   (vpinsrq 0)     rcx (1st function parameter, StringTable)\n;       64:127  (vpinsrq 1)     rdx (2nd function paramter, String)\n;\n; xmm4:\n;       0:7     (vpinsrb 0)     length of search string\n;       8:15    (vpinsrb 1)     min(String-&gt;Length, 16)\n;      16:23    (vpinsrb 2)     loop counter (when doing long string compares)\n;      24:31    (vpinsrb 3)     shift count\n;\n; xmm5:\n;       0:63    (vpinsrq 0)     r8 (3rd function parameter, StringMatch)\n;      64:95    (vpinsrd 2)     bitmap of slots to compare\n;      96:127   (vpinsrd 3)     index of slot currently being processed\n;\n\n;\n; Initialize rcx as our counter register by doing a popcnt against the bitmap\n; we just generated in edx, and clear our shift count register (r9).\n;\n\n        popcnt      ecx, edx                    ; Count bits in bitmap.\n        xor         r9, r9                      ; Clear r9.\n\n        align 16\n\n;\n; Top of the main comparison loop.  The bitmap will be present in rdx.  Count\n; trailing zeros of the bitmap, and then add in the shift count, producing an\n; index (rax) we can use to load the corresponding slot.\n;\n; Register usage at top of loop:\n;\n;   rax - Index.\n;\n;   rcx - Loop counter.\n;\n;   rdx - Bitmap initially, then slot length.\n;\n;   r9 - Shift count.\n;\n;   r10 - Search length.\n;\n;   r11 - String length.\n;\n\nPfx20:  tzcnt       r8d, edx                    ; Count trailing zeros.\n        mov         eax, r8d                    ; Copy tzcnt to rax,\n        add         rax, r9                     ; Add shift to create index.\n        inc         r8                          ; tzcnt + 1\n        shrx        rdx, rdx, r8                ; Reposition bitmap.\n        vpinsrd     xmm5, xmm5, edx, 2          ; Store bitmap, free up rdx.\n        xor         edx, edx                    ; Clear edx.\n        mov         r9, rax                     ; Copy index back to shift.\n        inc         r9                          ; Shift = Index + 1\n        vpinsrd     xmm5, xmm5, eax, 3          ; Store the raw index xmm5d[3].\n\n;\n; \"Scale\" the index (such that we can use it in a subsequent vmovdqa) by\n; shifting left by 4 (i.e. multiply by '(sizeof STRING_SLOT)', which is 16).\n;\n; Then, load the string table slot at this index into xmm1, then shift rax back.\n;\n\n        shl         eax, 4\n        vpextrq     r8, xmm2, 0\n        vmovdqa     xmm1, xmmword ptr [rax + StringTable.Slots[r8]]\n        shr         eax, 4\n\n;\n; The search string's first 16 characters are already in xmm0.  Compare this\n; against the slot that has just been loaded into xmm1, storing the result back\n; into xmm1.\n;\n\n        vpcmpeqb    xmm1, xmm1, xmm0            ; Compare search string to slot.\n\n;\n; Convert the XMM mask into a 32-bit representation, then zero high bits after\n; our \"search length\", which allows us to ignore the results of the comparison\n; above for bytes that were after the search string's length, if applicable.\n; Then, count the number of bits remaining, which tells us how many characters\n; we matched.\n;\n\n        vpmovmskb   r8d, xmm1                   ; Convert into mask.\n        bzhi        r8d, r8d, r10d              ; Zero high bits.\n        popcnt      r8d, r8d                    ; Count bits.\n\n;\n; Load the slot length into rdx.  As xmm3 already has all the slot lengths in\n; it, we can load rax (the current index) into xmm1 and use it to extract the\n; slot length via shuffle.  (The length will be in the lowest byte of xmm1\n; after the shuffle, which we can then vpextrb.)\n;\n\n        movd        xmm1, rax                   ; Load index into xmm1.\n        vpshufb     xmm1, xmm3, xmm1            ; Shuffle lengths.\n        vpextrb     rdx, xmm1, 0                ; Extract target length to rdx.\n\n;\n; If 16 characters matched, and the search string's length is longer than 16,\n; we're going to need to do a comparison of the remaining strings.\n;\n\n        cmp         r8w, 16                     ; Compare chars matched to 16.\n        je          short @F                    ; 16 chars matched.\n        jmp         Pfx30                       ; Less than 16 matched.\n\n;\n; All 16 characters matched.  If the slot length is greater than 16, we need\n; to do an inline memory comparison of the remaining bytes.  If it's 16 exactly,\n; then great, that's a slot match, we're done.\n;\n\n@@:     cmp         dl, 16                      ; Compare length to 16.\n        ja          Pfx50                       ; Length is &gt; 16.\n        je          short Pfx35                 ; Lengths match!\n                                                ; Length &lt;= 16, fall through...\n\n;\n; Less than or equal to 16 characters were matched.  Compare this against the\n; length of the slot; if equal, this is a match, if not, no match, continue.\n;\n\nPfx30:  cmp         r8b, dl                     ; Compare against slot length.\n        jne         @F                          ; No match found.\n        jmp         short Pfx35                 ; Match found!\n\n;\n; No match against this slot, decrement counter and either continue the loop\n; or terminate the search and return no match.\n;\n\n@@:     vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.\n        dec         cx                          ; Decrement counter.\n        jnz         Pfx20                       ; cx != 0, continue.\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        ret                                     ; Return.\n\n;\n; Pfx35 and Pfx40 are the jump targets for when the prefix match succeeds.  The\n; former is used when we need to copy the number of characters matched from r8\n; back to rax.  The latter jump target doesn't require this.\n;\n\nPfx35:  mov         rax, r8                     ; Copy numbers of chars matched.\n\n;\n; Load the match parameter back into r8 and test to see if it's not-NULL, in\n; which case we need to fill out a STRING_MATCH structure for the match.\n;\n\nPfx40:  vpextrq     r8, xmm5, 0                 ; Extract StringMatch.\n        test        r8, r8                      ; Is NULL?\n        jnz         short @F                    ; Not zero, need to fill out.\n\n;\n; StringMatch is NULL, we're done. Extract index of match back into rax and ret.\n;\n\n        vpextrd     eax, xmm5, 3                ; Extract raw index for match.\n        ret                                     ; StringMatch == NULL, finish.\n\n;\n; StringMatch is not NULL.  Fill out characters matched (currently rax), then\n; reload the index from xmm5 into rax and save.\n;\n\n@@:     mov         byte ptr StringMatch.NumberOfMatchedCharacters[r8], al\n        vpextrd     eax, xmm5, 3                ; Extract raw index for match.\n        mov         byte ptr StringMatch.Index[r8], al\n\n;\n; Final step, loading the address of the string in the string array.  This\n; involves going through the StringTable, so we need to load that parameter\n; back into rcx, then resolving the string array address via pStringArray,\n; then the relevant STRING offset within the StringArray.Strings structure.\n;\n\n        vpextrq     rcx, xmm2, 0            ; Extract StringTable into rcx.\n        mov         rcx, StringTable.pStringArray[rcx] ; Load string array.\n\n        shl         eax, 4                  ; Scale the index; sizeof STRING=16.\n        lea         rdx, [rax + StringArray.Strings[rcx]] ; Resolve address.\n        mov         qword ptr StringMatch.String[r8], rdx ; Save STRING ptr.\n        shr         eax, 4                  ; Revert the scaling.\n\n        ret\n\n;\n; 16 characters matched and the length of the underlying slot is greater than\n; 16, so we need to do a little memory comparison to determine if the search\n; string is a prefix match.\n;\n; The slot length is stored in rax at this point, and the search string's\n; length is stored in r11.  We know that the search string's length will\n; always be longer than or equal to the slot length at this point, so, we\n; can subtract 16 (currently stored in r10) from rax, and use the resulting\n; value as a loop counter, comparing the search string with the underlying\n; string slot byte-by-byte to determine if there's a match.\n;\n\nPfx50:  sub         rdx, r10                ; Subtract 16 from search length.\n\n;\n; Free up some registers by stashing their values into various xmm offsets.\n;\n\n        vpinsrb     xmm4, xmm4, ecx, 2      ; Free up rcx register.\n        mov         rcx, rdx                ; Free up rdx, rcx is now counter.\n\n;\n; Load the search string buffer and advance it 16 bytes.\n;\n\n        vpextrq     r11, xmm2, 1            ; Extract String into r11.\n        mov         r11, String.Buffer[r11] ; Load buffer address.\n        add         r11, r10                ; Advance buffer 16 bytes.\n\n;\n; Loading the slot is more involved as we have to go to the string table, then\n; the pStringArray pointer, then the relevant STRING offset within the string\n; array (which requires re-loading the index from xmm5d[3]), then the string\n; buffer from that structure.\n;\n\n        vpextrq     r8, xmm2, 0             ; Extract StringTable into r8.\n        mov         r8, StringTable.pStringArray[r8] ; Load string array.\n\n        shl         eax, 4                  ; Scale the index; sizeof STRING=16.\n\n        lea         r8, [rax + StringArray.Strings[r8]] ; Resolve address.\n        mov         r8, String.Buffer[r8]   ; Load string table buffer address.\n        add         r8, r10                 ; Advance buffer 16 bytes.\n\n        xor         eax, eax                ; Clear eax.\n\n;\n; We've got both buffer addresses + 16 bytes loaded in r11 and r8 respectively.\n; Do a byte-by-byte comparison.\n;\n\n        align 16\n@@:     mov         dl, byte ptr [rax + r11]    ; Load byte from search string.\n        cmp         dl, byte ptr [rax + r8]     ; Compare against target.\n        jne         short Pfx60                 ; If not equal, jump.\n\n;\n; The two bytes were equal, update rax, decrement rcx and potentially continue\n; the loop.\n;\n\n        inc         ax                          ; Increment index.\n        loopnz      @B                          ; Decrement cx and loop back.\n\n;\n; All bytes matched!  Add 16 (still in r10) back to rax such that it captures\n; how many characters we matched, and then jump to Pfx40 for finalization.\n;\n\n        add         rax, r10\n        jmp         Pfx40\n\n;\n; Byte comparisons were not equal.  Restore the rcx loop counter and decrement\n; it.  If it's zero, we have no more strings to compare, so we can do a quick\n; exit.  If there are still comparisons to be made, restore the other registers\n; we trampled then jump back to the start of the loop Pfx20.\n;\n\nPfx60:  vpextrb     rcx, xmm4, 2                ; Restore rcx counter.\n        dec         cx                          ; Decrement counter.\n        jnz         short @F                    ; Jump forward if not zero.\n\n;\n; No more comparisons remaining, return.\n;\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        ret                                     ; Return.\n\n;\n; More comparisons remain; restore the registers we clobbered and continue loop.\n;\n\n@@:     vpextrb     r10, xmm4, 1                ; Restore r10.\n        vpextrb     r11, xmm4, 0                ; Restore r11.\n        vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.\n        jmp         Pfx20                       ; Continue comparisons.\n\n        ;IACA_VC_END\n\n        LEAF_END   IsPrefixOfStringInTable_x64_2, _TEXT$00\n\n; vim:set tw=80 ts=8 sw=4 sts=4 et syntax=masm fo=croql comments=\\:;           :\n\n\n% diff -u IsPrefixOfStringInTable_x64_1.asm IsPrefixOfStringInTable_x64_2.asm\n--- IsPrefixOfStringInTable_x64_1.asm   2018-04-29 11:03:46.403568800 -0400\n+++ IsPrefixOfStringInTable_x64_2.asm   2018-04-26 14:15:53.805409700 -0400\n@@ -50,12 +50,12 @@\n ;\n ;--\n\n-        LEAF_ENTRY IsPrefixOfStringInTable_x64_1, _TEXT$00\n+        LEAF_ENTRY IsPrefixOfStringInTable_x64_2, _TEXT$00\n\n ;\n ; Load the string buffer into xmm0, and the unique indexes from the string table\n ; into xmm1.  Shuffle the buffer according to the unique indexes, and store the\n-; result back into xmm0.\n+; result into xmm5.\n ;\n\n         ;IACA_VC_START\n@@ -63,34 +63,36 @@\n         mov     rax, String.Buffer[rdx]\n         vmovdqu xmm0, xmmword ptr [rax]                 ; Load search buffer.\n         vmovdqa xmm1, xmmword ptr StringTable.UniqueIndex[rcx] ; Load indexes.\n-        vpshufb xmm0, xmm0, xmm1\n+        vpshufb xmm5, xmm0, xmm1\n\n ;\n-; Load the string table's unique character array into xmm2, and the lengths for\n-; each string slot into xmm3.\n-;\n+; Load the string table's unique character array into xmm2.\n\n         vmovdqa xmm2, xmmword ptr StringTable.UniqueChars[rcx]  ; Load chars.\n-        vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]      ; Load lengths.\n\n ;\n-; Set xmm5 to all ones.  This is used later.\n+; Compare the search string's unique character array (xmm5) against the string\n+; table's unique chars (xmm2), saving the result back into xmm5.\n ;\n\n-        vpcmpeqq    xmm5, xmm5, xmm5                    ; Set xmm5 to all ones.\n+        vpcmpeqb    xmm5, xmm5, xmm2            ; Compare unique chars.\n\n ;\n-; Broadcast the byte-sized string length into xmm4.\n+; Load the lengths of each string table slot into xmm3.\n ;\n+        vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]      ; Load lengths.\n\n-        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.\n+;\n+; Set xmm2 to all ones.  We use this later to invert the length comparison.\n+;\n+\n+        vpcmpeqq    xmm2, xmm2, xmm2            ; Set xmm2 to all ones.\n\n ;\n-; Compare the search string's unique character array (xmm0) against the string\n-; table's unique chars (xmm2), saving the result back into xmm0.\n+; Broadcast the byte-sized string length into xmm4.\n ;\n\n-        vpcmpeqb    xmm0, xmm0, xmm2            ; Compare unique chars.\n+        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.\n\n ;\n ; Compare the search string's length, which we've broadcasted to all 8-byte\n@@ -100,30 +102,378 @@\n ; a slot with a length less than or equal to our search string's length.\n ;\n\n-        vpcmpgtb    xmm1, xmm4, xmm3            ; Identify long slots.\n-        vpxor       xmm1, xmm1, xmm5            ; Invert the result.\n+        vpcmpgtb    xmm1, xmm3, xmm4            ; Identify long slots.\n+        vpxor       xmm1, xmm1, xmm2            ; Invert the result.\n\n ;\n-; Intersect-and-test the unique character match xmm mask register (xmm0) with\n+; Intersect-and-test the unique character match xmm mask register (xmm5) with\n ; the length match mask xmm register (xmm1).  This affects flags, allowing us\n ; to do a fast-path exit for the no-match case (where ZF = 1).\n ;\n\n-        vptest      xmm0, xmm1                  ; Check for no match.\n-        ;jnz        short @F                    ; There was a match.\n-                                                ; (Not yet implemented.)\n+        vptest      xmm5, xmm1                  ; Check for no match.\n+        jnz         short Pfx10                 ; There was a match.\n\n ;\n ; No match, set rax to -1 and return.\n ;\n\n-        xor         eax, eax                    ;\n-        not         al                          ; rax = -1\n+        xor         eax, eax                    ; Clear rax.\n+        not         al                          ; al = -1\n+        ret                                     ; Return.\n+\n+        ;IACA_VC_END\n+\n+;\n+; (There was at least one match, continue with processing.)\n+;\n+\n+;\n+; Calculate the \"search length\" for the incoming search string, which is\n+; equivalent of 'min(String-&gt;Length, 16)'.  (The search string's length\n+; currently lives in xmm4, albeit as a byte-value broadcasted across the\n+; entire register, so extract that first.)\n+;\n+; Once the search length is calculated, deposit it back at the second byte\n+; location of xmm4.\n+;\n+;   r10 and xmm4[15:8] - Search length (min(String-&gt;Length, 16))\n+;\n+;   r11 - String length (String-&gt;Length)\n+;\n+\n+Pfx10:  vpextrb     r11, xmm4, 0                ; Load length.\n+        mov         rax, 16                     ; Load 16 into rax.\n+        mov         r10, r11                    ; Copy into r10.\n+        cmp         r10w, ax                    ; Compare against 16.\n+        cmova       r10w, ax                    ; Use 16 if length is greater.\n+        vpinsrb     xmm4, xmm4, r10d, 1         ; Save back to xmm4b[1].\n+\n+;\n+; Home our parameter registers into xmm registers instead of their stack-backed\n+; location, to avoid memory writes.\n+;\n+\n+        vpxor       xmm2, xmm2, xmm2            ; Clear xmm2.\n+        vpinsrq     xmm2, xmm2, rcx, 0          ; Save rcx into xmm2q[0].\n+        vpinsrq     xmm2, xmm2, rdx, 1          ; Save rdx into xmm2q[1].\n+\n+;\n+; Intersect xmm5 and xmm1 (as we did earlier with the 'vptest xmm5, xmm1'),\n+; yielding a mask identifying indices we need to perform subsequent matches\n+; upon.  Convert this into a bitmap and save in xmm2d[2].\n+;\n+\n+        vpand       xmm5, xmm5, xmm1            ; Intersect unique + lengths.\n+        vpmovmskb   edx, xmm5                   ; Generate a bitmap from mask.\n+\n+;\n+; We're finished with xmm5; repurpose it in the same vein as xmm2 above.\n+;\n+\n+        vpxor       xmm5, xmm5, xmm5            ; Clear xmm5.\n+        vpinsrq     xmm5, xmm5, r8, 0           ; Save r8 into xmm5q[0].\n+\n+;\n+; Summary of xmm register stashing for the rest of the routine:\n+;\n+; xmm2:\n+;        0:63   (vpinsrq 0)     rcx (1st function parameter, StringTable)\n+;       64:127  (vpinsrq 1)     rdx (2nd function paramter, String)\n+;\n+; xmm4:\n+;       0:7     (vpinsrb 0)     length of search string\n+;       8:15    (vpinsrb 1)     min(String-&gt;Length, 16)\n+;      16:23    (vpinsrb 2)     loop counter (when doing long string compares)\n+;      24:31    (vpinsrb 3)     shift count\n+;\n+; xmm5:\n+;       0:63    (vpinsrq 0)     r8 (3rd function parameter, StringMatch)\n+;      64:95    (vpinsrd 2)     bitmap of slots to compare\n+;      96:127   (vpinsrd 3)     index of slot currently being processed\n+;\n+\n+;\n+; Initialize rcx as our counter register by doing a popcnt against the bitmap\n+; we just generated in edx, and clear our shift count register (r9).\n+;\n+\n+        popcnt      ecx, edx                    ; Count bits in bitmap.\n+        xor         r9, r9                      ; Clear r9.\n+\n+        align 16\n+\n+;\n+; Top of the main comparison loop.  The bitmap will be present in rdx.  Count\n+; trailing zeros of the bitmap, and then add in the shift count, producing an\n+; index (rax) we can use to load the corresponding slot.\n+;\n+; Register usage at top of loop:\n+;\n+;   rax - Index.\n+;\n+;   rcx - Loop counter.\n+;\n+;   rdx - Bitmap initially, then slot length.\n+;\n+;   r9 - Shift count.\n+;\n+;   r10 - Search length.\n+;\n+;   r11 - String length.\n+;\n+\n+Pfx20:  tzcnt       r8d, edx                    ; Count trailing zeros.\n+        mov         eax, r8d                    ; Copy tzcnt to rax,\n+        add         rax, r9                     ; Add shift to create index.\n+        inc         r8                          ; tzcnt + 1\n+        shrx        rdx, rdx, r8                ; Reposition bitmap.\n+        vpinsrd     xmm5, xmm5, edx, 2          ; Store bitmap, free up rdx.\n+        xor         edx, edx                    ; Clear edx.\n+        mov         r9, rax                     ; Copy index back to shift.\n+        inc         r9                          ; Shift = Index + 1\n+        vpinsrd     xmm5, xmm5, eax, 3          ; Store the raw index xmm5d[3].\n+\n+;\n+; \"Scale\" the index (such that we can use it in a subsequent vmovdqa) by\n+; shifting left by 4 (i.e. multiply by '(sizeof STRING_SLOT)', which is 16).\n+;\n+; Then, load the string table slot at this index into xmm1, then shift rax back.\n+;\n+\n+        shl         eax, 4\n+        vpextrq     r8, xmm2, 0\n+        vmovdqa     xmm1, xmmword ptr [rax + StringTable.Slots[r8]]\n+        shr         eax, 4\n+\n+;\n+; The search string's first 16 characters are already in xmm0.  Compare this\n+; against the slot that has just been loaded into xmm1, storing the result back\n+; into xmm1.\n+;\n+\n+        vpcmpeqb    xmm1, xmm1, xmm0            ; Compare search string to slot.\n+\n+;\n+; Convert the XMM mask into a 32-bit representation, then zero high bits after\n+; our \"search length\", which allows us to ignore the results of the comparison\n+; above for bytes that were after the search string's length, if applicable.\n+; Then, count the number of bits remaining, which tells us how many characters\n+; we matched.\n+;\n+\n+        vpmovmskb   r8d, xmm1                   ; Convert into mask.\n+        bzhi        r8d, r8d, r10d              ; Zero high bits.\n+        popcnt      r8d, r8d                    ; Count bits.\n+\n+;\n+; Load the slot length into rdx.  As xmm3 already has all the slot lengths in\n+; it, we can load rax (the current index) into xmm1 and use it to extract the\n+; slot length via shuffle.  (The length will be in the lowest byte of xmm1\n+; after the shuffle, which we can then vpextrb.)\n+;\n+\n+        movd        xmm1, rax                   ; Load index into xmm1.\n+        vpshufb     xmm1, xmm3, xmm1            ; Shuffle lengths.\n+        vpextrb     rdx, xmm1, 0                ; Extract target length to rdx.\n+\n+;\n+; If 16 characters matched, and the search string's length is longer than 16,\n+; we're going to need to do a comparison of the remaining strings.\n+;\n+\n+        cmp         r8w, 16                     ; Compare chars matched to 16.\n+        je          short @F                    ; 16 chars matched.\n+        jmp         Pfx30                       ; Less than 16 matched.\n+\n+;\n+; All 16 characters matched.  If the slot length is greater than 16, we need\n+; to do an inline memory comparison of the remaining bytes.  If it's 16 exactly,\n+; then great, that's a slot match, we're done.\n+;\n+\n+@@:     cmp         dl, 16                      ; Compare length to 16.\n+        ja          Pfx50                       ; Length is &gt; 16.\n+        je          short Pfx35                 ; Lengths match!\n+                                                ; Length &lt;= 16, fall through...\n+\n+;\n+; Less than or equal to 16 characters were matched.  Compare this against the\n+; length of the slot; if equal, this is a match, if not, no match, continue.\n+;\n+\n+Pfx30:  cmp         r8b, dl                     ; Compare against slot length.\n+        jne         @F                          ; No match found.\n+        jmp         short Pfx35                 ; Match found!\n+\n+;\n+; No match against this slot, decrement counter and either continue the loop\n+; or terminate the search and return no match.\n+;\n+\n+@@:     vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.\n+        dec         cx                          ; Decrement counter.\n+        jnz         Pfx20                       ; cx != 0, continue.\n+\n+        xor         eax, eax                    ; Clear rax.\n+        not         al                          ; al = -1\n+        ret                                     ; Return.\n+\n+;\n+; Pfx35 and Pfx40 are the jump targets for when the prefix match succeeds.  The\n+; former is used when we need to copy the number of characters matched from r8\n+; back to rax.  The latter jump target doesn't require this.\n+;\n+\n+Pfx35:  mov         rax, r8                     ; Copy numbers of chars matched.\n+\n+;\n+; Load the match parameter back into r8 and test to see if it's not-NULL, in\n+; which case we need to fill out a STRING_MATCH structure for the match.\n+;\n+\n+Pfx40:  vpextrq     r8, xmm5, 0                 ; Extract StringMatch.\n+        test        r8, r8                      ; Is NULL?\n+        jnz         short @F                    ; Not zero, need to fill out.\n+\n+;\n+; StringMatch is NULL, we're done. Extract index of match back into rax and ret.\n+;\n+\n+        vpextrd     eax, xmm5, 3                ; Extract raw index for match.\n+        ret                                     ; StringMatch == NULL, finish.\n+\n+;\n+; StringMatch is not NULL.  Fill out characters matched (currently rax), then\n+; reload the index from xmm5 into rax and save.\n+;\n+\n+@@:     mov         byte ptr StringMatch.NumberOfMatchedCharacters[r8], al\n+        vpextrd     eax, xmm5, 3                ; Extract raw index for match.\n+        mov         byte ptr StringMatch.Index[r8], al\n+\n+;\n+; Final step, loading the address of the string in the string array.  This\n+; involves going through the StringTable, so we need to load that parameter\n+; back into rcx, then resolving the string array address via pStringArray,\n+; then the relevant STRING offset within the StringArray.Strings structure.\n+;\n+\n+        vpextrq     rcx, xmm2, 0            ; Extract StringTable into rcx.\n+        mov         rcx, StringTable.pStringArray[rcx] ; Load string array.\n+\n+        shl         eax, 4                  ; Scale the index; sizeof STRING=16.\n+        lea         rdx, [rax + StringArray.Strings[rcx]] ; Resolve address.\n+        mov         qword ptr StringMatch.String[r8], rdx ; Save STRING ptr.\n+        shr         eax, 4                  ; Revert the scaling.\n+\n         ret\n\n+;\n+; 16 characters matched and the length of the underlying slot is greater than\n+; 16, so we need to do a little memory comparison to determine if the search\n+; string is a prefix match.\n+;\n+; The slot length is stored in rax at this point, and the search string's\n+; length is stored in r11.  We know that the search string's length will\n+; always be longer than or equal to the slot length at this point, so, we\n+; can subtract 16 (currently stored in r10) from rax, and use the resulting\n+; value as a loop counter, comparing the search string with the underlying\n+; string slot byte-by-byte to determine if there's a match.\n+;\n+\n+Pfx50:  sub         rdx, r10                ; Subtract 16 from search length.\n+\n+;\n+; Free up some registers by stashing their values into various xmm offsets.\n+;\n+\n+        vpinsrb     xmm4, xmm4, ecx, 2      ; Free up rcx register.\n+        mov         rcx, rdx                ; Free up rdx, rcx is now counter.\n+\n+;\n+; Load the search string buffer and advance it 16 bytes.\n+;\n+\n+        vpextrq     r11, xmm2, 1            ; Extract String into r11.\n+        mov         r11, String.Buffer[r11] ; Load buffer address.\n+        add         r11, r10                ; Advance buffer 16 bytes.\n+\n+;\n+; Loading the slot is more involved as we have to go to the string table, then\n+; the pStringArray pointer, then the relevant STRING offset within the string\n+; array (which requires re-loading the index from xmm5d[3]), then the string\n+; buffer from that structure.\n+;\n+\n+        vpextrq     r8, xmm2, 0             ; Extract StringTable into r8.\n+        mov         r8, StringTable.pStringArray[r8] ; Load string array.\n+\n+        shl         eax, 4                  ; Scale the index; sizeof STRING=16.\n+\n+        lea         r8, [rax + StringArray.Strings[r8]] ; Resolve address.\n+        mov         r8, String.Buffer[r8]   ; Load string table buffer address.\n+        add         r8, r10                 ; Advance buffer 16 bytes.\n+\n+        xor         eax, eax                ; Clear eax.\n+\n+;\n+; We've got both buffer addresses + 16 bytes loaded in r11 and r8 respectively.\n+; Do a byte-by-byte comparison.\n+;\n+\n+        align 16\n+@@:     mov         dl, byte ptr [rax + r11]    ; Load byte from search string.\n+        cmp         dl, byte ptr [rax + r8]     ; Compare against target.\n+        jne         short Pfx60                 ; If not equal, jump.\n+\n+;\n+; The two bytes were equal, update rax, decrement rcx and potentially continue\n+; the loop.\n+;\n+\n+        inc         ax                          ; Increment index.\n+        loopnz      @B                          ; Decrement cx and loop back.\n+\n+;\n+; All bytes matched!  Add 16 (still in r10) back to rax such that it captures\n+; how many characters we matched, and then jump to Pfx40 for finalization.\n+;\n+\n+        add         rax, r10\n+        jmp         Pfx40\n+\n+;\n+; Byte comparisons were not equal.  Restore the rcx loop counter and decrement\n+; it.  If it's zero, we have no more strings to compare, so we can do a quick\n+; exit.  If there are still comparisons to be made, restore the other registers\n+; we trampled then jump back to the start of the loop Pfx20.\n+;\n+\n+Pfx60:  vpextrb     rcx, xmm4, 2                ; Restore rcx counter.\n+        dec         cx                          ; Decrement counter.\n+        jnz         short @F                    ; Jump forward if not zero.\n+\n+;\n+; No more comparisons remaining, return.\n+;\n+\n+        xor         eax, eax                    ; Clear rax.\n+        not         al                          ; al = -1\n+        ret                                     ; Return.\n+\n+;\n+; More comparisons remain; restore the registers we clobbered and continue loop.\n+;\n+\n+@@:     vpextrb     r10, xmm4, 1                ; Restore r10.\n+        vpextrb     r11, xmm4, 0                ; Restore r11.\n+        vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.\n+        jmp         Pfx20                       ; Continue comparisons.\n+\n         ;IACA_VC_END\n\n-        LEAF_END   IsPrefixOfStringInTable_x64_1, _TEXT$00\n+        LEAF_END   IsPrefixOfStringInTable_x64_2, _TEXT$00\n\n ; vim:set tw=80 ts=8 sw=4 sts=4 et syntax=masm fo=croql comments=\\:;           :\n\n\n\nLooking back on my time logs (shout out to my favorite iPhone app, HoursTracker!), the routine above took about 8 hours to implement over the course of about two days, give or take. Writing assembly is slow; writing correct assembly is even slower. I generally find that there’s a noticeable hump I need to get over in the first, say, 30 minutes of any assembly programming session, but once you get into the zone, things can start flowing quite nicely. I’m an aggressive debugger user; often, to get started, I’ll write a simple LEAF_ENTRY that looks like this:\n    LEAF_ENTRY Foo, _TEXT$00\n        int 3\n        xor eax, eax\n        ret\n    LEAF_END Foo, _TEXT$00\nThat’ll allow me to attach the debugger and at least inspect the parameter registers so I can write the next couple of instructions. I find it definitely helps get me into the zone quicker.\nAnyway, enough about that. Let’s look at performance. Again, this will be an interesting one—other than the optimal negative match logic that I copied from version 1, the sole focus was on getting a working assembly version; I wasn’t giving any thought to performance at this stage.\nSo, it’ll be interesting to see how it compares to a) version 1 in the negative matching case (it should be very close), and b) against the C versions in the prefix matching case (it hopefully won’t be prohibitively worse).\n\n\nBenchmark x64 2: Negative Matching\n\n\n\nBenchmark Negative Match\n\n\nHmmm, that’s not too bad! We’re very close to version 1 for negative matching, within about 0.5 cycles or so. That sounds about right, given that our initial logic had to be tweaked a bit to play nicer with the rest of the implementation. And we’re still about 3-4 cycles faster than the fastest C version.\nWhat about prefix matching performance?\n\n\nBenchmark x64 2: Prefix Matching\n\n\n\nBenchmark Prefix Match\n\n\nThe prefix matching performance isn’t too bad either! We’re definitely slower than the C version, ranging from about 4 cycles to 10 cycles in most cases, with the $INDEX_ALLOCATION input about 13 cycles slower.\n  (I’ve just noticed the pattern with regards to the first 8 entries, $AttrDef to $Mft, clocking in at about 18 and 24 cycles respectively. But the next four entries, $Secure to $Cairo, consistently clock in at about 24 and 34 cycles respectively. $Secure is the 9th slot, which puts it at memory offset 192 bytes from the start of the string table. And then the 18 and 24 cycle behavior returns for the last two items, ???? and ., which are at the end of the string table’s inner slot array. This pattern is prevalent in all of our iterations. Very peculiar! We’ll investigate later.) \n\n\nIsPrefixOfStringInTable_x64_3\n← IsPrefixOfStringInTable_x64_2 | IsPrefixOfStringInTable_x64_4 →\n(We’re nearly at the end of the first round of iterations, I promise!)\nSeeing the performance of the second version in assembly, I decided to try whipping up a third version, which would switch from a LEAF_ENTRY to NESTED_ENTRY and use rep cmps for the byte comparison for long strings (instead of the byte-by-byte approach used now).\nIn order to use rep cmps, you need to use two non-volatile registers, rsi (the source index) and rdi (the destination index). You also need to specify the direction of the comparison, which means mutating the flags, which are also classed as non-volatile, so they need to be pushed to the stack in the prologue and popped back off in the epilogue.\nI didn’t really expect this to offer a measurable speedup, but it was a tangible reason to use a NESTED_ENTRY, and otherwise allowed me to stay within the confines of the version 2 implementation.\nLet’s take a look at the implementation. At the very least, it’s useful to see how you can go about organizing your prologue in MASM. For NESTED_ENTRY routines, I always define a Locals structure that incorporates the return address and home parameter space for easy access. Mainly because it allows me to write code like this:\n    mov     Locals.HomeRcx[rsp], rcx        ; Home our first param.\n    mov     Locals.HomeRdx[rsp], rdx        ; Home our second param.\n    mov     rsi, Locals.SavedRsi[rsp]       ; Restore rsi.\n    mov     rdi, Locals.SavedRdi[rsp]       ; Restore rdi.\nInstead of working wiht offsets like this:\n    mov     qword ptr [rsp+30h], rcx        ; Home our first param.\n    mov     qword ptr [rsp+38h], rdx        ; Home our second param.\n    mov     rsi, qword ptr [rsp+10h]        ; Restore rsi.\n    mov     rdi, qword ptr [rsp+8]          ; Restore rdi.\nThis routine was written last, after version 10 of the C routine, so it incorporates the slightly re-arranged loop logic that proved to be faster for that version. Other than that, the main changes involved converting all the early exit returns in the body of the function to jump to a single exit point, Pfx90, mainly to simplify epilogue exit code.\n\nDiffFull\n\n\n % diff -u IsPrefixOfStringInTable_x64_2.asm IsPrefixOfStringInTable_x64_3.asm\n--- IsPrefixOfStringInTable_x64_2.asm   2018-04-26 14:15:53.805409700 -0400\n+++ IsPrefixOfStringInTable_x64_3.asm   2018-04-29 16:01:10.033827200 -0400\n@@ -18,6 +18,31 @@\n\n include StringTable.inc\n\n+;\n+; Define a locals struct for saving flags, rsi and rdi.\n+;\n+\n+Locals struct\n+\n+    Padding             dq      ?\n+    SavedRdi            dq      ?\n+    SavedRsi            dq      ?\n+    SavedFlags          dq      ?\n+\n+    ReturnAddress       dq      ?\n+    HomeRcx             dq      ?\n+    HomeRdx             dq      ?\n+    HomeR8              dq      ?\n+    HomeR9              dq      ?\n+\n+Locals ends\n+\n+;\n+; Exclude the return address onward from the frame calculation size.\n+;\n+\n+LOCALS_SIZE  equ ((sizeof Locals) + (Locals.ReturnAddress - (sizeof Locals)))\n+\n ;++\n ;\n ; STRING_TABLE_INDEX\n@@ -33,6 +58,14 @@\n ;   search string.  That is, whether any string in the table \"starts with\n ;   or is equal to\" the search string.\n ;\n+;   This routine is based off version 2.  It has been converted into a nested\n+;   entry (version 2 is a leaf entry), and uses 'repe cmpsb' to do the string\n+;   comparison for long strings (instead of the byte-by-byte comparison used\n+;   in version 2).  This requires use of the rsi and rdi registers, and the\n+;   direction flag.  These are all non-volatile registers and thus, must be\n+;   saved to the stack in the function prologue (hence the need to make this\n+;   a nested entry).\n+;\n ; Arguments:\n ;\n ;   StringTable - Supplies a pointer to a STRING_TABLE struct.\n@@ -50,7 +83,19 @@\n ;\n ;--\n\n-        LEAF_ENTRY IsPrefixOfStringInTable_x64_2, _TEXT$00\n+        NESTED_ENTRY IsPrefixOfStringInTable_x64_3, _TEXT$00\n+\n+;\n+; Begin prologue.  Allocate stack space and save non-volatile registers.\n+;\n+\n+        alloc_stack LOCALS_SIZE                     ; Allocate stack space.\n+\n+        push_eflags                                 ; Save flags.\n+        save_reg    rsi, Locals.SavedRsi            ; Save non-volatile rsi.\n+        save_reg    rdi, Locals.SavedRdi            ; Save non-volatile rdi.\n+\n+        END_PROLOGUE\n\n ;\n ; Load the string buffer into xmm0, and the unique indexes from the string table\n@@ -120,7 +165,7 @@\n\n         xor         eax, eax                    ; Clear rax.\n         not         al                          ; al = -1\n-        ret                                     ; Return.\n+        jmp         Pfx90                       ; Return.\n\n         ;IACA_VC_END\n\n@@ -214,7 +259,7 @@\n ;\n ;   rcx - Loop counter.\n ;\n-;   rdx - Bitmap initially, then slot length.\n+;   rdx - Bitmap.\n ;\n ;   r9 - Shift count.\n ;\n@@ -228,8 +273,6 @@\n         add         rax, r9                     ; Add shift to create index.\n         inc         r8                          ; tzcnt + 1\n         shrx        rdx, rdx, r8                ; Reposition bitmap.\n-        vpinsrd     xmm5, xmm5, edx, 2          ; Store bitmap, free up rdx.\n-        xor         edx, edx                    ; Clear edx.\n         mov         r9, rax                     ; Copy index back to shift.\n         inc         r9                          ; Shift = Index + 1\n         vpinsrd     xmm5, xmm5, eax, 3          ; Store the raw index xmm5d[3].\n@@ -252,7 +295,7 @@\n ; into xmm1.\n ;\n\n-        vpcmpeqb    xmm1, xmm1, xmm0            ; Compare search string to slot.\n+        vpcmpeqb    xmm1, xmm0, xmm1            ; Compare search string to slot.\n\n ;\n ; Convert the XMM mask into a 32-bit representation, then zero high bits after\n@@ -267,17 +310,6 @@\n         popcnt      r8d, r8d                    ; Count bits.\n\n ;\n-; Load the slot length into rdx.  As xmm3 already has all the slot lengths in\n-; it, we can load rax (the current index) into xmm1 and use it to extract the\n-; slot length via shuffle.  (The length will be in the lowest byte of xmm1\n-; after the shuffle, which we can then vpextrb.)\n-;\n-\n-        movd        xmm1, rax                   ; Load index into xmm1.\n-        vpshufb     xmm1, xmm3, xmm1            ; Shuffle lengths.\n-        vpextrb     rdx, xmm1, 0                ; Extract target length to rdx.\n-\n-;\n ; If 16 characters matched, and the search string's length is longer than 16,\n ; we're going to need to do a comparison of the remaining strings.\n ;\n@@ -287,37 +319,38 @@\n         jmp         Pfx30                       ; Less than 16 matched.\n\n ;\n-; All 16 characters matched.  If the slot length is greater than 16, we need\n-; to do an inline memory comparison of the remaining bytes.  If it's 16 exactly,\n-; then great, that's a slot match, we're done.\n+; All 16 characters matched.  Load the underlying slot's length from the\n+; relevant offset in the xmm3 register, then check to see if it's greater than,\n+; equal or less than 16.\n ;\n\n-@@:     cmp         dl, 16                      ; Compare length to 16.\n+@@:     movd        xmm1, rax                   ; Load into xmm1.\n+        vpshufb     xmm1, xmm3, xmm1            ; Shuffle length...\n+        vpextrb     rax, xmm1, 0                ; And extract back into rax.\n+        cmp         al, 16                      ; Compare length to 16.\n         ja          Pfx50                       ; Length is &gt; 16.\n         je          short Pfx35                 ; Lengths match!\n                                                 ; Length &lt;= 16, fall through...\n\n ;\n ; Less than or equal to 16 characters were matched.  Compare this against the\n-; length of the slot; if equal, this is a match, if not, no match, continue.\n+; length of the search string; if equal, this is a match.\n ;\n\n-Pfx30:  cmp         r8b, dl                     ; Compare against slot length.\n-        jne         @F                          ; No match found.\n-        jmp         short Pfx35                 ; Match found!\n+Pfx30:  cmp         r8d, r10d                   ; Compare against search string.\n+        je          short Pfx35                 ; Match found!\n\n ;\n ; No match against this slot, decrement counter and either continue the loop\n ; or terminate the search and return no match.\n ;\n\n-@@:     vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.\n         dec         cx                          ; Decrement counter.\n         jnz         Pfx20                       ; cx != 0, continue.\n\n         xor         eax, eax                    ; Clear rax.\n         not         al                          ; al = -1\n-        ret                                     ; Return.\n+        jmp         Pfx90                       ; Return.\n\n ;\n ; Pfx35 and Pfx40 are the jump targets for when the prefix match succeeds.  The\n@@ -341,7 +374,7 @@\n ;\n\n         vpextrd     eax, xmm5, 3                ; Extract raw index for match.\n-        ret                                     ; StringMatch == NULL, finish.\n+        jmp         Pfx90                       ; StringMatch == NULL, finish.\n\n ;\n ; StringMatch is not NULL.  Fill out characters matched (currently rax), then\n@@ -367,7 +400,7 @@\n         mov         qword ptr StringMatch.String[r8], rdx ; Save STRING ptr.\n         shr         eax, 4                  ; Revert the scaling.\n\n-        ret\n+        jmp         Pfx90\n\n ;\n ; 16 characters matched and the length of the underlying slot is greater than\n@@ -382,14 +415,15 @@\n ; string slot byte-by-byte to determine if there's a match.\n ;\n\n-Pfx50:  sub         rdx, r10                ; Subtract 16 from search length.\n+Pfx50:  sub         rax, r10                ; Subtract 16 from search length.\n\n ;\n ; Free up some registers by stashing their values into various xmm offsets.\n ;\n\n+        vpinsrd     xmm5, xmm5, edx, 2      ; Free up rdx register.\n         vpinsrb     xmm4, xmm4, ecx, 2      ; Free up rcx register.\n-        mov         rcx, rdx                ; Free up rdx, rcx is now counter.\n+        mov         rcx, rax                ; Free up rax, rcx is now counter.\n\n ;\n ; Load the search string buffer and advance it 16 bytes.\n@@ -409,31 +443,27 @@\n         vpextrq     r8, xmm2, 0             ; Extract StringTable into r8.\n         mov         r8, StringTable.pStringArray[r8] ; Load string array.\n\n+        vpextrd     eax, xmm5, 3            ; Extract index from xmm5.\n         shl         eax, 4                  ; Scale the index; sizeof STRING=16.\n\n         lea         r8, [rax + StringArray.Strings[r8]] ; Resolve address.\n         mov         r8, String.Buffer[r8]   ; Load string table buffer address.\n         add         r8, r10                 ; Advance buffer 16 bytes.\n\n-        xor         eax, eax                ; Clear eax.\n+        mov         rax, rcx                ; Copy counter.\n\n ;\n ; We've got both buffer addresses + 16 bytes loaded in r11 and r8 respectively.\n-; Do a byte-by-byte comparison.\n+; Set up rsi/rdi so we can do a 'rep cmps'.\n ;\n\n-        align 16\n-@@:     mov         dl, byte ptr [rax + r11]    ; Load byte from search string.\n-        cmp         dl, byte ptr [rax + r8]     ; Compare against target.\n-        jne         short Pfx60                 ; If not equal, jump.\n-\n-;\n-; The two bytes were equal, update rax, decrement rcx and potentially continue\n-; the loop.\n-;\n+        cld\n+        mov         rsi, r11\n+        mov         rdi, r8\n+        repe        cmpsb\n\n-        inc         ax                          ; Increment index.\n-        loopnz      @B                          ; Decrement cx and loop back.\n+        test        cl, 0\n+        jnz         short Pfx60                 ; Not all bytes compared, jump.\n\n ;\n ; All bytes matched!  Add 16 (still in r10) back to rax such that it captures\n@@ -460,7 +490,7 @@\n\n         xor         eax, eax                    ; Clear rax.\n         not         al                          ; al = -1\n-        ret                                     ; Return.\n+        jmp Pfx90                               ; Return.\n\n ;\n ; More comparisons remain; restore the registers we clobbered and continue loop.\n@@ -473,7 +503,17 @@\n\n         ;IACA_VC_END\n\n-        LEAF_END   IsPrefixOfStringInTable_x64_2, _TEXT$00\n+        align   16\n+\n+Pfx90:  mov     rsi, Locals.SavedRsi[rsp]       ; Restore rsi.\n+        mov     rdi, Locals.SavedRdi[rsp]       ; Restore rdi.\n+        popfq                                   ; Restore flags.\n+        add     rsp, LOCALS_SIZE                ; Deallocate stack space.\n+\n+        ret\n+\n+        NESTED_END   IsPrefixOfStringInTable_x64_3, _TEXT$00\n+\n\n ; vim:set tw=80 ts=8 sw=4 sts=4 et syntax=masm fo=croql comments=\\:;           :\n\n\n;\n; Define a locals struct for saving flags, rsi and rdi.\n;\n\nLocals struct\n\n    Padding             dq      ?\n    SavedRdi            dq      ?\n    SavedRsi            dq      ?\n    SavedFlags          dq      ?\n\n    ReturnAddress       dq      ?\n    HomeRcx             dq      ?\n    HomeRdx             dq      ?\n    HomeR8              dq      ?\n    HomeR9              dq      ?\n\nLocals ends\n\n;\n; Exclude the return address onward from the frame calculation size.\n;\n\nLOCALS_SIZE  equ ((sizeof Locals) + (Locals.ReturnAddress - (sizeof Locals)))\n\n;++\n;\n; STRING_TABLE_INDEX\n; IsPrefixOfStringInTable_x64_*(\n;     _In_ PSTRING_TABLE StringTable,\n;     _In_ PSTRING String,\n;     _Out_opt_ PSTRING_MATCH Match\n;     )\n;\n; Routine Description:\n;\n;   Searches a string table to see if any strings \"prefix match\" the given\n;   search string.  That is, whether any string in the table \"starts with\n;   or is equal to\" the search string.\n;\n;   This routine is based off version 2.  It has been converted into a nested\n;   entry (version 2 is a leaf entry), and uses 'rep cmpsb' to do the string\n;   comparison for long strings (instead of the byte-by-byte comparison used\n;   in version 2).  This requires use of the rsi and rdi registers, and the\n;   direction flag.  These are all non-volatile registers and thus, must be\n;   saved to the stack in the function prologue (hence the need to make this\n;   a nested entry).\n;\n; Arguments:\n;\n;   StringTable - Supplies a pointer to a STRING_TABLE struct.\n;\n;   String - Supplies a pointer to a STRING struct that contains the string to\n;       search for.\n;\n;   Match - Optionally supplies a pointer to a variable that contains the\n;       address of a STRING_MATCH structure.  This will be populated with\n;       additional details about the match if a non-NULL pointer is supplied.\n;\n; Return Value:\n;\n;   Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n;\n;--\n\n        NESTED_ENTRY IsPrefixOfStringInTable_x64_3, _TEXT$00\n\n;\n; Begin prologue.  Allocate stack space and save non-volatile registers.\n;\n\n        alloc_stack LOCALS_SIZE                     ; Allocate stack space.\n\n        push_eflags                                 ; Save flags.\n        save_reg    rsi, Locals.SavedRsi            ; Save non-volatile rsi.\n        save_reg    rdi, Locals.SavedRdi            ; Save non-volatile rdi.\n\n        END_PROLOGUE\n\n;\n; Load the string buffer into xmm0, and the unique indexes from the string table\n; into xmm1.  Shuffle the buffer according to the unique indexes, and store the\n; result into xmm5.\n;\n\n        ;IACA_VC_START\n\n        mov     rax, String.Buffer[rdx]\n        vmovdqu xmm0, xmmword ptr [rax]                 ; Load search buffer.\n        vmovdqa xmm1, xmmword ptr StringTable.UniqueIndex[rcx] ; Load indexes.\n        vpshufb xmm5, xmm0, xmm1\n\n;\n; Load the string table's unique character array into xmm2.\n\n        vmovdqa xmm2, xmmword ptr StringTable.UniqueChars[rcx]  ; Load chars.\n\n;\n; Compare the search string's unique character array (xmm5) against the string\n; table's unique chars (xmm2), saving the result back into xmm5.\n;\n\n        vpcmpeqb    xmm5, xmm5, xmm2            ; Compare unique chars.\n\n;\n; Load the lengths of each string table slot into xmm3.\n;\n        vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]      ; Load lengths.\n\n;\n; Set xmm2 to all ones.  We use this later to invert the length comparison.\n;\n\n        vpcmpeqq    xmm2, xmm2, xmm2            ; Set xmm2 to all ones.\n\n;\n; Broadcast the byte-sized string length into xmm4.\n;\n\n        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.\n\n;\n; Compare the search string's length, which we've broadcasted to all 8-byte\n; elements of the xmm4 register, to the lengths of the slots in the string\n; table, to find those that are greater in length.  Invert the result, such\n; that we're left with a masked register where each 0xff element indicates\n; a slot with a length less than or equal to our search string's length.\n;\n\n        vpcmpgtb    xmm1, xmm3, xmm4            ; Identify long slots.\n        vpxor       xmm1, xmm1, xmm2            ; Invert the result.\n\n;\n; Intersect-and-test the unique character match xmm mask register (xmm5) with\n; the length match mask xmm register (xmm1).  This affects flags, allowing us\n; to do a fast-path exit for the no-match case (where ZF = 1).\n;\n\n        vptest      xmm5, xmm1                  ; Check for no match.\n        jnz         short Pfx10                 ; There was a match.\n\n;\n; No match, set rax to -1 and return.\n;\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        jmp         Pfx90                       ; Return.\n\n        ;IACA_VC_END\n\n;\n; (There was at least one match, continue with processing.)\n;\n\n;\n; Calculate the \"search length\" for the incoming search string, which is\n; equivalent of 'min(String-&gt;Length, 16)'.  (The search string's length\n; currently lives in xmm4, albeit as a byte-value broadcasted across the\n; entire register, so extract that first.)\n;\n; Once the search length is calculated, deposit it back at the second byte\n; location of xmm4.\n;\n;   r10 and xmm4[15:8] - Search length (min(String-&gt;Length, 16))\n;\n;   r11 - String length (String-&gt;Length)\n;\n\nPfx10:  vpextrb     r11, xmm4, 0                ; Load length.\n        mov         rax, 16                     ; Load 16 into rax.\n        mov         r10, r11                    ; Copy into r10.\n        cmp         r10w, ax                    ; Compare against 16.\n        cmova       r10w, ax                    ; Use 16 if length is greater.\n        vpinsrb     xmm4, xmm4, r10d, 1         ; Save back to xmm4b[1].\n\n;\n; Home our parameter registers into xmm registers instead of their stack-backed\n; location, to avoid memory writes.\n;\n\n        vpxor       xmm2, xmm2, xmm2            ; Clear xmm2.\n        vpinsrq     xmm2, xmm2, rcx, 0          ; Save rcx into xmm2q[0].\n        vpinsrq     xmm2, xmm2, rdx, 1          ; Save rdx into xmm2q[1].\n\n;\n; Intersect xmm5 and xmm1 (as we did earlier with the 'vptest xmm5, xmm1'),\n; yielding a mask identifying indices we need to perform subsequent matches\n; upon.  Convert this into a bitmap and save in xmm2d[2].\n;\n\n        vpand       xmm5, xmm5, xmm1            ; Intersect unique + lengths.\n        vpmovmskb   edx, xmm5                   ; Generate a bitmap from mask.\n\n;\n; We're finished with xmm5; repurpose it in the same vein as xmm2 above.\n;\n\n        vpxor       xmm5, xmm5, xmm5            ; Clear xmm5.\n        vpinsrq     xmm5, xmm5, r8, 0           ; Save r8 into xmm5q[0].\n\n;\n; Summary of xmm register stashing for the rest of the routine:\n;\n; xmm2:\n;        0:63   (vpinsrq 0)     rcx (1st function parameter, StringTable)\n;       64:127  (vpinsrq 1)     rdx (2nd function paramter, String)\n;\n; xmm4:\n;       0:7     (vpinsrb 0)     length of search string\n;       8:15    (vpinsrb 1)     min(String-&gt;Length, 16)\n;      16:23    (vpinsrb 2)     loop counter (when doing long string compares)\n;      24:31    (vpinsrb 3)     shift count\n;\n; xmm5:\n;       0:63    (vpinsrq 0)     r8 (3rd function parameter, StringMatch)\n;      64:95    (vpinsrd 2)     bitmap of slots to compare\n;      96:127   (vpinsrd 3)     index of slot currently being processed\n;\n\n;\n; Initialize rcx as our counter register by doing a popcnt against the bitmap\n; we just generated in edx, and clear our shift count register (r9).\n;\n\n        popcnt      ecx, edx                    ; Count bits in bitmap.\n        xor         r9, r9                      ; Clear r9.\n\n        align 16\n\n;\n; Top of the main comparison loop.  The bitmap will be present in rdx.  Count\n; trailing zeros of the bitmap, and then add in the shift count, producing an\n; index (rax) we can use to load the corresponding slot.\n;\n; Register usage at top of loop:\n;\n;   rax - Index.\n;\n;   rcx - Loop counter.\n;\n;   rdx - Bitmap.\n;\n;   r9 - Shift count.\n;\n;   r10 - Search length.\n;\n;   r11 - String length.\n;\n\nPfx20:  tzcnt       r8d, edx                    ; Count trailing zeros.\n        mov         eax, r8d                    ; Copy tzcnt to rax,\n        add         rax, r9                     ; Add shift to create index.\n        inc         r8                          ; tzcnt + 1\n        shrx        rdx, rdx, r8                ; Reposition bitmap.\n        mov         r9, rax                     ; Copy index back to shift.\n        inc         r9                          ; Shift = Index + 1\n        vpinsrd     xmm5, xmm5, eax, 3          ; Store the raw index xmm5d[3].\n\n;\n; \"Scale\" the index (such that we can use it in a subsequent vmovdqa) by\n; shifting left by 4 (i.e. multiply by '(sizeof STRING_SLOT)', which is 16).\n;\n; Then, load the string table slot at this index into xmm1, then shift rax back.\n;\n\n        shl         eax, 4\n        vpextrq     r8, xmm2, 0\n        vmovdqa     xmm1, xmmword ptr [rax + StringTable.Slots[r8]]\n        shr         eax, 4\n\n;\n; The search string's first 16 characters are already in xmm0.  Compare this\n; against the slot that has just been loaded into xmm1, storing the result back\n; into xmm1.\n;\n\n        vpcmpeqb    xmm1, xmm0, xmm1            ; Compare search string to slot.\n\n;\n; Convert the XMM mask into a 32-bit representation, then zero high bits after\n; our \"search length\", which allows us to ignore the results of the comparison\n; above for bytes that were after the search string's length, if applicable.\n; Then, count the number of bits remaining, which tells us how many characters\n; we matched.\n;\n\n        vpmovmskb   r8d, xmm1                   ; Convert into mask.\n        bzhi        r8d, r8d, r10d              ; Zero high bits.\n        popcnt      r8d, r8d                    ; Count bits.\n\n;\n; If 16 characters matched, and the search string's length is longer than 16,\n; we're going to need to do a comparison of the remaining strings.\n;\n\n        cmp         r8w, 16                     ; Compare chars matched to 16.\n        je          short @F                    ; 16 chars matched.\n        jmp         Pfx30                       ; Less than 16 matched.\n\n;\n; All 16 characters matched.  Load the underlying slot's length from the\n; relevant offset in the xmm3 register, then check to see if it's greater than,\n; equal or less than 16.\n;\n\n@@:     movd        xmm1, rax                   ; Load into xmm1.\n        vpshufb     xmm1, xmm3, xmm1            ; Shuffle length...\n        vpextrb     rax, xmm1, 0                ; And extract back into rax.\n        cmp         al, 16                      ; Compare length to 16.\n        ja          Pfx50                       ; Length is &gt; 16.\n        je          short Pfx35                 ; Lengths match!\n                                                ; Length &lt;= 16, fall through...\n\n;\n; Less than or equal to 16 characters were matched.  Compare this against the\n; length of the search string; if equal, this is a match.\n;\n\nPfx30:  cmp         r8d, r10d                   ; Compare against search string.\n        je          short Pfx35                 ; Match found!\n\n;\n; No match against this slot, decrement counter and either continue the loop\n; or terminate the search and return no match.\n;\n\n        dec         cx                          ; Decrement counter.\n        jnz         Pfx20                       ; cx != 0, continue.\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        jmp         Pfx90                       ; Return.\n\n;\n; Pfx35 and Pfx40 are the jump targets for when the prefix match succeeds.  The\n; former is used when we need to copy the number of characters matched from r8\n; back to rax.  The latter jump target doesn't require this.\n;\n\nPfx35:  mov         rax, r8                     ; Copy numbers of chars matched.\n\n;\n; Load the match parameter back into r8 and test to see if it's not-NULL, in\n; which case we need to fill out a STRING_MATCH structure for the match.\n;\n\nPfx40:  vpextrq     r8, xmm5, 0                 ; Extract StringMatch.\n        test        r8, r8                      ; Is NULL?\n        jnz         short @F                    ; Not zero, need to fill out.\n\n;\n; StringMatch is NULL, we're done. Extract index of match back into rax and ret.\n;\n\n        vpextrd     eax, xmm5, 3                ; Extract raw index for match.\n        jmp         Pfx90                       ; StringMatch == NULL, finish.\n\n;\n; StringMatch is not NULL.  Fill out characters matched (currently rax), then\n; reload the index from xmm5 into rax and save.\n;\n\n@@:     mov         byte ptr StringMatch.NumberOfMatchedCharacters[r8], al\n        vpextrd     eax, xmm5, 3                ; Extract raw index for match.\n        mov         byte ptr StringMatch.Index[r8], al\n\n;\n; Final step, loading the address of the string in the string array.  This\n; involves going through the StringTable, so we need to load that parameter\n; back into rcx, then resolving the string array address via pStringArray,\n; then the relevant STRING offset within the StringArray.Strings structure.\n;\n\n        vpextrq     rcx, xmm2, 0            ; Extract StringTable into rcx.\n        mov         rcx, StringTable.pStringArray[rcx] ; Load string array.\n\n        shl         eax, 4                  ; Scale the index; sizeof STRING=16.\n        lea         rdx, [rax + StringArray.Strings[rcx]] ; Resolve address.\n        mov         qword ptr StringMatch.String[r8], rdx ; Save STRING ptr.\n        shr         eax, 4                  ; Revert the scaling.\n\n        jmp         Pfx90\n\n;\n; 16 characters matched and the length of the underlying slot is greater than\n; 16, so we need to do a little memory comparison to determine if the search\n; string is a prefix match.\n;\n; The slot length is stored in rax at this point, and the search string's\n; length is stored in r11.  We know that the search string's length will\n; always be longer than or equal to the slot length at this point, so, we\n; can subtract 16 (currently stored in r10) from rax, and use the resulting\n; value as a loop counter, comparing the search string with the underlying\n; string slot byte-by-byte to determine if there's a match.\n;\n\nPfx50:  sub         rax, r10                ; Subtract 16 from search length.\n\n;\n; Free up some registers by stashing their values into various xmm offsets.\n;\n\n        vpinsrd     xmm5, xmm5, edx, 2      ; Free up rdx register.\n        vpinsrb     xmm4, xmm4, ecx, 2      ; Free up rcx register.\n        mov         rcx, rax                ; Free up rax, rcx is now counter.\n\n;\n; Load the search string buffer and advance it 16 bytes.\n;\n\n        vpextrq     r11, xmm2, 1            ; Extract String into r11.\n        mov         r11, String.Buffer[r11] ; Load buffer address.\n        add         r11, r10                ; Advance buffer 16 bytes.\n\n;\n; Loading the slot is more involved as we have to go to the string table, then\n; the pStringArray pointer, then the relevant STRING offset within the string\n; array (which requires re-loading the index from xmm5d[3]), then the string\n; buffer from that structure.\n;\n\n        vpextrq     r8, xmm2, 0             ; Extract StringTable into r8.\n        mov         r8, StringTable.pStringArray[r8] ; Load string array.\n\n        vpextrd     eax, xmm5, 3            ; Extract index from xmm5.\n        shl         eax, 4                  ; Scale the index; sizeof STRING=16.\n\n        lea         r8, [rax + StringArray.Strings[r8]] ; Resolve address.\n        mov         r8, String.Buffer[r8]   ; Load string table buffer address.\n        add         r8, r10                 ; Advance buffer 16 bytes.\n\n        mov         rax, rcx                ; Copy counter.\n\n;\n; We've got both buffer addresses + 16 bytes loaded in r11 and r8 respectively.\n; Set up rsi/rdi so we can do a 'rep cmps'.\n;\n\n        cld\n        mov         rsi, r11\n        mov         rdi, r8\n        repe        cmpsb\n\n        test        cl, 0\n        jnz         short Pfx60                 ; Not all bytes compared, jump.\n\n;\n; All bytes matched!  Add 16 (still in r10) back to rax such that it captures\n; how many characters we matched, and then jump to Pfx40 for finalization.\n;\n\n        add         rax, r10\n        jmp         Pfx40\n\n;\n; Byte comparisons were not equal.  Restore the rcx loop counter and decrement\n; it.  If it's zero, we have no more strings to compare, so we can do a quick\n; exit.  If there are still comparisons to be made, restore the other registers\n; we trampled then jump back to the start of the loop Pfx20.\n;\n\nPfx60:  vpextrb     rcx, xmm4, 2                ; Restore rcx counter.\n        dec         cx                          ; Decrement counter.\n        jnz         short @F                    ; Jump forward if not zero.\n\n;\n; No more comparisons remaining, return.\n;\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        jmp Pfx90                               ; Return.\n\n;\n; More comparisons remain; restore the registers we clobbered and continue loop.\n;\n\n@@:     vpextrb     r10, xmm4, 1                ; Restore r10.\n        vpextrb     r11, xmm4, 0                ; Restore r11.\n        vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.\n        jmp         Pfx20                       ; Continue comparisons.\n\n        ;IACA_VC_END\n\n        align   16\n\nPfx90:  mov     rsi, Locals.SavedRsi[rsp]       ; Restore rsi.\n        mov     rdi, Locals.SavedRdi[rsp]       ; Restore rdi.\n        popfq                                   ; Restore flags.\n        add     rsp, LOCALS_SIZE                ; Deallocate stack space.\n\n        ret\n\n        NESTED_END   IsPrefixOfStringInTable_x64_3, _TEXT$00\n\n\n; vim:set tw=80 ts=8 sw=4 sts=4 et syntax=masm fo=croql comments=\\:;           :\n\n\n\nI don’t have a strong hunch as to how this will perform; like I said earlier, it was mainly done to set up the scaffolding for using a NESTED_ENTRY in the future, such that we’ll have the glue in place if we want to iterate on the disassembly of the PGO versions. If I had to guess, I suspect it will be slightly slower than version 2, but surely not by much, right? It’s a pretty minor change in the grand scheme of things. Let’s take a look.\n\n\nBenchmark x64 3\n\n\n\nBenchmark x64 3\n\n\nHah! Version 3 is much, much worse! Even its negative matching performance is terrible, which is the one thing the assembly versions have been good at so far. How peculiar.\nNow, in the interest of keeping events chronological, as much as I’d like to dive in now and figure out why, I’ll have to defer to my behavior when I encountered this performance gap: I laughed, shelved the version 3 experiment, and moved on.\nThat’s a decidedly unsatisfying end to the matter, though, I’ll admit. We’ll come back to it later in the article and try and get some closure as to why it was so slow, comparatively.\n\n\n\nInternet Feedback\nSo, at this point, with version 10 of the C routine and version 2 of the assembly version in hand, and a very early draft of this article, I solicited feedback on Twitter and got some great responses. Thanks again to Fabian Giesen, Wojciech Muła, Geoff Langdale, Daniel Lemire, and Kendall Willets for their discussion and input over the course of a few days!"
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#round2",
    "href": "articles/is-prefix-of-string-in-table/index.html#round2",
    "title": "Is Prefix Of String In Table?",
    "section": "Round 2—Post-Internet Feedback",
    "text": "Round 2—Post-Internet Feedback\nLet’s take a look at the iterations that came about after receiving feedback.\n\nIsPrefixOfStringInTable_11\n← IsPrefixOfStringInTable_10 | IsPrefixOfStringInTable_12 →\nBoth Fabian Giesen and Wojciech Muła pointed out that we could use _mm_andnot_si128() to avoid the need to invert the results of the IncludeSlotsByLength XMM register (via _mm_xor_si128()). Let’s try that.\n\nDiffFull\n\n\n% diff -u IsPrefixOfStringInTable_10.c IsPrefixOfStringInTable_11.c\n--- IsPrefixOfStringInTable_10.c        2018-04-26 10:38:09.357890400 -0400\n+++ IsPrefixOfStringInTable_11.c        2018-04-26 12:43:44.184528000 -0400\n@@ -18,7 +18,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_10(\n+IsPrefixOfStringInTable_11(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -31,8 +31,8 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This version is based off version 8, but rewrites the inner loop that\n-    checks for comparisons.\n+    This version is based off version 10, but with the vpandn used at the\n+    end of the initial test, as suggested by Wojciech Mula (@pshufb).\n\n Arguments:\n\n@@ -70,9 +70,7 @@\n     XMMWORD TableUniqueChars;\n     XMMWORD IncludeSlotsByUniqueChar;\n     XMMWORD IgnoreSlotsByLength;\n-    XMMWORD IncludeSlotsByLength;\n     XMMWORD IncludeSlots;\n-    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n     //\n     // Unconditionally do the following five operations before checking any of\n@@ -158,28 +156,25 @@\n     // N.B. Because we default the length of empty slots to 0x7f, they will\n     //      handily be included in the ignored set (i.e. their words will also\n     //      be set to 0xff), which means they'll also get filtered out when\n-    //      we invert the mask shortly after.\n+    //      we do the \"and not\" intersection with the include slots next.\n     //\n\n     IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n     //\n-    // Invert the result of the comparison; we want 0xff for slots to include\n-    // and 0x0 for slots to ignore (it's currently the other way around).  We\n-    // can achieve this by XOR'ing the result against our all-ones XMM register.\n-    //\n-\n-    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n-\n-    //\n     // We're now ready to intersect the two XMM registers to determine which\n     // slots should still be included in the comparison (i.e. which slots have\n     // the exact same unique character as the string and a length less than or\n     // equal to the length of the search string).\n     //\n+    // As the IgnoreSlotsByLength XMM register is the inverse of what we want\n+    // at the moment (we want 0xff for slots to include, and 0x00 for slots\n+    // to ignore; it's currently the other way around), we use _mm_andnot_si128\n+    // instead of just _mm_and_si128.\n+    //\n\n-    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n-                                 IncludeSlotsByLength);\n+    IncludeSlots = _mm_andnot_si128(IgnoreSlotsByLength,\n+                                    IncludeSlotsByUniqueChar);\n\n     //\n     // Generate a mask.\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_11(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This version is based off version 10, but with the vpandn used at the\n    end of the initial test, as suggested by Wojciech Mula (@pshufb).\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlots;\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we do the \"and not\" intersection with the include slots next.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // We're now ready to intersect the two XMM registers to determine which\n    // slots should still be included in the comparison (i.e. which slots have\n    // the exact same unique character as the string and a length less than or\n    // equal to the length of the search string).\n    //\n    // As the IgnoreSlotsByLength XMM register is the inverse of what we want\n    // at the moment (we want 0xff for slots to include, and 0x00 for slots\n    // to ignore; it's currently the other way around), we use _mm_andnot_si128\n    // instead of just _mm_and_si128.\n    //\n\n    IncludeSlots = _mm_andnot_si128(IgnoreSlotsByLength,\n                                    IncludeSlotsByUniqueChar);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    if (!Bitmap) {\n\n        //\n        // No bits were set, so there are no strings in this table starting\n        // with the same character and of a lesser or equal length as the\n        // search string.\n        //\n\n        return NO_MATCH_FOUND;\n    }\n\n    //\n    // Calculate the \"search length\" of the incoming string, which ensures we\n    // only compare up to the first 16 characters.\n    //\n\n    SearchLength = min(String-&gt;Length, 16);\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched &lt; Length && Length &lt;= 16) {\n\n            //\n            // The slot length is longer than the number of characters matched\n            // from the search string; this isn't a prefix match.  Continue.\n            //\n\n            continue;\n        }\n\n        if (Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n            }\n        }\n\n        //\n        // This slot is a prefix match.  Fill out the Match structure if the\n        // caller provided a non-NULL pointer, then return the index of the\n        // match.\n        //\n\n        if (ARGUMENT_PRESENT(Match)) {\n\n            Match-&gt;Index = (BYTE)Index;\n            Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n            Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n        }\n\n        return (STRING_TABLE_INDEX)Index;\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\nWe’re only shaving one instruction off here, so the performance gain, if any, should be very modest.\n\n\nBenchmark 11\n\n\n\nBenchmark 11\n\n\nDefinitely a slight improvement over version 10 in most cases!\n\n\n\nIsPrefixOfStringInTable_x64_4\n← IsPrefixOfStringInTable_x64_3 | IsPrefixOfStringInTable_x64_5 →\nSomething I didn’t know about vptest that Fabian pointed out is that it actually does two operations. The first essentially does an AND of the two input registers and sets the zero flag (ZF=1) if the result is all 0s. We’ve been using that aspect in the assembly version up to now.\nHowever, it also does the equivalent of (xmm0 and (not xmm1)), and sets the carry flag (CY=1) if that expression evaluates to all zeros. That’s handy, because it’s exactly the expression we want to do!\nSo, let’s take version 2 of our assembly routine, remove the vpxor bit, and re-arrange the vptest inputs such that we can do a jnc instead of jnz:\n\nDiffFull\n\n\n% diff -u IsPrefixOfStringInTable_x64_2.asm IsPrefixOfStringInTable_x64_4.asm\n--- IsPrefixOfStringInTable_x64_2.asm   2018-04-26 14:15:53.805409700 -0400\n+++ IsPrefixOfStringInTable_x64_4.asm   2018-04-26 14:16:37.909717200 -0400\n@@ -33,6 +33,10 @@\n ;   search string.  That is, whether any string in the table \"starts with\n ;   or is equal to\" the search string.\n ;\n+;   This routine is based off version 2, but leverages the fact that\n+;   vptest sets the carry flag if '(xmm0 and (not xmm1))' evaluates\n+;   to all 0s, avoiding the the need to do the pxor or pandn steps.\n+;\n ; Arguments:\n ;\n ;   StringTable - Supplies a pointer to a STRING_TABLE struct.\n@@ -50,7 +54,7 @@\n ;\n ;--\n\n-        LEAF_ENTRY IsPrefixOfStringInTable_x64_2, _TEXT$00\n+        LEAF_ENTRY IsPrefixOfStringInTable_x64_4, _TEXT$00\n\n ;\n ; Load the string buffer into xmm0, and the unique indexes from the string table\n@@ -83,12 +87,6 @@\n         vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]      ; Load lengths.\n\n ;\n-; Set xmm2 to all ones.  We use this later to invert the length comparison.\n-;\n-\n-        vpcmpeqq    xmm2, xmm2, xmm2            ; Set xmm2 to all ones.\n-\n-;\n ; Broadcast the byte-sized string length into xmm4.\n ;\n\n@@ -103,16 +101,16 @@\n ;\n\n         vpcmpgtb    xmm1, xmm3, xmm4            ; Identify long slots.\n-        vpxor       xmm1, xmm1, xmm2            ; Invert the result.\n\n ;\n ; Intersect-and-test the unique character match xmm mask register (xmm5) with\n-; the length match mask xmm register (xmm1).  This affects flags, allowing us\n-; to do a fast-path exit for the no-match case (where ZF = 1).\n+; the inverted length match mask xmm register (xmm1).  This will set the carry\n+; flag (CY = 1) if the result of 'xmm5 and (not xmm1)' is all 0s, which allows\n+; us to do a fast-path exit for the no-match case.\n ;\n\n-        vptest      xmm5, xmm1                  ; Check for no match.\n-        jnz         short Pfx10                 ; There was a match.\n+        vptest      xmm1, xmm5                  ; Check for no match.\n+        jnc         short Pfx10                 ; There was a match.\n\n ;\n ; No match, set rax to -1 and return.\n@@ -159,12 +157,12 @@\n         vpinsrq     xmm2, xmm2, rdx, 1          ; Save rdx into xmm2q[1].\n\n ;\n-; Intersect xmm5 and xmm1 (as we did earlier with the 'vptest xmm5, xmm1'),\n+; Intersect xmm5 and xmm1 (as we did earlier with the 'vptest xmm1, xmm5'),\n ; yielding a mask identifying indices we need to perform subsequent matches\n ; upon.  Convert this into a bitmap and save in xmm2d[2].\n ;\n\n-        vpand       xmm5, xmm5, xmm1            ; Intersect unique + lengths.\n+        vpandn      xmm5, xmm1, xmm5            ; Intersect unique + lengths.\n         vpmovmskb   edx, xmm5                   ; Generate a bitmap from mask.\n\n ;\n@@ -473,7 +471,7 @@\n\n         ;IACA_VC_END\n\n-        LEAF_END   IsPrefixOfStringInTable_x64_2, _TEXT$00\n+        LEAF_END   IsPrefixOfStringInTable_x64_4, _TEXT$00\n\n ; vim:set tw=80 ts=8 sw=4 sts=4 et syntax=masm fo=croql comments=\\:;           :\n\n\n;++\n;\n; STRING_TABLE_INDEX\n; IsPrefixOfStringInTable_x64_*(\n;     _In_ PSTRING_TABLE StringTable,\n;     _In_ PSTRING String,\n;     _Out_opt_ PSTRING_MATCH Match\n;     )\n;\n; Routine Description:\n;\n;   Searches a string table to see if any strings \"prefix match\" the given\n;   search string.  That is, whether any string in the table \"starts with\n;   or is equal to\" the search string.\n;\n;   This routine is based off version 2, but leverages the fact that\n;   vptest sets the carry flag if '(xmm0 and (not xmm1))' evaluates\n;   to all 0s, avoiding the the need to do the pxor or pandn steps.\n;\n; Arguments:\n;\n;   StringTable - Supplies a pointer to a STRING_TABLE struct.\n;\n;   String - Supplies a pointer to a STRING struct that contains the string to\n;       search for.\n;\n;   Match - Optionally supplies a pointer to a variable that contains the\n;       address of a STRING_MATCH structure.  This will be populated with\n;       additional details about the match if a non-NULL pointer is supplied.\n;\n; Return Value:\n;\n;   Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n;\n;--\n\n        LEAF_ENTRY IsPrefixOfStringInTable_x64_4, _TEXT$00\n\n;\n; Load the string buffer into xmm0, and the unique indexes from the string table\n; into xmm1.  Shuffle the buffer according to the unique indexes, and store the\n; result into xmm5.\n;\n\n        ;IACA_VC_START\n\n        mov     rax, String.Buffer[rdx]\n        vmovdqu xmm0, xmmword ptr [rax]                 ; Load search buffer.\n        vmovdqa xmm1, xmmword ptr StringTable.UniqueIndex[rcx] ; Load indexes.\n        vpshufb xmm5, xmm0, xmm1\n\n;\n; Load the string table's unique character array into xmm2.\n\n        vmovdqa xmm2, xmmword ptr StringTable.UniqueChars[rcx]  ; Load chars.\n\n;\n; Compare the search string's unique character array (xmm5) against the string\n; table's unique chars (xmm2), saving the result back into xmm5.\n;\n\n        vpcmpeqb    xmm5, xmm5, xmm2            ; Compare unique chars.\n\n;\n; Load the lengths of each string table slot into xmm3.\n;\n        vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]      ; Load lengths.\n\n;\n; Broadcast the byte-sized string length into xmm4.\n;\n\n        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.\n\n;\n; Compare the search string's length, which we've broadcasted to all 8-byte\n; elements of the xmm4 register, to the lengths of the slots in the string\n; table, to find those that are greater in length.  Invert the result, such\n; that we're left with a masked register where each 0xff element indicates\n; a slot with a length less than or equal to our search string's length.\n;\n\n        vpcmpgtb    xmm1, xmm3, xmm4            ; Identify long slots.\n\n;\n; Intersect-and-test the unique character match xmm mask register (xmm5) with\n; the inverted length match mask xmm register (xmm1).  This will set the carry\n; flag (CY = 1) if the result of 'xmm5 and (not xmm1)' is all 0s, which allows\n; us to do a fast-path exit for the no-match case.\n;\n\n        vptest      xmm1, xmm5                  ; Check for no match.\n        jnc         short Pfx10                 ; There was a match.\n\n;\n; No match, set rax to -1 and return.\n;\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        ret                                     ; Return.\n\n        ;IACA_VC_END\n\n;\n; (There was at least one match, continue with processing.)\n;\n\n;\n; Calculate the \"search length\" for the incoming search string, which is\n; equivalent of 'min(String-&gt;Length, 16)'.  (The search string's length\n; currently lives in xmm4, albeit as a byte-value broadcasted across the\n; entire register, so extract that first.)\n;\n; Once the search length is calculated, deposit it back at the second byte\n; location of xmm4.\n;\n;   r10 and xmm4[15:8] - Search length (min(String-&gt;Length, 16))\n;\n;   r11 - String length (String-&gt;Length)\n;\n\nPfx10:  vpextrb     r11, xmm4, 0                ; Load length.\n        mov         rax, 16                     ; Load 16 into rax.\n        mov         r10, r11                    ; Copy into r10.\n        cmp         r10w, ax                    ; Compare against 16.\n        cmova       r10w, ax                    ; Use 16 if length is greater.\n        vpinsrb     xmm4, xmm4, r10d, 1         ; Save back to xmm4b[1].\n\n;\n; Home our parameter registers into xmm registers instead of their stack-backed\n; location, to avoid memory writes.\n;\n\n        vpxor       xmm2, xmm2, xmm2            ; Clear xmm2.\n        vpinsrq     xmm2, xmm2, rcx, 0          ; Save rcx into xmm2q[0].\n        vpinsrq     xmm2, xmm2, rdx, 1          ; Save rdx into xmm2q[1].\n\n;\n; Intersect xmm5 and xmm1 (as we did earlier with the 'vptest xmm1, xmm5'),\n; yielding a mask identifying indices we need to perform subsequent matches\n; upon.  Convert this into a bitmap and save in xmm2d[2].\n;\n\n        vpandn      xmm5, xmm1, xmm5            ; Intersect unique + lengths.\n        vpmovmskb   edx, xmm5                   ; Generate a bitmap from mask.\n\n;\n; We're finished with xmm5; repurpose it in the same vein as xmm2 above.\n;\n\n        vpxor       xmm5, xmm5, xmm5            ; Clear xmm5.\n        vpinsrq     xmm5, xmm5, r8, 0           ; Save r8 into xmm5q[0].\n\n;\n; Summary of xmm register stashing for the rest of the routine:\n;\n; xmm2:\n;        0:63   (vpinsrq 0)     rcx (1st function parameter, StringTable)\n;       64:127  (vpinsrq 1)     rdx (2nd function paramter, String)\n;\n; xmm4:\n;       0:7     (vpinsrb 0)     length of search string\n;       8:15    (vpinsrb 1)     min(String-&gt;Length, 16)\n;      16:23    (vpinsrb 2)     loop counter (when doing long string compares)\n;      24:31    (vpinsrb 3)     shift count\n;\n; xmm5:\n;       0:63    (vpinsrq 0)     r8 (3rd function parameter, StringMatch)\n;      64:95    (vpinsrd 2)     bitmap of slots to compare\n;      96:127   (vpinsrd 3)     index of slot currently being processed\n;\n\n;\n; Initialize rcx as our counter register by doing a popcnt against the bitmap\n; we just generated in edx, and clear our shift count register (r9).\n;\n\n        popcnt      ecx, edx                    ; Count bits in bitmap.\n        xor         r9, r9                      ; Clear r9.\n\n        align 16\n\n;\n; Top of the main comparison loop.  The bitmap will be present in rdx.  Count\n; trailing zeros of the bitmap, and then add in the shift count, producing an\n; index (rax) we can use to load the corresponding slot.\n;\n; Register usage at top of loop:\n;\n;   rax - Index.\n;\n;   rcx - Loop counter.\n;\n;   rdx - Bitmap initially, then slot length.\n;\n;   r9 - Shift count.\n;\n;   r10 - Search length.\n;\n;   r11 - String length.\n;\n\nPfx20:  tzcnt       r8d, edx                    ; Count trailing zeros.\n        mov         eax, r8d                    ; Copy tzcnt to rax,\n        add         rax, r9                     ; Add shift to create index.\n        inc         r8                          ; tzcnt + 1\n        shrx        rdx, rdx, r8                ; Reposition bitmap.\n        vpinsrd     xmm5, xmm5, edx, 2          ; Store bitmap, free up rdx.\n        xor         edx, edx                    ; Clear edx.\n        mov         r9, rax                     ; Copy index back to shift.\n        inc         r9                          ; Shift = Index + 1\n        vpinsrd     xmm5, xmm5, eax, 3          ; Store the raw index xmm5d[3].\n\n;\n; \"Scale\" the index (such that we can use it in a subsequent vmovdqa) by\n; shifting left by 4 (i.e. multiply by '(sizeof STRING_SLOT)', which is 16).\n;\n; Then, load the string table slot at this index into xmm1, then shift rax back.\n;\n\n        shl         eax, 4\n        vpextrq     r8, xmm2, 0\n        vmovdqa     xmm1, xmmword ptr [rax + StringTable.Slots[r8]]\n        shr         eax, 4\n\n;\n; The search string's first 16 characters are already in xmm0.  Compare this\n; against the slot that has just been loaded into xmm1, storing the result back\n; into xmm1.\n;\n\n        vpcmpeqb    xmm1, xmm1, xmm0            ; Compare search string to slot.\n\n;\n; Convert the XMM mask into a 32-bit representation, then zero high bits after\n; our \"search length\", which allows us to ignore the results of the comparison\n; above for bytes that were after the search string's length, if applicable.\n; Then, count the number of bits remaining, which tells us how many characters\n; we matched.\n;\n\n        vpmovmskb   r8d, xmm1                   ; Convert into mask.\n        bzhi        r8d, r8d, r10d              ; Zero high bits.\n        popcnt      r8d, r8d                    ; Count bits.\n\n;\n; Load the slot length into rdx.  As xmm3 already has all the slot lengths in\n; it, we can load rax (the current index) into xmm1 and use it to extract the\n; slot length via shuffle.  (The length will be in the lowest byte of xmm1\n; after the shuffle, which we can then vpextrb.)\n;\n\n        movd        xmm1, rax                   ; Load index into xmm1.\n        vpshufb     xmm1, xmm3, xmm1            ; Shuffle lengths.\n        vpextrb     rdx, xmm1, 0                ; Extract target length to rdx.\n\n;\n; If 16 characters matched, and the search string's length is longer than 16,\n; we're going to need to do a comparison of the remaining strings.\n;\n\n        cmp         r8w, 16                     ; Compare chars matched to 16.\n        je          short @F                    ; 16 chars matched.\n        jmp         Pfx30                       ; Less than 16 matched.\n\n;\n; All 16 characters matched.  If the slot length is greater than 16, we need\n; to do an inline memory comparison of the remaining bytes.  If it's 16 exactly,\n; then great, that's a slot match, we're done.\n;\n\n@@:     cmp         dl, 16                      ; Compare length to 16.\n        ja          Pfx50                       ; Length is &gt; 16.\n        je          short Pfx35                 ; Lengths match!\n                                                ; Length &lt;= 16, fall through...\n\n;\n; Less than or equal to 16 characters were matched.  Compare this against the\n; length of the slot; if equal, this is a match, if not, no match, continue.\n;\n\nPfx30:  cmp         r8b, dl                     ; Compare against slot length.\n        jne         @F                          ; No match found.\n        jmp         short Pfx35                 ; Match found!\n\n;\n; No match against this slot, decrement counter and either continue the loop\n; or terminate the search and return no match.\n;\n\n@@:     vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.\n        dec         cx                          ; Decrement counter.\n        jnz         Pfx20                       ; cx != 0, continue.\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        ret                                     ; Return.\n\n;\n; Pfx35 and Pfx40 are the jump targets for when the prefix match succeeds.  The\n; former is used when we need to copy the number of characters matched from r8\n; back to rax.  The latter jump target doesn't require this.\n;\n\nPfx35:  mov         rax, r8                     ; Copy numbers of chars matched.\n\n;\n; Load the match parameter back into r8 and test to see if it's not-NULL, in\n; which case we need to fill out a STRING_MATCH structure for the match.\n;\n\nPfx40:  vpextrq     r8, xmm5, 0                 ; Extract StringMatch.\n        test        r8, r8                      ; Is NULL?\n        jnz         short @F                    ; Not zero, need to fill out.\n\n;\n; StringMatch is NULL, we're done. Extract index of match back into rax and ret.\n;\n\n        vpextrd     eax, xmm5, 3                ; Extract raw index for match.\n        ret                                     ; StringMatch == NULL, finish.\n\n;\n; StringMatch is not NULL.  Fill out characters matched (currently rax), then\n; reload the index from xmm5 into rax and save.\n;\n\n@@:     mov         byte ptr StringMatch.NumberOfMatchedCharacters[r8], al\n        vpextrd     eax, xmm5, 3                ; Extract raw index for match.\n        mov         byte ptr StringMatch.Index[r8], al\n\n;\n; Final step, loading the address of the string in the string array.  This\n; involves going through the StringTable, so we need to load that parameter\n; back into rcx, then resolving the string array address via pStringArray,\n; then the relevant STRING offset within the StringArray.Strings structure.\n;\n\n        vpextrq     rcx, xmm2, 0            ; Extract StringTable into rcx.\n        mov         rcx, StringTable.pStringArray[rcx] ; Load string array.\n\n        shl         eax, 4                  ; Scale the index; sizeof STRING=16.\n        lea         rdx, [rax + StringArray.Strings[rcx]] ; Resolve address.\n        mov         qword ptr StringMatch.String[r8], rdx ; Save STRING ptr.\n        shr         eax, 4                  ; Revert the scaling.\n\n        ret\n\n;\n; 16 characters matched and the length of the underlying slot is greater than\n; 16, so we need to do a little memory comparison to determine if the search\n; string is a prefix match.\n;\n; The slot length is stored in rax at this point, and the search string's\n; length is stored in r11.  We know that the search string's length will\n; always be longer than or equal to the slot length at this point, so, we\n; can subtract 16 (currently stored in r10) from rax, and use the resulting\n; value as a loop counter, comparing the search string with the underlying\n; string slot byte-by-byte to determine if there's a match.\n;\n\nPfx50:  sub         rdx, r10                ; Subtract 16 from search length.\n\n;\n; Free up some registers by stashing their values into various xmm offsets.\n;\n\n        vpinsrb     xmm4, xmm4, ecx, 2      ; Free up rcx register.\n        mov         rcx, rdx                ; Free up rdx, rcx is now counter.\n\n;\n; Load the search string buffer and advance it 16 bytes.\n;\n\n        vpextrq     r11, xmm2, 1            ; Extract String into r11.\n        mov         r11, String.Buffer[r11] ; Load buffer address.\n        add         r11, r10                ; Advance buffer 16 bytes.\n\n;\n; Loading the slot is more involved as we have to go to the string table, then\n; the pStringArray pointer, then the relevant STRING offset within the string\n; array (which requires re-loading the index from xmm5d[3]), then the string\n; buffer from that structure.\n;\n\n        vpextrq     r8, xmm2, 0             ; Extract StringTable into r8.\n        mov         r8, StringTable.pStringArray[r8] ; Load string array.\n\n        shl         eax, 4                  ; Scale the index; sizeof STRING=16.\n\n        lea         r8, [rax + StringArray.Strings[r8]] ; Resolve address.\n        mov         r8, String.Buffer[r8]   ; Load string table buffer address.\n        add         r8, r10                 ; Advance buffer 16 bytes.\n\n        xor         eax, eax                ; Clear eax.\n\n;\n; We've got both buffer addresses + 16 bytes loaded in r11 and r8 respectively.\n; Do a byte-by-byte comparison.\n;\n\n        align 16\n@@:     mov         dl, byte ptr [rax + r11]    ; Load byte from search string.\n        cmp         dl, byte ptr [rax + r8]     ; Compare against target.\n        jne         short Pfx60                 ; If not equal, jump.\n\n;\n; The two bytes were equal, update rax, decrement rcx and potentially continue\n; the loop.\n;\n\n        inc         ax                          ; Increment index.\n        loopnz      @B                          ; Decrement cx and loop back.\n\n;\n; All bytes matched!  Add 16 (still in r10) back to rax such that it captures\n; how many characters we matched, and then jump to Pfx40 for finalization.\n;\n\n        add         rax, r10\n        jmp         Pfx40\n\n;\n; Byte comparisons were not equal.  Restore the rcx loop counter and decrement\n; it.  If it's zero, we have no more strings to compare, so we can do a quick\n; exit.  If there are still comparisons to be made, restore the other registers\n; we trampled then jump back to the start of the loop Pfx20.\n;\n\nPfx60:  vpextrb     rcx, xmm4, 2                ; Restore rcx counter.\n        dec         cx                          ; Decrement counter.\n        jnz         short @F                    ; Jump forward if not zero.\n\n;\n; No more comparisons remaining, return.\n;\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        ret                                     ; Return.\n\n;\n; More comparisons remain; restore the registers we clobbered and continue loop.\n;\n\n@@:     vpextrb     r10, xmm4, 1                ; Restore r10.\n        vpextrb     r11, xmm4, 0                ; Restore r11.\n        vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.\n        jmp         Pfx20                       ; Continue comparisons.\n\n        ;IACA_VC_END\n\n        LEAF_END   IsPrefixOfStringInTable_x64_4, _TEXT$00\n\n\n\nLet’s see how that stacks up against the existing version 2 of the assembly routine.\n\n\nBenchmark x64 4\n\n\n\nBenchmark x64 4\n\n\nNice, we’ve shaved an entire cycle off the negative match path! I say that both seriously and sarcastically. A single cycle, wow, stop the press! On the other hand, going from 8 cycles to 7 cycles is usually a lot harder than, say, going from 100,000 cycles to 80,000 cycles. We’re so close to the lower bound, additional cycle improvements are a lot like trying to get blood out of a stone.\n\n\n\nIsPrefixOfStringInTable_12\n← IsPrefixOfStringInTable_11 | IsPrefixOfStringInTable_13 →\nThe vptest fast-path exit definitely yielded a repeatable and measurable gain for the assembly version. Let’s replicate it in a C version.\n\nDiffFull\n\n\n% diff -u IsPrefixOfStringInTable_10.c IsPrefixOfStringInTable_12.c\n--- IsPrefixOfStringInTable_10.c        2018-04-26 13:28:06.006627100 -0400\n+++ IsPrefixOfStringInTable_12.c        2018-04-26 17:47:54.970331600 -0400\n@@ -19,7 +19,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_10(\n+IsPrefixOfStringInTable_12(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -32,8 +32,15 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This version is based off version 8, but rewrites the inner loop that\n-    checks for comparisons.\n+    This version is based off version 10, but with factors in the improvements\n+    made to version 4 of the x64 assembly version, thanks to suggestions from\n+    both Wojciech Mula (@pshufb) and Fabian Giesen (@rygorous).\n+\n+    Like version 11, we omit the vpxor to invert the lengths, but instead of\n+    an initial vpandn, we leverage the fact that vptest sets the carry flag\n+    if all 0s result from the expression: \"param1 and (not param2)\".  This\n+    allows us to do a fast-path early exit (like x64 version 2 does) if no\n+    match is found.\n\n Arguments:\n\n@@ -71,9 +78,7 @@\n     XMMWORD TableUniqueChars;\n     XMMWORD IncludeSlotsByUniqueChar;\n     XMMWORD IgnoreSlotsByLength;\n-    XMMWORD IncludeSlotsByLength;\n     XMMWORD IncludeSlots;\n-    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n     //\n     // Unconditionally do the following five operations before checking any of\n@@ -159,47 +164,58 @@\n     // N.B. Because we default the length of empty slots to 0x7f, they will\n     //      handily be included in the ignored set (i.e. their words will also\n     //      be set to 0xff), which means they'll also get filtered out when\n-    //      we invert the mask shortly after.\n+    //      we do the \"and not\" intersection with the include slots next.\n     //\n\n     IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n     //\n-    // Invert the result of the comparison; we want 0xff for slots to include\n-    // and 0x0 for slots to ignore (it's currently the other way around).  We\n-    // can achieve this by XOR'ing the result against our all-ones XMM register.\n+    // We can do a fast-path test for no match here via _mm_testc_si128(),\n+    // which is essentially equivalent to the following logic, just with\n+    // fewer instructions:\n     //\n-\n-    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n-\n-    //\n-    // We're now ready to intersect the two XMM registers to determine which\n-    // slots should still be included in the comparison (i.e. which slots have\n-    // the exact same unique character as the string and a length less than or\n-    // equal to the length of the search string).\n+    //      IncludeSlots = _mm_andnot_si128(IgnoreSlotsByLength,\n+    //                                      IncludeSlotsByUniqueChar);\n     //\n-\n-    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n-                                 IncludeSlotsByLength);\n-\n+    //      if (!IncludeSlots) {\n+    //          return NO_MATCH_FOUND;\n+    //      }\n     //\n-    // Generate a mask.\n     //\n\n-    Bitmap = _mm_movemask_epi8(IncludeSlots);\n-\n-    if (!Bitmap) {\n+    if (_mm_testc_si128(IgnoreSlotsByLength, IncludeSlotsByUniqueChar)) {\n\n         //\n-        // No bits were set, so there are no strings in this table starting\n-        // with the same character and of a lesser or equal length as the\n-        // search string.\n+        // No remaining slots were left after we intersected the slots with\n+        // matching unique characters with the inverted slots to ignore due\n+        // to length.  Thus, no prefix match was found.\n         //\n\n         return NO_MATCH_FOUND;\n     }\n\n     //\n+    // Continue with the remaining logic, including actually generating the\n+    // IncludeSlots, which we need for bitmap generation as part of our\n+    // comparison loop.\n+    //\n+    // As the IgnoreSlotsByLength XMM register is the inverse of what we want\n+    // at the moment (we want 0xff for slots to include, and 0x00 for slots\n+    // to ignore; it's currently the other way around), we use _mm_andnot_si128\n+    // instead of just _mm_and_si128.\n+    //\n+\n+    IncludeSlots = _mm_andnot_si128(IgnoreSlotsByLength,\n+                                    IncludeSlotsByUniqueChar);\n+\n+    //\n+    // Generate a mask, count the number of bits, and initialize the search\n+    // length.\n+    //\n+\n+    Bitmap = _mm_movemask_epi8(IncludeSlots);\n+\n+    //\n     // Calculate the \"search length\" of the incoming string, which ensures we\n     // only compare up to the first 16 characters.\n     //\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_12(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This version is based off version 10, but with factors in the improvements\n    made to version 4 of the x64 assembly version, thanks to suggestions from\n    both Wojciech Mula (@pshufb) and Fabian Giesen (@rygorous).\n\n    Like version 11, we omit the vpxor to invert the lengths, but instead of\n    an initial vpandn, we leverage the fact that vptest sets the carry flag\n    if all 0s result from the expression: \"param1 and (not param2)\".  This\n    allows us to do a fast-path early exit (like x64 version 2 does) if no\n    match is found.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Count;\n    ULONG Length;\n    ULONG Index;\n    ULONG Shift = 0;\n    ULONG CharactersMatched;\n    ULONG NumberOfTrailingZeros;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlots;\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we do the \"and not\" intersection with the include slots next.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // We can do a fast-path test for no match here via _mm_testc_si128(),\n    // which is essentially equivalent to the following logic, just with\n    // fewer instructions:\n    //\n    //      IncludeSlots = _mm_andnot_si128(IgnoreSlotsByLength,\n    //                                      IncludeSlotsByUniqueChar);\n    //\n    //      if (!IncludeSlots) {\n    //          return NO_MATCH_FOUND;\n    //      }\n    //\n    //\n\n    if (_mm_testc_si128(IgnoreSlotsByLength, IncludeSlotsByUniqueChar)) {\n\n        //\n        // No remaining slots were left after we intersected the slots with\n        // matching unique characters with the inverted slots to ignore due\n        // to length.  Thus, no prefix match was found.\n        //\n\n        return NO_MATCH_FOUND;\n    }\n\n    //\n    // Continue with the remaining logic, including actually generating the\n    // IncludeSlots, which we need for bitmap generation as part of our\n    // comparison loop.\n    //\n    // As the IgnoreSlotsByLength XMM register is the inverse of what we want\n    // at the moment (we want 0xff for slots to include, and 0x00 for slots\n    // to ignore; it's currently the other way around), we use _mm_andnot_si128\n    // instead of just _mm_and_si128.\n    //\n\n    IncludeSlots = _mm_andnot_si128(IgnoreSlotsByLength,\n                                    IncludeSlotsByUniqueChar);\n\n    //\n    // Generate a mask, count the number of bits, and initialize the search\n    // length.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    //\n    // Calculate the \"search length\" of the incoming string, which ensures we\n    // only compare up to the first 16 characters.\n    //\n\n    SearchLength = min(String-&gt;Length, 16);\n\n    //\n    // A popcount against the mask will tell us how many slots we matched, and\n    // thus, need to compare.\n    //\n\n    Count = __popcnt(Bitmap);\n\n    do {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap and adding the amount we've already shifted by.\n        //\n\n        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n        Index = NumberOfTrailingZeros + Shift;\n\n        //\n        // Shift the bitmap right, past the zeros and the 1 that was just found,\n        // such that it's positioned correctly for the next loop's tzcnt. Update\n        // the shift count accordingly.\n        //\n\n        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n        Shift = Index + 1;\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched &lt; Length && Length &lt;= 16) {\n\n            //\n            // The slot length is longer than the number of characters matched\n            // from the search string; this isn't a prefix match.  Continue.\n            //\n\n            continue;\n        }\n\n        if (Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n            }\n        }\n\n        //\n        // This slot is a prefix match.  Fill out the Match structure if the\n        // caller provided a non-NULL pointer, then return the index of the\n        // match.\n        //\n\n        if (ARGUMENT_PRESENT(Match)) {\n\n            Match-&gt;Index = (BYTE)Index;\n            Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n            Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n        }\n\n        return (STRING_TABLE_INDEX)Index;\n\n    } while (--Count);\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\n\n\nBenchmark 12\n\n\n\nBenchmark 12\n\n\nEh, there’s not much in this one. The negative match fast path is basically identical, and the normal prefix matches are a tiny bit slower.\n\n\n\nIsPrefixOfStringInTable_13\n← IsPrefixOfStringInTable_12 | IsPrefixOfStringInTable_14 →\nAnother tip from Fabian: we can tweak the loop logic further. Instead of shifting the bitmap right each iteration (and keeping a separate shift count), we can just leverage the blsr intrinsic, which stands for reset lowest set bit, and is equivalent to doing x & (x -1). This allows us to tweak the loop organization as well, such that we can simply do while (Bitmap) { } instead of the do { } while (--Count) approach we’ve been using.\n\nDiffFull\n\n\n% diff -u IsPrefixOfStringInTable_10.c IsPrefixOfStringInTable_13.c\n--- IsPrefixOfStringInTable_10.c        2018-04-26 18:22:23.926168500 -0400\n+++ IsPrefixOfStringInTable_13.c        2018-04-26 19:16:34.926170200 -0400\n@@ -19,7 +19,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_10(\n+IsPrefixOfStringInTable_13(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -32,8 +32,10 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This version is based off version 8, but rewrites the inner loop that\n-    checks for comparisons.\n+    This version is based off version 10, but does away with the bitmap\n+    shifting logic and `do { } while (--Count)` loop, instead simply using\n+    blsr in conjunction with `while (Bitmap) { }`.  Credit goes to Fabian\n+    Giesen (@rygorous) for pointing this approach out.\n\n Arguments:\n\n@@ -54,12 +56,9 @@\n {\n     ULONG Bitmap;\n     ULONG Mask;\n-    ULONG Count;\n     ULONG Length;\n     ULONG Index;\n-    ULONG Shift = 0;\n     ULONG CharactersMatched;\n-    ULONG NumberOfTrailingZeros;\n     ULONG SearchLength;\n     PSTRING TargetString;\n     STRING_SLOT Slot;\n@@ -206,31 +205,26 @@\n\n     SearchLength = min(String-&gt;Length, 16);\n\n-    //\n-    // A popcount against the mask will tell us how many slots we matched, and\n-    // thus, need to compare.\n-    //\n-\n-    Count = __popcnt(Bitmap);\n-\n-    do {\n+    while (Bitmap) {\n\n         //\n         // Extract the next index by counting the number of trailing zeros left\n-        // in the bitmap and adding the amount we've already shifted by.\n+        // in the bitmap.\n         //\n\n-        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n-        Index = NumberOfTrailingZeros + Shift;\n+        Index = _tzcnt_u32(Bitmap);\n\n         //\n-        // Shift the bitmap right, past the zeros and the 1 that was just found,\n-        // such that it's positioned correctly for the next loop's tzcnt. Update\n-        // the shift count accordingly.\n+        // Clear the bitmap's lowest set bit, such that it's ready for the next\n+        // loop's tzcnt if no match is found in this iteration.  Equivalent to\n+        //\n+        //      Bitmap &= Bitmap - 1;\n+        //\n+        // (Which the optimizer will convert into a blsr instruction anyway in\n+        //  non-debug builds.  But it's nice to be explicit.)\n         //\n\n-        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n-        Shift = Index + 1;\n+        Bitmap = _blsr_u32(Bitmap);\n\n         //\n         // Load the slot and its length.\n@@ -313,7 +307,7 @@\n\n         return (STRING_TABLE_INDEX)Index;\n\n-    } while (--Count);\n+    }\n\n     //\n     // If we get here, we didn't find a match.\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_13(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This version is based off version 10, but does away with the bitmap\n    shifting logic and `do { } while (--Count)` loop, instead simply using\n    blsr in conjunction with `while (Bitmap) { }`.  Credit goes to Fabian\n    Giesen (@rygorous) for pointing this approach out.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Length;\n    ULONG Index;\n    ULONG CharactersMatched;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlotsByLength;\n    XMMWORD IncludeSlots;\n    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we invert the mask shortly after.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // Invert the result of the comparison; we want 0xff for slots to include\n    // and 0x0 for slots to ignore (it's currently the other way around).  We\n    // can achieve this by XOR'ing the result against our all-ones XMM register.\n    //\n\n    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n\n    //\n    // We're now ready to intersect the two XMM registers to determine which\n    // slots should still be included in the comparison (i.e. which slots have\n    // the exact same unique character as the string and a length less than or\n    // equal to the length of the search string).\n    //\n\n    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n                                 IncludeSlotsByLength);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    if (!Bitmap) {\n\n        //\n        // No bits were set, so there are no strings in this table starting\n        // with the same character and of a lesser or equal length as the\n        // search string.\n        //\n\n        return NO_MATCH_FOUND;\n    }\n\n    //\n    // Calculate the \"search length\" of the incoming string, which ensures we\n    // only compare up to the first 16 characters.\n    //\n\n    SearchLength = min(String-&gt;Length, 16);\n\n    while (Bitmap) {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap.\n        //\n\n        Index = _tzcnt_u32(Bitmap);\n\n        //\n        // Clear the bitmap's lowest set bit, such that it's ready for the next\n        // loop's tzcnt if no match is found in this iteration.  Equivalent to\n        //\n        //      Bitmap &= Bitmap - 1;\n        //\n        // (Which the optimizer will convert into a blsr instruction anyway in\n        //  non-debug builds.  But it's nice to be explicit.)\n        //\n\n        Bitmap = _blsr_u32(Bitmap);\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched &lt; Length && Length &lt;= 16) {\n\n            //\n            // The slot length is longer than the number of characters matched\n            // from the search string; this isn't a prefix match.  Continue.\n            //\n\n            continue;\n        }\n\n        if (Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n            }\n        }\n\n        //\n        // This slot is a prefix match.  Fill out the Match structure if the\n        // caller provided a non-NULL pointer, then return the index of the\n        // match.\n        //\n\n        if (ARGUMENT_PRESENT(Match)) {\n\n            Match-&gt;Index = (BYTE)Index;\n            Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n            Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n        }\n\n        return (STRING_TABLE_INDEX)Index;\n\n    }\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\nI like this change. It was a great suggestion from Fabian. Let’s see how it performs. Hopefully it’ll do slightly better at prefix matching, given that we’re effectively reducing the number of instructions required as part of the string comparison logic.\n\n\nBenchmark 13\n\n\n\nBenchmark 13\n\n\nAh! A measurable, repeatable speed-up! Excellent!\n\n\n\nIsPrefixOfStringInTable_14\n← IsPrefixOfStringInTable_13 | IsPrefixOfStringInTable_15 →\nLet’s give the C version the same chance as the assembly version with regards to negative matching; we’ll take version 13 above and factor in the vptest logic from version 12.\n\nDiff (14 vs 13)Diff (14 vs 12)Full (14)\n\n\n% diff -u IsPrefixOfStringInTable_13.c IsPrefixOfStringInTable_14.c\n--- IsPrefixOfStringInTable_13.c        2018-04-26 19:16:34.926170200 -0400\n+++ IsPrefixOfStringInTable_14.c        2018-04-26 19:32:30.674199200 -0400\n@@ -19,7 +19,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_13(\n+IsPrefixOfStringInTable_14(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -32,10 +32,8 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This version is based off version 10, but does away with the bitmap\n-    shifting logic and `do { } while (--Count)` loop, instead simply using\n-    blsr in conjunction with `while (Bitmap) { }`.  Credit goes to Fabian\n-    Giesen (@rygorous) for pointing this approach out.\n+    This version combines the altered bitmap logic from version 13 with the\n+    fast-path _mm_testc_si128() exit from version 12.\n\n Arguments:\n\n@@ -70,9 +68,7 @@\n     XMMWORD TableUniqueChars;\n     XMMWORD IncludeSlotsByUniqueChar;\n     XMMWORD IgnoreSlotsByLength;\n-    XMMWORD IncludeSlotsByLength;\n     XMMWORD IncludeSlots;\n-    const XMMWORD AllOnesXmm = _mm_set1_epi8(0xff);\n\n     //\n     // Unconditionally do the following five operations before checking any of\n@@ -164,22 +160,43 @@\n     IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n     //\n-    // Invert the result of the comparison; we want 0xff for slots to include\n-    // and 0x0 for slots to ignore (it's currently the other way around).  We\n-    // can achieve this by XOR'ing the result against our all-ones XMM register.\n+    // We can do a fast-path test for no match here via _mm_testc_si128(),\n+    // which is essentially equivalent to the following logic, just with\n+    // fewer instructions:\n     //\n+    //      IncludeSlots = _mm_andnot_si128(IgnoreSlotsByLength,\n+    //                                      IncludeSlotsByUniqueChar);\n+    //\n+    //      if (!IncludeSlots) {\n+    //          return NO_MATCH_FOUND;\n+    //      }\n+    //\n+    //\n+\n+    if (_mm_testc_si128(IgnoreSlotsByLength, IncludeSlotsByUniqueChar)) {\n\n-    IncludeSlotsByLength = _mm_xor_si128(IgnoreSlotsByLength, AllOnesXmm);\n+        //\n+        // No remaining slots were left after we intersected the slots with\n+        // matching unique characters with the inverted slots to ignore due\n+        // to length.  Thus, no prefix match was found.\n+        //\n+\n+        return NO_MATCH_FOUND;\n+    }\n\n     //\n-    // We're now ready to intersect the two XMM registers to determine which\n-    // slots should still be included in the comparison (i.e. which slots have\n-    // the exact same unique character as the string and a length less than or\n-    // equal to the length of the search string).\n+    // Continue with the remaining logic, including actually generating the\n+    // IncludeSlots, which we need for bitmap generation as part of our\n+    // comparison loop.\n+    //\n+    // As the IgnoreSlotsByLength XMM register is the inverse of what we want\n+    // at the moment (we want 0xff for slots to include, and 0x00 for slots\n+    // to ignore; it's currently the other way around), we use _mm_andnot_si128\n+    // instead of just _mm_and_si128.\n     //\n\n-    IncludeSlots = _mm_and_si128(IncludeSlotsByUniqueChar,\n-                                 IncludeSlotsByLength);\n+    IncludeSlots = _mm_andnot_si128(IgnoreSlotsByLength,\n+                                    IncludeSlotsByUniqueChar);\n\n     //\n     // Generate a mask.\n@@ -187,17 +204,6 @@\n\n     Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n-    if (!Bitmap) {\n-\n-        //\n-        // No bits were set, so there are no strings in this table starting\n-        // with the same character and of a lesser or equal length as the\n-        // search string.\n-        //\n-\n-        return NO_MATCH_FOUND;\n-    }\n-\n     //\n     // Calculate the \"search length\" of the incoming string, which ensures we\n     // only compare up to the first 16 characters.\n\n\n% diff -u IsPrefixOfStringInTable_12.c IsPrefixOfStringInTable_14.c\n--- IsPrefixOfStringInTable_12.c        2018-04-26 17:47:54.970331600 -0400\n+++ IsPrefixOfStringInTable_14.c        2018-04-26 19:32:30.674199200 -0400\n@@ -19,7 +19,7 @@\n\n _Use_decl_annotations_\n STRING_TABLE_INDEX\n-IsPrefixOfStringInTable_12(\n+IsPrefixOfStringInTable_14(\n     PSTRING_TABLE StringTable,\n     PSTRING String,\n     PSTRING_MATCH Match\n@@ -32,15 +32,8 @@\n     search string.  That is, whether any string in the table \"starts with\n     or is equal to\" the search string.\n\n-    This version is based off version 10, but with factors in the improvements\n-    made to version 4 of the x64 assembly version, thanks to suggestions from\n-    both Wojciech Mula (@pshufb) and Fabian Giesen (@rygorous).\n-\n-    Like version 11, we omit the vpxor to invert the lengths, but instead of\n-    an initial vpandn, we leverage the fact that vptest sets the carry flag\n-    if all 0s result from the expression: \"param1 and (not param2)\".  This\n-    allows us to do a fast-path early exit (like x64 version 2 does) if no\n-    match is found.\n+    This version combines the altered bitmap logic from version 13 with the\n+    fast-path _mm_testc_si128() exit from version 12.\n\n Arguments:\n\n@@ -61,12 +54,9 @@\n {\n     ULONG Bitmap;\n     ULONG Mask;\n-    ULONG Count;\n     ULONG Length;\n     ULONG Index;\n-    ULONG Shift = 0;\n     ULONG CharactersMatched;\n-    ULONG NumberOfTrailingZeros;\n     ULONG SearchLength;\n     PSTRING TargetString;\n     STRING_SLOT Slot;\n@@ -118,7 +108,7 @@\n     // Load the first 16-bytes of the search string into an XMM register.\n     //\n\n-    Search.CharsXmm = _mm_load_si128((PXMMWORD)String-&gt;Buffer);\n+    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n     //\n     // Broadcast the search string's unique characters according to the string\n@@ -164,7 +154,7 @@\n     // N.B. Because we default the length of empty slots to 0x7f, they will\n     //      handily be included in the ignored set (i.e. their words will also\n     //      be set to 0xff), which means they'll also get filtered out when\n-    //      we do the \"and not\" intersection with the include slots next.\n+    //      we invert the mask shortly after.\n     //\n\n     IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n@@ -209,8 +199,7 @@\n                                     IncludeSlotsByUniqueChar);\n\n     //\n-    // Generate a mask, count the number of bits, and initialize the search\n-    // length.\n+    // Generate a mask.\n     //\n\n     Bitmap = _mm_movemask_epi8(IncludeSlots);\n@@ -222,31 +211,26 @@\n\n     SearchLength = min(String-&gt;Length, 16);\n\n-    //\n-    // A popcount against the mask will tell us how many slots we matched, and\n-    // thus, need to compare.\n-    //\n-\n-    Count = __popcnt(Bitmap);\n-\n-    do {\n+    while (Bitmap) {\n\n         //\n         // Extract the next index by counting the number of trailing zeros left\n-        // in the bitmap and adding the amount we've already shifted by.\n+        // in the bitmap.\n         //\n\n-        NumberOfTrailingZeros = _tzcnt_u32(Bitmap);\n-        Index = NumberOfTrailingZeros + Shift;\n+        Index = _tzcnt_u32(Bitmap);\n\n         //\n-        // Shift the bitmap right, past the zeros and the 1 that was just found,\n-        // such that it's positioned correctly for the next loop's tzcnt. Update\n-        // the shift count accordingly.\n+        // Clear the bitmap's lowest set bit, such that it's ready for the next\n+        // loop's tzcnt if no match is found in this iteration.  Equivalent to\n+        //\n+        //      Bitmap &= Bitmap - 1;\n+        //\n+        // (Which the optimizer will convert into a blsr instruction anyway in\n+        //  non-debug builds.  But it's nice to be explicit.)\n         //\n\n-        Bitmap &gt;&gt;= (NumberOfTrailingZeros + 1);\n-        Shift = Index + 1;\n+        Bitmap = _blsr_u32(Bitmap);\n\n         //\n         // Load the slot and its length.\n@@ -329,7 +313,7 @@\n\n         return (STRING_TABLE_INDEX)Index;\n\n-    } while (--Count);\n+    }\n\n     //\n     // If we get here, we didn't find a match.\n\n\n_Use_decl_annotations_\nSTRING_TABLE_INDEX\nIsPrefixOfStringInTable_14(\n    PSTRING_TABLE StringTable,\n    PSTRING String,\n    PSTRING_MATCH Match\n    )\n/*++\n\nRoutine Description:\n\n    Searches a string table to see if any strings \"prefix match\" the given\n    search string.  That is, whether any string in the table \"starts with\n    or is equal to\" the search string.\n\n    This version combines the altered bitmap logic from version 13 with the\n    fast-path _mm_testc_si128() exit from version 12.\n\nArguments:\n\n    StringTable - Supplies a pointer to a STRING_TABLE struct.\n\n    String - Supplies a pointer to a STRING struct that contains the string to\n        search for.\n\n    Match - Optionally supplies a pointer to a variable that contains the\n        address of a STRING_MATCH structure.  This will be populated with\n        additional details about the match if a non-NULL pointer is supplied.\n\nReturn Value:\n\n    Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n\n--*/\n{\n    ULONG Bitmap;\n    ULONG Mask;\n    ULONG Length;\n    ULONG Index;\n    ULONG CharactersMatched;\n    ULONG SearchLength;\n    PSTRING TargetString;\n    STRING_SLOT Slot;\n    STRING_SLOT Search;\n    STRING_SLOT Compare;\n    SLOT_LENGTHS Lengths;\n    XMMWORD LengthXmm;\n    XMMWORD UniqueChar;\n    XMMWORD TableUniqueChars;\n    XMMWORD IncludeSlotsByUniqueChar;\n    XMMWORD IgnoreSlotsByLength;\n    XMMWORD IncludeSlots;\n\n    //\n    // Unconditionally do the following five operations before checking any of\n    // the results and determining how the search should proceed:\n    //\n    //  1. Load the search string into an Xmm register, and broadcast the\n    //     character indicated by the unique character index (relative to\n    //     other strings in the table) across a second Xmm register.\n    //\n    //  2. Load the string table's unique character array into an Xmm register.\n    //\n    //  3. Broadcast the search string's length into an XMM register.\n    //\n    //  3. Load the string table's slot lengths array into an XMM register.\n    //\n    //  4. Compare the unique character from step 1 to the string table's unique\n    //     character array set up in step 2.  The result of this comparison\n    //     will produce an XMM register with each byte set to either 0xff if\n    //     the unique character was found, or 0x0 if it wasn't.\n    //\n    //  5. Compare the search string's length from step 3 to the string table's\n    //     slot length array set up in step 3.  This allows us to identify the\n    //     slots that have strings that are of lesser or equal length to our\n    //     search string.  As we're doing a prefix search, we can ignore any\n    //     slots longer than our incoming search string.\n    //\n    // We do all five of these operations up front regardless of whether or not\n    // they're strictly necessary.  That is, if the unique character isn't in\n    // the unique character array, we don't need to load array lengths -- and\n    // vice versa.  However, we assume the benefits afforded by giving the CPU\n    // a bunch of independent things to do unconditionally up-front outweigh\n    // the cost of putting in branches and conditionally loading things if\n    // necessary.\n    //\n\n    //\n    // Load the first 16-bytes of the search string into an XMM register.\n    //\n\n    Search.CharsXmm = _mm_loadu_si128((PXMMWORD)String-&gt;Buffer);\n\n    //\n    // Broadcast the search string's unique characters according to the string\n    // table's unique character index.\n    //\n\n    UniqueChar = _mm_shuffle_epi8(Search.CharsXmm,\n                                  StringTable-&gt;UniqueIndex.IndexXmm);\n\n    //\n    // Load the slot length array into an XMM register.\n    //\n\n    Lengths.SlotsXmm = _mm_load_si128(&StringTable-&gt;Lengths.SlotsXmm);\n\n    //\n    // Load the string table's unique character array into an XMM register.\n    //\n\n    TableUniqueChars = _mm_load_si128(&StringTable-&gt;UniqueChars.CharsXmm);\n\n    //\n    // Broadcast the search string's length into an XMM register.\n    //\n\n    LengthXmm.m128i_u8[0] = (BYTE)String-&gt;Length;\n    LengthXmm = _mm_broadcastb_epi8(LengthXmm);\n\n    //\n    // Compare the search string's unique character with all of the unique\n    // characters of strings in the table, saving the results into an XMM\n    // register.  This comparison will indicate which slots we can ignore\n    // because the characters at a given index don't match.  Matched slots\n    // will be 0xff, unmatched slots will be 0x0.\n    //\n\n    IncludeSlotsByUniqueChar = _mm_cmpeq_epi8(UniqueChar, TableUniqueChars);\n\n    //\n    // Find all slots that are longer than the incoming string length, as these\n    // are the ones we're going to exclude from any prefix match.\n    //\n    // N.B. Because we default the length of empty slots to 0x7f, they will\n    //      handily be included in the ignored set (i.e. their words will also\n    //      be set to 0xff), which means they'll also get filtered out when\n    //      we invert the mask shortly after.\n    //\n\n    IgnoreSlotsByLength = _mm_cmpgt_epi8(Lengths.SlotsXmm, LengthXmm);\n\n    //\n    // We can do a fast-path test for no match here via _mm_testc_si128(),\n    // which is essentially equivalent to the following logic, just with\n    // fewer instructions:\n    //\n    //      IncludeSlots = _mm_andnot_si128(IgnoreSlotsByLength,\n    //                                      IncludeSlotsByUniqueChar);\n    //\n    //      if (!IncludeSlots) {\n    //          return NO_MATCH_FOUND;\n    //      }\n    //\n    //\n\n    if (_mm_testc_si128(IgnoreSlotsByLength, IncludeSlotsByUniqueChar)) {\n\n        //\n        // No remaining slots were left after we intersected the slots with\n        // matching unique characters with the inverted slots to ignore due\n        // to length.  Thus, no prefix match was found.\n        //\n\n        return NO_MATCH_FOUND;\n    }\n\n    //\n    // Continue with the remaining logic, including actually generating the\n    // IncludeSlots, which we need for bitmap generation as part of our\n    // comparison loop.\n    //\n    // As the IgnoreSlotsByLength XMM register is the inverse of what we want\n    // at the moment (we want 0xff for slots to include, and 0x00 for slots\n    // to ignore; it's currently the other way around), we use _mm_andnot_si128\n    // instead of just _mm_and_si128.\n    //\n\n    IncludeSlots = _mm_andnot_si128(IgnoreSlotsByLength,\n                                    IncludeSlotsByUniqueChar);\n\n    //\n    // Generate a mask.\n    //\n\n    Bitmap = _mm_movemask_epi8(IncludeSlots);\n\n    //\n    // Calculate the \"search length\" of the incoming string, which ensures we\n    // only compare up to the first 16 characters.\n    //\n\n    SearchLength = min(String-&gt;Length, 16);\n\n    while (Bitmap) {\n\n        //\n        // Extract the next index by counting the number of trailing zeros left\n        // in the bitmap.\n        //\n\n        Index = _tzcnt_u32(Bitmap);\n\n        //\n        // Clear the bitmap's lowest set bit, such that it's ready for the next\n        // loop's tzcnt if no match is found in this iteration.  Equivalent to\n        //\n        //      Bitmap &= Bitmap - 1;\n        //\n        // (Which the optimizer will convert into a blsr instruction anyway in\n        //  non-debug builds.  But it's nice to be explicit.)\n        //\n\n        Bitmap = _blsr_u32(Bitmap);\n\n        //\n        // Load the slot and its length.\n        //\n\n        Slot.CharsXmm = _mm_load_si128(&StringTable-&gt;Slots[Index].CharsXmm);\n        Length = Lengths.Slots[Index];\n\n        //\n        // Compare the slot to the search string.\n        //\n\n        Compare.CharsXmm = _mm_cmpeq_epi8(Slot.CharsXmm, Search.CharsXmm);\n\n        //\n        // Create a mask of the comparison, then filter out high bits from the\n        // search string's length (which is capped at 16).  (This shouldn't be\n        // technically necessary as the string array buffers should have been\n        // calloc'd and zeroed, but optimizing compilers can often ignore the\n        // zeroing request -- which can produce some bizarre results where the\n        // debug build is correct (because the buffers were zeroed) but the\n        // release build fails because the zeroing got ignored and there are\n        // junk bytes past the NULL terminator, which get picked up in our\n        // 128-bit loads.)\n        //\n\n        Mask = _bzhi_u32(_mm_movemask_epi8(Compare.CharsXmm), SearchLength);\n\n        //\n        // Count how many characters matched.\n        //\n\n        CharactersMatched = __popcnt(Mask);\n\n        if ((USHORT)CharactersMatched &lt; Length && Length &lt;= 16) {\n\n            //\n            // The slot length is longer than the number of characters matched\n            // from the search string; this isn't a prefix match.  Continue.\n            //\n\n            continue;\n        }\n\n        if (Length &gt; 16) {\n\n            //\n            // The first 16 characters in the string matched against this\n            // slot, and the slot is oversized (longer than 16 characters),\n            // so do a direct comparison between the remaining buffers.\n            //\n\n            TargetString = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n            CharactersMatched = IsPrefixMatch(String, TargetString, 16);\n\n            if (CharactersMatched == NO_MATCH_FOUND) {\n\n                //\n                // The prefix match failed, continue our search.\n                //\n\n                continue;\n            }\n        }\n\n        //\n        // This slot is a prefix match.  Fill out the Match structure if the\n        // caller provided a non-NULL pointer, then return the index of the\n        // match.\n        //\n\n        if (ARGUMENT_PRESENT(Match)) {\n\n            Match-&gt;Index = (BYTE)Index;\n            Match-&gt;NumberOfMatchedCharacters = (BYTE)CharactersMatched;\n            Match-&gt;String = &StringTable-&gt;pStringArray-&gt;Strings[Index];\n\n        }\n\n        return (STRING_TABLE_INDEX)Index;\n\n    }\n\n    //\n    // If we get here, we didn't find a match.\n    //\n\n    //IACA_VC_END();\n\n    return NO_MATCH_FOUND;\n}\n\n\n\nWe’re really clutching at straws here obviously with regards to trying to eke out more performance. The _mm_testc_si128() alteration was a tiny bit slower for version 12 across the board. However, the vptest (which is the underlying assembly instruction that maps to the _mm_testc_si128() intrinsic) version 4 of our assembly was definitely a little bit faster than the other versions. Let’s see how our final C version performs.\n\n\nBenchmark 14\n\n\n\nBenchmark 14\n\n\nWelp, at least it’s consistent! Like version 12, the _mm_testc_si128() change doesn’t really offer a compelling improvement for version 14. That makes version 13 officially our fastest C implementation for round 2.\n\n\nIsPrefixOfStringInTable_x64_5\n← IsPrefixOfStringInTable_x64_4 | IsPrefixOfStringInTable_x64_6 →\nBefore we conclude round 2, let’s see if we can eke any more performance out of the negative match fast path of our fastest assembly version so far: version 4. For this step, I’m going to leverage Intel Architecture Code Analyzer, or IACA, for short.\nThis is a handy little static analysis tool that can provide useful information for fine-tuning performance-sensitive code. Let’s take a look at the output from IACA for our assembly version 4. To do this, I uncomment the two macros, IACA_VC_START and IACA_VC_END, which reside at the start and end of the negative match logic. These macros are defined in StringTable.inc, and look like this:\nIACA_VC_START macro Name\n\n        mov     byte ptr gs:[06fh], 06fh\n\n        endm\n\nIACA_VC_END macro Name\n\n        mov     byte ptr gs:[0deh], 0deh\n\n        endm\nThe equivalent versions for C are defined in Rtl.h, and look like this:\n//\n// Define start/end markers for IACA.\n//\n\n#define IACA_VC_START() __writegsbyte(111, 111)\n#define IACA_VC_END()   __writegsbyte(222, 222)\nYou may have noticed commented-out versions of these macros in both the C and assembly code. What they do is emit a specific byte pattern in the instruction byte code that the IACA tool can detect. You place the start and end markers around the code you’re interested in, recompile it, then run IACA against the final executable (or library).\nLet’s see what happens when we do this for our version 4 assembly routine. I’ll include the relevant assembly snippet, reformatted into a more concise fashion, followed by the IACA output (also reformatted into a more concise fashion):\n\nAssemblyIACA\n\n\nmov      rax,  String.Buffer[rdx]                       ; Load address of string buffer.\nvmovdqu  xmm0, xmmword ptr [rax]                        ; Load search buffer.\nvmovdqa  xmm1, xmmword ptr StringTable.UniqueIndex[rcx] ; Load indexes.\nvpshufb  xmm5, xmm0, xmm1                               ; Rearrange string by uniq. ix.\nvmovdqa  xmm2, xmmword ptr StringTable.UniqueChars[rcx] ; Load unique chars.\nvpcmpeqb xmm5, xmm5, xmm2                               ; Compare unique chars.\nvmovdqa  xmm3, xmmword ptr StringTable.Lengths[rcx]     ; Load table lengths.\nvpbroadcastb xmm4, byte ptr String.Length[rdx]          ; Broadcast string length.\nvpcmpgtb xmm1, xmm3, xmm4                               ; Identify long slots.\nvptest   xmm1, xmm5                                     ; Unique slots AND (!long slots).\njnc      short Pfx10                                    ; CY=0, continue with routine.\nxor      eax, eax                                       ; CY=1, no match.  Clear rax.\nnot      al                                             ; al = -1 (NO_MATCH_FOUND)\nret                                                     ; Return NO_MATCH_FOUND\n\n\nS:\\Source\\tracer&gt;iaca x64\\Release\\StringTable2.dll\nIntel(R) Architecture Code Analyzer\nVersion -  v3.0-28-g1ba2cbb build date: 2017-10-23;17:30:24\nAnalyzed File -  x64\\Release\\StringTable2.dll\nBinary Format - 64Bit\nArchitecture  -  SKL\nAnalysis Type - Throughput\n\nThroughput Analysis Report\n--------------------------\nBlock Throughput: 3.74 Cycles       Throughput Bottleneck: Dependency Chains\nLoop Count:  22\nPort Binding In Cycles Per Iteration:\n----------------------------------------------------------------------------\n| Port   |  0  - DV  |  1  |  2  - D   |  3  - D   |  4  |  5  |  6  |  7  |\n----------------------------------------------------------------------------\n| Cycles | 2.0   0.0 | 1.0 | 3.5   3.5 | 3.5   3.5 | 0.0 | 3.0 | 2.0 | 0.0 |\n----------------------------------------------------------------------------\n\nDV - Divider pipe (on port 0)\nD - Data fetch pipe (on ports 2 and 3)\n* - instruction micro-ops not bound to a port\n^ - Micro Fusion occurred\n\n|    | Ports pressure in cycles        | |\n|µops|0DV| 1 | 2 - D | 3 - D |4| 5 | 6 |7|\n-------------------------------------------\n| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | mov rax, qword ptr [rdx+0x8]\n| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | vmovdqu xmm0, xmmword ptr [rax]\n| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | vmovdqa xmm1, xmmword ptr [rcx+0x10]\n| 1  |   |   |       |       | |1.0|   | | vpshufb xmm5, xmm0, xmm1\n| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | vmovdqa xmm2, xmmword ptr [rcx]\n| 1  |1.0|   |0.5 0.5|0.5 0.5| |   |   | | vpcmpeqb xmm5, xmm5, xmm2\n| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | vmovdqa xmm3, xmmword ptr [rcx+0x20]\n| 2  |   |   |0.5 0.5|0.5 0.5| |1.0|   | | vpbroadcastb xmm4, byte ptr [rdx]\n| 1  |   |1.0|       |       | |   |   | | vpcmpgtb xmm1, xmm3, xmm4\n| 2  |1.0|   |       |       | |1.0|   | | vptest xmm1, xmm5\n| 1  |   |   |       |       | |   |1.0| | jnb 0x10\n| 1* |   |   |       |       | |   |   | | xor eax, eax\n| 1  |   |   |       |       | |   |1.0| | not al\n| 3^ |   |   |0.5 0.5|0.5 0.5| |   |   | | ret\nTotal Num Of µops: 18\n\n\n\nThe Intel Architecture Code Analyzer User Manual (v3.0) provides decent documentation about how to interpret the output, so I won’t go over the gory details. What I’m really looking at in this pass is what my block throughput is, and potentially what the bottleneck is.\nIn this case, our block throughput is being reported as 3.74 cycles, which basically indicates how many CPU cycles it takes to execute the block. Our bottleneck is dependency chains, which refers to the situation where, say, instruction C can’t start because the results from instruction A aren’t ready yet.\nAlright, well, what can we do? A good answer would be that with an intimate understanding of contemporary Intel CPU architecture, you can pinpoint exactly what needs changing in order to reduce dependencies, maximize port utilization, and generally make the CPU happier.\nOr you can just move shit around until the number gets smaller. That’s what I did.\nWell, that’s not entirely true. Fabian did make a good suggestion when he was reviewing some of my assembly that I was often needlessly doing a load into an XMM register only to use it once in a subsequent operation. Instead of doing that, I could just use the load-op version of the instruction, which allows for an instruction input parameter to be sourced from memory.\nFor example, instead of this:\nvmovdqa  xmm2, xmmword ptr StringTable.UniqueChars[rcx] ; Load unique chars.\nvpcmpeqb xmm5, xmm5, xmm2                               ; Compare unique chars.\nYou can just do this:\nvpcmpeqb xmm5, xmm5, xmmword ptr StringTable.UniqueChars[rcx] ; Compare...\nBut yeah, other than a few load-op tweaks, I basically just shuffled shit around until the block throughput reported lower. Very rigorous methodology, I know. Here’s the final version, which also happens to be the version quoted in the introduction of this article:\n\nAssemblyIACA\n\n\nmov      rax,  String.Buffer[rdx]                   ; Load address of string buffer.\nvpbroadcastb xmm4, byte ptr String.Length[rdx]      ; Broadcast string length.\nvmovdqa  xmm3, xmmword ptr StringTable.Lengths[rcx] ; Load table lengths.\nvmovdqu  xmm0, xmmword ptr [rax]                    ; Load string buffer.\nvpcmpgtb xmm1, xmm3, xmm4                           ; Identify slots &gt; string len.\nvpshufb  xmm5, xmm0, StringTable.UniqueIndex[rcx]   ; Rearrange string by unique index.\nvpcmpeqb xmm5, xmm5, StringTable.UniqueChars[rcx]   ; Compare rearranged to unique.\nvptest   xmm1, xmm5                                 ; Unique slots AND (!long slots).\njnc      short Pfx10                                ; CY=0, continue with routine.\nxor      eax, eax                                   ; CY=1, no match.\nnot      al                                         ; al = -1 (NO_MATCH_FOUND).\nret                                                 ; Return NO_MATCH_FOUND.\n\n\nS:\\Source\\tracer&gt;iaca x64\\Release\\StringTable2.dll\nIntel(R) Architecture Code Analyzer\nVersion -  v3.0-28-g1ba2cbb build date: 2017-10-23;17:30:24\nAnalyzed File -  x64\\Release\\StringTable2.dll\nBinary Format - 64Bit\nArchitecture  -  SKL\nAnalysis Type - Throughput\n\nThroughput Analysis Report\n--------------------------\nBlock Throughput: 3.48 Cycles       Throughput Bottleneck: FrontEnd\nLoop Count:  24\nPort Binding In Cycles Per Iteration:\n----------------------------------------------------------------------------\n| Port   |  0  - DV  |  1  |  2  - D   |  3  - D   |  4  |  5  |  6  |  7  |\n----------------------------------------------------------------------------\n| Cycles | 2.0   0.0 | 1.0 | 3.5   3.5 | 3.5   3.5 | 0.0 | 3.0 | 2.0 | 0.0 |\n----------------------------------------------------------------------------\n\nDV - Divider pipe (on port 0)\nD - Data fetch pipe (on ports 2 and 3)\n* - instruction micro-ops not bound to a port\n^ - Micro Fusion occurred\n\n|    | Ports pressure in cycles        | |\n|µops|0DV| 1 | 2 - D | 3 - D |4| 5 | 6 |7|\n-------------------------------------------\n| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | mov rax, qword ptr [rdx+0x8]\n| 2  |   |   |0.5 0.5|0.5 0.5| |1.0|   | | vpbroadcastb xmm4, byte ptr [rdx]\n| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | vmovdqa xmm3, xmmword ptr [rcx+0x20]\n| 1  |   |   |0.5 0.5|0.5 0.5| |   |   | | vmovdqu xmm0, xmmword ptr [rax]\n| 1  |1.0|   |       |       | |   |   | | vpcmpgtb xmm1, xmm3, xmm4\n| 2^ |   |   |0.5 0.5|0.5 0.5| |1.0|   | | vpshufb xmm5, xmm0, xmmword ptr [rcx+0x10]\n| 2^ |   |1.0|0.5 0.5|0.5 0.5| |   |   | | vpcmpeqb xmm5, xmm5, xmmword ptr [rcx]\n| 2  |1.0|   |       |       | |1.0|   | | vptest xmm1, xmm5\n| 1  |   |   |       |       | |   |1.0| | jnb 0x10\n| 1* |   |   |       |       | |   |   | | xor eax, eax\n| 1  |   |   |       |       | |   |1.0| | not al\n| 3^ |   |   |0.5 0.5|0.5 0.5| |   |   | | ret\nTotal Num Of µops: 18\n\n\n\nAs you can see, that is reporting a block throughput of 3.48 instead of 3.74. A whopping 0.26 reduction! Also note the bottleneck is now being reported as FrontEnd, which basically means that the thing holding up this code now is literally the CPU’s ability to decode the actual instruction stream into actionable internal work. (Again, super simplistic explanation of a very complex process.)\nFor the sake of completeness, here’s the proper diff and full version of assembly version 5:\n\nDiff (5 vs 4)Full\n\n\n% diff -u IsPrefixOfStringInTable_x64_4.asm IsPrefixOfStringInTable_x64_5.asm\n--- IsPrefixOfStringInTable_x64_4.asm   2018-04-26 17:56:37.934374900 -0400\n+++ IsPrefixOfStringInTable_x64_5.asm   2018-04-26 18:17:26.087861100 -0400\n@@ -33,9 +33,14 @@\n ;   search string.  That is, whether any string in the table \"starts with\n ;   or is equal to\" the search string.\n ;\n-;   This routine is based off version 2, but leverages the fact that\n-;   vptest sets the carry flag if '(xmm0 and (not xmm1))' evaluates\n-;   to all 0s, avoiding the the need to do the pxor or pandn steps.\n+;   This routine is identical to version 4, but has the initial negative match\n+;   instructions re-ordered and tweaked in order to reduce the block throughput\n+;   reported by IACA (from 3.74 to 3.48).\n+;\n+;   N.B. Although this does result in a measurable speedup, the clarity suffers\n+;        somewhat due to the fact that instructions that were previously paired\n+;        together are now spread out (e.g. moving the string buffer address into\n+;        rax and then loading that into xmm0 three instructions later).\n ;\n ; Arguments:\n ;\n@@ -54,32 +59,21 @@\n ;\n ;--\n\n-        LEAF_ENTRY IsPrefixOfStringInTable_x64_4, _TEXT$00\n+        LEAF_ENTRY IsPrefixOfStringInTable_x64_5, _TEXT$00\n\n ;\n-; Load the string buffer into xmm0, and the unique indexes from the string table\n-; into xmm1.  Shuffle the buffer according to the unique indexes, and store the\n-; result into xmm5.\n+; Load the address of the string buffer into rax.\n ;\n\n         ;IACA_VC_START\n\n-        mov     rax, String.Buffer[rdx]\n-        vmovdqu xmm0, xmmword ptr [rax]                 ; Load search buffer.\n-        vmovdqa xmm1, xmmword ptr StringTable.UniqueIndex[rcx] ; Load indexes.\n-        vpshufb xmm5, xmm0, xmm1\n-\n-;\n-; Load the string table's unique character array into xmm2.\n-\n-        vmovdqa xmm2, xmmword ptr StringTable.UniqueChars[rcx]  ; Load chars.\n+        mov     rax, String.Buffer[rdx]         ; Load buffer addr.\n\n ;\n-; Compare the search string's unique character array (xmm5) against the string\n-; table's unique chars (xmm2), saving the result back into xmm5.\n+; Broadcast the byte-sized string length into xmm4.\n ;\n\n-        vpcmpeqb    xmm5, xmm5, xmm2            ; Compare unique chars.\n+        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.\n\n ;\n ; Load the lengths of each string table slot into xmm3.\n@@ -88,26 +82,38 @@\n         vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]  ; Load lengths.\n\n ;\n-; Broadcast the byte-sized string length into xmm4.\n+; Load the search string buffer into xmm0.\n ;\n\n-        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.\n+        vmovdqu xmm0, xmmword ptr [rax]         ; Load search buffer.\n\n ;\n ; Compare the search string's length, which we've broadcasted to all 8-byte\n ; elements of the xmm4 register, to the lengths of the slots in the string\n-; table, to find those that are greater in length.  Invert the result, such\n-; that we're left with a masked register where each 0xff element indicates\n-; a slot with a length less than or equal to our search string's length.\n+; table, to find those that are greater in length.\n ;\n\n         vpcmpgtb    xmm1, xmm3, xmm4            ; Identify long slots.\n\n ;\n+; Shuffle the buffer in xmm0 according to the unique indexes, and store the\n+; result into xmm5.\n+;\n+\n+        vpshufb     xmm5, xmm0, StringTable.UniqueIndex[rcx] ; Rearrange string.\n+\n+;\n+; Compare the search string's unique character array (xmm5) against the string\n+; table's unique chars (xmm2), saving the result back into xmm5.\n+;\n+\n+        vpcmpeqb    xmm5, xmm5, StringTable.UniqueChars[rcx] ; Compare to uniq.\n+\n+;\n ; Intersect-and-test the unique character match xmm mask register (xmm5) with\n-; the inverted length match mask xmm register (xmm1).  This will set the carry\n-; flag (CY = 1) if the result of 'xmm5 and (not xmm1)' is all 0s, which allows\n-; us to do a fast-path exit for the no-match case.\n+; the length match mask xmm register (xmm1).  This affects flags, allowing us\n+; to do a fast-path exit for the no-match case (where CY = 1 after xmm1 has\n+; been inverted).\n ;\n\n         vptest      xmm1, xmm5                  ; Check for no match.\n@@ -472,7 +478,7 @@\n\n         ;IACA_VC_END\n\n-        LEAF_END   IsPrefixOfStringInTable_x64_4, _TEXT$00\n+        LEAF_END   IsPrefixOfStringInTable_x64_5, _TEXT$00\n\n ; vim:set tw=80 ts=8 sw=4 sts=4 et syntax=masm fo=croql comments=\\:;           :\n\n\n;++\n;\n; STRING_TABLE_INDEX\n; IsPrefixOfStringInTable_x64_*(\n;     _In_ PSTRING_TABLE StringTable,\n;     _In_ PSTRING String,\n;     _Out_opt_ PSTRING_MATCH Match\n;     )\n;\n; Routine Description:\n;\n;   Searches a string table to see if any strings \"prefix match\" the given\n;   search string.  That is, whether any string in the table \"starts with\n;   or is equal to\" the search string.\n;\n;   This routine is identical to version 4, but has the initial negative match\n;   instructions re-ordered and tweaked in order to reduce the block throughput\n;   reported by IACA (from 3.74 to 3.48).\n;\n;   N.B. Although this does result in a measurable speedup, the clarity suffers\n;        somewhat due to the fact that instructions that were previously paired\n;        together are now spread out (e.g. moving the string buffer address into\n;        rax and then loading that into xmm0 three instructions later).\n;\n; Arguments:\n;\n;   StringTable - Supplies a pointer to a STRING_TABLE struct.\n;\n;   String - Supplies a pointer to a STRING struct that contains the string to\n;       search for.\n;\n;   Match - Optionally supplies a pointer to a variable that contains the\n;       address of a STRING_MATCH structure.  This will be populated with\n;       additional details about the match if a non-NULL pointer is supplied.\n;\n; Return Value:\n;\n;   Index of the prefix match if one was found, NO_MATCH_FOUND if not.\n;\n;--\n\n        LEAF_ENTRY IsPrefixOfStringInTable_x64_5, _TEXT$00\n\n;\n; Load the address of the string buffer into rax.\n;\n\n        ;IACA_VC_START\n\n        mov     rax, String.Buffer[rdx]         ; Load buffer addr.\n\n;\n; Broadcast the byte-sized string length into xmm4.\n;\n\n        vpbroadcastb xmm4, byte ptr String.Length[rdx]  ; Broadcast length.\n\n;\n; Load the lengths of each string table slot into xmm3.\n;\n\n        vmovdqa xmm3, xmmword ptr StringTable.Lengths[rcx]  ; Load lengths.\n\n;\n; Load the search string buffer into xmm0.\n;\n\n        vmovdqu xmm0, xmmword ptr [rax]         ; Load search buffer.\n\n;\n; Compare the search string's length, which we've broadcasted to all 8-byte\n; elements of the xmm4 register, to the lengths of the slots in the string\n; table, to find those that are greater in length.\n;\n\n        vpcmpgtb    xmm1, xmm3, xmm4            ; Identify long slots.\n\n;\n; Shuffle the buffer in xmm0 according to the unique indexes, and store the\n; result into xmm5.\n;\n\n        vpshufb     xmm5, xmm0, StringTable.UniqueIndex[rcx] ; Rearrange string.\n\n;\n; Compare the search string's unique character array (xmm5) against the string\n; table's unique chars (xmm2), saving the result back into xmm5.\n;\n\n        vpcmpeqb    xmm5, xmm5, StringTable.UniqueChars[rcx] ; Compare to uniq.\n\n;\n; Intersect-and-test the unique character match xmm mask register (xmm5) with\n; the length match mask xmm register (xmm1).  This affects flags, allowing us\n; to do a fast-path exit for the no-match case (where CY = 1 after xmm1 has\n; been inverted).\n;\n\n        vptest      xmm1, xmm5                  ; Check for no match.\n        jnc         short Pfx10                 ; There was a match.\n\n;\n; No match, set rax to -1 and return.\n;\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        ret                                     ; Return.\n\n        ;IACA_VC_END\n\n;\n; (There was at least one match, continue with processing.)\n;\n\n;\n; Calculate the \"search length\" for the incoming search string, which is\n; equivalent of 'min(String-&gt;Length, 16)'.  (The search string's length\n; currently lives in xmm4, albeit as a byte-value broadcasted across the\n; entire register, so extract that first.)\n;\n; Once the search length is calculated, deposit it back at the second byte\n; location of xmm4.\n;\n;   r10 and xmm4[15:8] - Search length (min(String-&gt;Length, 16))\n;\n;   r11 - String length (String-&gt;Length)\n;\n\nPfx10:  vpextrb     r11, xmm4, 0                ; Load length.\n        mov         rax, 16                     ; Load 16 into rax.\n        mov         r10, r11                    ; Copy into r10.\n        cmp         r10w, ax                    ; Compare against 16.\n        cmova       r10w, ax                    ; Use 16 if length is greater.\n        vpinsrb     xmm4, xmm4, r10d, 1         ; Save back to xmm4b[1].\n\n;\n; Home our parameter registers into xmm registers instead of their stack-backed\n; location, to avoid memory writes.\n;\n\n        vpxor       xmm2, xmm2, xmm2            ; Clear xmm2.\n        vpinsrq     xmm2, xmm2, rcx, 0          ; Save rcx into xmm2q[0].\n        vpinsrq     xmm2, xmm2, rdx, 1          ; Save rdx into xmm2q[1].\n\n;\n; Intersect xmm5 and xmm1 (as we did earlier with the 'vptest xmm1, xmm5'),\n; yielding a mask identifying indices we need to perform subsequent matches\n; upon.  Convert this into a bitmap and save in xmm2d[2].\n;\n\n        vpandn      xmm5, xmm1, xmm5            ; Intersect unique + lengths.\n        vpmovmskb   edx, xmm5                   ; Generate a bitmap from mask.\n\n;\n; We're finished with xmm5; repurpose it in the same vein as xmm2 above.\n;\n\n        vpxor       xmm5, xmm5, xmm5            ; Clear xmm5.\n        vpinsrq     xmm5, xmm5, r8, 0           ; Save r8 into xmm5q[0].\n\n;\n; Summary of xmm register stashing for the rest of the routine:\n;\n; xmm2:\n;        0:63   (vpinsrq 0)     rcx (1st function parameter, StringTable)\n;       64:127  (vpinsrq 1)     rdx (2nd function paramter, String)\n;\n; xmm4:\n;       0:7     (vpinsrb 0)     length of search string\n;       8:15    (vpinsrb 1)     min(String-&gt;Length, 16)\n;      16:23    (vpinsrb 2)     loop counter (when doing long string compares)\n;      24:31    (vpinsrb 3)     shift count\n;\n; xmm5:\n;       0:63    (vpinsrq 0)     r8 (3rd function parameter, StringMatch)\n;      64:95    (vpinsrd 2)     bitmap of slots to compare\n;      96:127   (vpinsrd 3)     index of slot currently being processed\n;\n\n;\n; Initialize rcx as our counter register by doing a popcnt against the bitmap\n; we just generated in edx, and clear our shift count register (r9).\n;\n\n        popcnt      ecx, edx                    ; Count bits in bitmap.\n        xor         r9, r9                      ; Clear r9.\n\n        align 16\n\n;\n; Top of the main comparison loop.  The bitmap will be present in rdx.  Count\n; trailing zeros of the bitmap, and then add in the shift count, producing an\n; index (rax) we can use to load the corresponding slot.\n;\n; Register usage at top of loop:\n;\n;   rax - Index.\n;\n;   rcx - Loop counter.\n;\n;   rdx - Bitmap initially, then slot length.\n;\n;   r9 - Shift count.\n;\n;   r10 - Search length.\n;\n;   r11 - String length.\n;\n\nPfx20:  tzcnt       r8d, edx                    ; Count trailing zeros.\n        mov         eax, r8d                    ; Copy tzcnt to rax,\n        add         rax, r9                     ; Add shift to create index.\n        inc         r8                          ; tzcnt + 1\n        shrx        rdx, rdx, r8                ; Reposition bitmap.\n        vpinsrd     xmm5, xmm5, edx, 2          ; Store bitmap, free up rdx.\n        xor         edx, edx                    ; Clear edx.\n        mov         r9, rax                     ; Copy index back to shift.\n        inc         r9                          ; Shift = Index + 1\n        vpinsrd     xmm5, xmm5, eax, 3          ; Store the raw index xmm5d[3].\n\n;\n; \"Scale\" the index (such that we can use it in a subsequent vmovdqa) by\n; shifting left by 4 (i.e. multiply by '(sizeof STRING_SLOT)', which is 16).\n;\n; Then, load the string table slot at this index into xmm1, then shift rax back.\n;\n\n        shl         eax, 4\n        vpextrq     r8, xmm2, 0\n        vmovdqa     xmm1, xmmword ptr [rax + StringTable.Slots[r8]]\n        shr         eax, 4\n\n;\n; The search string's first 16 characters are already in xmm0.  Compare this\n; against the slot that has just been loaded into xmm1, storing the result back\n; into xmm1.\n;\n\n        vpcmpeqb    xmm1, xmm1, xmm0            ; Compare search string to slot.\n\n;\n; Convert the XMM mask into a 32-bit representation, then zero high bits after\n; our \"search length\", which allows us to ignore the results of the comparison\n; above for bytes that were after the search string's length, if applicable.\n; Then, count the number of bits remaining, which tells us how many characters\n; we matched.\n;\n\n        vpmovmskb   r8d, xmm1                   ; Convert into mask.\n        bzhi        r8d, r8d, r10d              ; Zero high bits.\n        popcnt      r8d, r8d                    ; Count bits.\n\n;\n; Load the slot length into rdx.  As xmm3 already has all the slot lengths in\n; it, we can load rax (the current index) into xmm1 and use it to extract the\n; slot length via shuffle.  (The length will be in the lowest byte of xmm1\n; after the shuffle, which we can then vpextrb.)\n;\n\n        movd        xmm1, rax                   ; Load index into xmm1.\n        vpshufb     xmm1, xmm3, xmm1            ; Shuffle lengths.\n        vpextrb     rdx, xmm1, 0                ; Extract target length to rdx.\n\n;\n; If 16 characters matched, and the search string's length is longer than 16,\n; we're going to need to do a comparison of the remaining strings.\n;\n\n        cmp         r8w, 16                     ; Compare chars matched to 16.\n        je          short @F                    ; 16 chars matched.\n        jmp         Pfx30                       ; Less than 16 matched.\n\n;\n; All 16 characters matched.  If the slot length is greater than 16, we need\n; to do an inline memory comparison of the remaining bytes.  If it's 16 exactly,\n; then great, that's a slot match, we're done.\n;\n\n@@:     cmp         dl, 16                      ; Compare length to 16.\n        ja          Pfx50                       ; Length is &gt; 16.\n        je          short Pfx35                 ; Lengths match!\n                                                ; Length &lt;= 16, fall through...\n\n;\n; Less than or equal to 16 characters were matched.  Compare this against the\n; length of the slot; if equal, this is a match, if not, no match, continue.\n;\n\nPfx30:  cmp         r8b, dl                     ; Compare against slot length.\n        jne         @F                          ; No match found.\n        jmp         short Pfx35                 ; Match found!\n\n;\n; No match against this slot, decrement counter and either continue the loop\n; or terminate the search and return no match.\n;\n\n@@:     vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.\n        dec         cx                          ; Decrement counter.\n        jnz         Pfx20                       ; cx != 0, continue.\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        ret                                     ; Return.\n\n;\n; Pfx35 and Pfx40 are the jump targets for when the prefix match succeeds.  The\n; former is used when we need to copy the number of characters matched from r8\n; back to rax.  The latter jump target doesn't require this.\n;\n\nPfx35:  mov         rax, r8                     ; Copy numbers of chars matched.\n\n;\n; Load the match parameter back into r8 and test to see if it's not-NULL, in\n; which case we need to fill out a STRING_MATCH structure for the match.\n;\n\nPfx40:  vpextrq     r8, xmm5, 0                 ; Extract StringMatch.\n        test        r8, r8                      ; Is NULL?\n        jnz         short @F                    ; Not zero, need to fill out.\n\n;\n; StringMatch is NULL, we're done. Extract index of match back into rax and ret.\n;\n\n        vpextrd     eax, xmm5, 3                ; Extract raw index for match.\n        ret                                     ; StringMatch == NULL, finish.\n\n;\n; StringMatch is not NULL.  Fill out characters matched (currently rax), then\n; reload the index from xmm5 into rax and save.\n;\n\n@@:     mov         byte ptr StringMatch.NumberOfMatchedCharacters[r8], al\n        vpextrd     eax, xmm5, 3                ; Extract raw index for match.\n        mov         byte ptr StringMatch.Index[r8], al\n\n;\n; Final step, loading the address of the string in the string array.  This\n; involves going through the StringTable, so we need to load that parameter\n; back into rcx, then resolving the string array address via pStringArray,\n; then the relevant STRING offset within the StringArray.Strings structure.\n;\n\n        vpextrq     rcx, xmm2, 0            ; Extract StringTable into rcx.\n        mov         rcx, StringTable.pStringArray[rcx] ; Load string array.\n\n        shl         eax, 4                  ; Scale the index; sizeof STRING=16.\n        lea         rdx, [rax + StringArray.Strings[rcx]] ; Resolve address.\n        mov         qword ptr StringMatch.String[r8], rdx ; Save STRING ptr.\n        shr         eax, 4                  ; Revert the scaling.\n\n        ret\n\n;\n; 16 characters matched and the length of the underlying slot is greater than\n; 16, so we need to do a little memory comparison to determine if the search\n; string is a prefix match.\n;\n; The slot length is stored in rax at this point, and the search string's\n; length is stored in r11.  We know that the search string's length will\n; always be longer than or equal to the slot length at this point, so, we\n; can subtract 16 (currently stored in r10) from rax, and use the resulting\n; value as a loop counter, comparing the search string with the underlying\n; string slot byte-by-byte to determine if there's a match.\n;\n\nPfx50:  sub         rdx, r10                ; Subtract 16 from search length.\n\n;\n; Free up some registers by stashing their values into various xmm offsets.\n;\n\n        vpinsrb     xmm4, xmm4, ecx, 2      ; Free up rcx register.\n        mov         rcx, rdx                ; Free up rdx, rcx is now counter.\n\n;\n; Load the search string buffer and advance it 16 bytes.\n;\n\n        vpextrq     r11, xmm2, 1            ; Extract String into r11.\n        mov         r11, String.Buffer[r11] ; Load buffer address.\n        add         r11, r10                ; Advance buffer 16 bytes.\n\n;\n; Loading the slot is more involved as we have to go to the string table, then\n; the pStringArray pointer, then the relevant STRING offset within the string\n; array (which requires re-loading the index from xmm5d[3]), then the string\n; buffer from that structure.\n;\n\n        vpextrq     r8, xmm2, 0             ; Extract StringTable into r8.\n        mov         r8, StringTable.pStringArray[r8] ; Load string array.\n\n        shl         eax, 4                  ; Scale the index; sizeof STRING=16.\n\n        lea         r8, [rax + StringArray.Strings[r8]] ; Resolve address.\n        mov         r8, String.Buffer[r8]   ; Load string table buffer address.\n        add         r8, r10                 ; Advance buffer 16 bytes.\n\n        xor         eax, eax                ; Clear eax.\n\n;\n; We've got both buffer addresses + 16 bytes loaded in r11 and r8 respectively.\n; Do a byte-by-byte comparison.\n;\n\n        align 16\n@@:     mov         dl, byte ptr [rax + r11]    ; Load byte from search string.\n        cmp         dl, byte ptr [rax + r8]     ; Compare against target.\n        jne         short Pfx60                 ; If not equal, jump.\n\n;\n; The two bytes were equal, update rax, decrement rcx and potentially continue\n; the loop.\n;\n\n        inc         ax                          ; Increment index.\n        loopnz      @B                          ; Decrement cx and loop back.\n\n;\n; All bytes matched!  Add 16 (still in r10) back to rax such that it captures\n; how many characters we matched, and then jump to Pfx40 for finalization.\n;\n\n        add         rax, r10\n        jmp         Pfx40\n\n;\n; Byte comparisons were not equal.  Restore the rcx loop counter and decrement\n; it.  If it's zero, we have no more strings to compare, so we can do a quick\n; exit.  If there are still comparisons to be made, restore the other registers\n; we trampled then jump back to the start of the loop Pfx20.\n;\n\nPfx60:  vpextrb     rcx, xmm4, 2                ; Restore rcx counter.\n        dec         cx                          ; Decrement counter.\n        jnz         short @F                    ; Jump forward if not zero.\n\n;\n; No more comparisons remaining, return.\n;\n\n        xor         eax, eax                    ; Clear rax.\n        not         al                          ; al = -1\n        ret                                     ; Return.\n\n;\n; More comparisons remain; restore the registers we clobbered and continue loop.\n;\n\n@@:     vpextrb     r10, xmm4, 1                ; Restore r10.\n        vpextrb     r11, xmm4, 0                ; Restore r11.\n        vpextrd     edx, xmm5, 2                ; Restore rdx bitmap.\n        jmp         Pfx20                       ; Continue comparisons.\n\n        ;IACA_VC_END\n\n        LEAF_END   IsPrefixOfStringInTable_x64_5, _TEXT$00\n\n\n\nDid it make a difference? Were we able to shave any time off the negative match fast path? Let’s find out.\n\n\nBenchmark x64 5\n\n\n\nBenchmark-x64-05-v1\n\n\nHurrah! We’ve got a new winner! Our final tweaks yielded a very small but measurable and repeatable improvement in both prefix matching and negative matching! Let’s mark that up as a win."
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#implementation-considerations",
    "href": "articles/is-prefix-of-string-in-table/index.html#implementation-considerations",
    "title": "Is Prefix Of String In Table?",
    "section": "Implementation Considerations",
    "text": "Implementation Considerations\nOne issue with writing so many versions of the exact same function is… how do you actually handle this? Downstream consumers of the component don’t need to access the 30 different function pointers for each function you’ve experimented with, but things like unit tests and benchmark programs do.\nHere’s what I did for the StringTable component. Define two API structures, a normal one and an “extended” one. The extended one mirrors the normal one, and then adds all of its additional functions to the end.\nI use a .def file to control the DLL function exports, with an alias to easily control which version of a function is the official version. The main header file then contains some bootstrap glue (in the form of an inline function) that dynamically loads the target library and resolves the number of API methods according to the size of the API structure provided.\nThis currently means that the StringTable2.dll includes all 14 C and 5 assembly variants, which is harmless, but it does increase the size of the module unnecessarily. (The module is currently about 19KB in size, whereas it would be under 4KB if only the official versions were included.) What I’ll probably end up doing is setting up a second project called StringTableEx, and, in conjunction with some #ifdefs, have that be the version of the module that contains all the additional functions, with the normal version just containing the official versions.\nHere’s the bootstrap glue from StringTable.h and the StringTable.def file I currently use. (Note: this routine uses the LoadSymbols() function from the Rtl component.)\n\nBootstrap Header GlueStringTable.def\n\n\n//\n// Define the string table API structure.\n//\n\ntypedef struct _STRING_TABLE_API {\n\n    PSET_C_SPECIFIC_HANDLER SetCSpecificHandler;\n\n    PCOPY_STRING_ARRAY CopyStringArray;\n    PCREATE_STRING_TABLE CreateStringTable;\n    PDESTROY_STRING_TABLE DestroyStringTable;\n\n    PINITIALIZE_STRING_TABLE_ALLOCATOR\n        InitializeStringTableAllocator;\n\n    PINITIALIZE_STRING_TABLE_ALLOCATOR_FROM_RTL_BOOTSTRAP\n        InitializeStringTableAllocatorFromRtlBootstrap;\n\n    PCREATE_STRING_ARRAY_FROM_DELIMITED_STRING\n        CreateStringArrayFromDelimitedString;\n\n    PCREATE_STRING_TABLE_FROM_DELIMITED_STRING\n        CreateStringTableFromDelimitedString;\n\n    PCREATE_STRING_TABLE_FROM_DELIMITED_ENVIRONMENT_VARIABLE\n        CreateStringTableFromDelimitedEnvironmentVariable;\n\n    PIS_STRING_IN_TABLE IsStringInTable;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable;\n\n} STRING_TABLE_API;\ntypedef STRING_TABLE_API *PSTRING_TABLE_API;\n\ntypedef struct _STRING_TABLE_API_EX {\n\n    //\n    // Inline STRING_TABLE_API.\n    //\n\n    PSET_C_SPECIFIC_HANDLER SetCSpecificHandler;\n\n    PCOPY_STRING_ARRAY CopyStringArray;\n    PCREATE_STRING_TABLE CreateStringTable;\n    PDESTROY_STRING_TABLE DestroyStringTable;\n\n    PINITIALIZE_STRING_TABLE_ALLOCATOR\n        InitializeStringTableAllocator;\n\n    PINITIALIZE_STRING_TABLE_ALLOCATOR_FROM_RTL_BOOTSTRAP\n        InitializeStringTableAllocatorFromRtlBootstrap;\n\n    PCREATE_STRING_ARRAY_FROM_DELIMITED_STRING\n        CreateStringArrayFromDelimitedString;\n\n    PCREATE_STRING_TABLE_FROM_DELIMITED_STRING\n        CreateStringTableFromDelimitedString;\n\n    PCREATE_STRING_TABLE_FROM_DELIMITED_ENVIRONMENT_VARIABLE\n        CreateStringTableFromDelimitedEnvironmentVariable;\n\n    PIS_STRING_IN_TABLE IsStringInTable;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable;\n\n    //\n    // Extended API methods used for benchmarking.\n    //\n\n    PIS_PREFIX_OF_CSTR_IN_ARRAY IsPrefixOfCStrInArray;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_1;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_2;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_3;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_4;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_5;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_6;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_7;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_8;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_9;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_10;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_11;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_12;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_13;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_14;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_x64_1;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_x64_2;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_x64_3;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_x64_4;\n    PIS_PREFIX_OF_STRING_IN_TABLE IsPrefixOfStringInTable_x64_5;\n    PIS_PREFIX_OF_STRING_IN_TABLE IntegerDivision_x64_1;\n\n} STRING_TABLE_API_EX;\ntypedef STRING_TABLE_API_EX *PSTRING_TABLE_API_EX;\n\ntypedef union _STRING_TABLE_ANY_API {\n    STRING_TABLE_API Api;\n    STRING_TABLE_API_EX ApiEx;\n} STRING_TABLE_ANY_API;\ntypedef STRING_TABLE_ANY_API *PSTRING_TABLE_ANY_API;\n\nFORCEINLINE\nBOOLEAN\nLoadStringTableApi(\n    _In_ PRTL Rtl,\n    _Inout_ HMODULE *ModulePointer,\n    _In_opt_ PUNICODE_STRING ModulePath,\n    _In_ ULONG SizeOfAnyApi,\n    _Out_writes_bytes_all_(SizeOfAnyApi) PSTRING_TABLE_ANY_API AnyApi\n    )\n/*++\n\nRoutine Description:\n\n    Loads the string table module and resolves all API functions for either\n    the STRING_TABLE_API or STRING_TABLE_API_EX structure.  The desired API\n    is indicated by the SizeOfAnyApi parameter.\n\n    Example use:\n\n        STRING_TABLE_API_EX GlobalApi;\n        PSTRING_TABLE_API_EX Api;\n\n        Success = LoadStringTableApi(Rtl,\n                                     NULL,\n                                     NULL,\n                                     sizeof(GlobalApi),\n                                     (PSTRING_TABLE_ANY_API)&GlobalApi);\n        ASSERT(Success);\n        Api = &GlobalApi;\n\n    In this example, the extended API will be provided as our sizeof(GlobalApi)\n    will indicate the structure size used by STRING_TABLE_API_EX.\n\n    See ../StringTable2BenchmarkExe/main.c for a complete example.\n\nArguments:\n\n    Rtl - Supplies a pointer to an initialized RTL structure.\n\n    ModulePointer - Optionally supplies a pointer to an existing module handle\n        for which the API symbols are to be resolved.  May be NULL.  If not\n        NULL, but the pointed-to value is NULL, then this parameter will\n        receive the handle obtained by LoadLibrary() as part of this call.\n        If the string table module is no longer needed, but the program will\n        keep running, the caller should issue a FreeLibrary() against this\n        module handle.\n\n    ModulePath - Optionally supplies a pointer to a UNICODE_STRING structure\n        representing a path name of the string table module to be loaded.\n        If *ModulePointer is not NULL, it takes precedence over this parameter.\n        If NULL, and no module has been provided via *ModulePointer, an attempt\n        will be made to load the library via 'LoadLibraryA(\"StringTable.dll\")'.\n\n    SizeOfAnyApi - Supplies the size, in bytes, of the underlying structure\n        pointed to by the AnyApi parameter.\n\n    AnyApi - Supplies the address of a structure which will receive resolved\n        API function pointers.  The API furnished will depend on the size\n        indicated by the SizeOfAnyApi parameter.\n\nReturn Value:\n\n    TRUE on success, FALSE on failure.\n\n--*/\n{\n    BOOL Success;\n    HMODULE Module = NULL;\n    ULONG NumberOfSymbols;\n    ULONG NumberOfResolvedSymbols;\n\n    //\n    // Define the API names.\n    //\n    // N.B. These names must match STRING_TABLE_API_EX exactly (including the\n    //      order).\n    //\n\n    const PCSTR Names[] = {\n        \"SetCSpecificHandler\",\n        \"CopyStringArray\",\n        \"CreateStringTable\",\n        \"DestroyStringTable\",\n        \"InitializeStringTableAllocator\",\n        \"InitializeStringTableAllocatorFromRtlBootstrap\",\n        \"CreateStringArrayFromDelimitedString\",\n        \"CreateStringTableFromDelimitedString\",\n        \"CreateStringTableFromDelimitedEnvironmentVariable\",\n        \"IsStringInTable\",\n        \"IsPrefixOfStringInTable\",\n        \"IsPrefixOfCStrInArray\",\n        \"IsPrefixOfStringInTable_1\",\n        \"IsPrefixOfStringInTable_2\",\n        \"IsPrefixOfStringInTable_3\",\n        \"IsPrefixOfStringInTable_4\",\n        \"IsPrefixOfStringInTable_5\",\n        \"IsPrefixOfStringInTable_6\",\n        \"IsPrefixOfStringInTable_7\",\n        \"IsPrefixOfStringInTable_8\",\n        \"IsPrefixOfStringInTable_9\",\n        \"IsPrefixOfStringInTable_10\",\n        \"IsPrefixOfStringInTable_11\",\n        \"IsPrefixOfStringInTable_12\",\n        \"IsPrefixOfStringInTable_13\",\n        \"IsPrefixOfStringInTable_14\",\n        \"IsPrefixOfStringInTable_x64_1\",\n        \"IsPrefixOfStringInTable_x64_2\",\n        \"IsPrefixOfStringInTable_x64_3\",\n        \"IsPrefixOfStringInTable_x64_4\",\n        \"IsPrefixOfStringInTable_x64_5\",\n        \"IntegerDivision_x64_1\",\n    };\n\n    //\n    // Define an appropriately sized bitmap we can passed to Rtl-&gt;LoadSymbols().\n    //\n\n    ULONG BitmapBuffer[(ALIGN_UP(ARRAYSIZE(Names), sizeof(ULONG) &lt;&lt; 3) &gt;&gt; 5)+1];\n    RTL_BITMAP FailedBitmap = { ARRAYSIZE(Names)+1, (PULONG)&BitmapBuffer };\n\n    //\n    // Determine the number of symbols we want to resolve based on the size of\n    // the API indicated by the caller.\n    //\n\n    if (SizeOfAnyApi == sizeof(AnyApi-&gt;Api)) {\n        NumberOfSymbols = sizeof(AnyApi-&gt;Api) / sizeof(ULONG_PTR);\n    } else if (SizeOfAnyApi == sizeof(AnyApi-&gt;ApiEx)) {\n        NumberOfSymbols = sizeof(AnyApi-&gt;ApiEx) / sizeof(ULONG_PTR);\n    } else {\n        return FALSE;\n    }\n\n    //\n    // Attempt to load the underlying string table module if necessary.\n    //\n\n    if (ARGUMENT_PRESENT(ModulePointer)) {\n        Module = *ModulePointer;\n    }\n\n    if (!Module) {\n        if (ARGUMENT_PRESENT(ModulePath)) {\n            Module = LoadLibraryW(ModulePath-&gt;Buffer);\n        } else {\n            Module = LoadLibraryA(\"StringTable2.dll\");\n        }\n    }\n\n    if (!Module) {\n        return FALSE;\n    }\n\n    //\n    // We've got a handle to the string table module.  Load the symbols we want\n    // dynamically via Rtl-&gt;LoadSymbols().\n    //\n\n    Success = Rtl-&gt;LoadSymbols(\n        Names,\n        NumberOfSymbols,\n        (PULONG_PTR)AnyApi,\n        NumberOfSymbols,\n        Module,\n        &FailedBitmap,\n        TRUE,\n        &NumberOfResolvedSymbols\n    );\n\n    ASSERT(Success);\n\n    //\n    // Debug helper: if the breakpoint below is hit, then the symbol names\n    // have potentially become out of sync.  Look at the value of first failed\n    // symbol to assist in determining the cause.\n    //\n\n    if (NumberOfSymbols != NumberOfResolvedSymbols) {\n        PCSTR FirstFailedSymbolName;\n        ULONG FirstFailedSymbol;\n        ULONG NumberOfFailedSymbols;\n\n        NumberOfFailedSymbols = Rtl-&gt;RtlNumberOfSetBits(&FailedBitmap);\n        FirstFailedSymbol = Rtl-&gt;RtlFindSetBits(&FailedBitmap, 1, 0);\n        FirstFailedSymbolName = Names[FirstFailedSymbol-1];\n        __debugbreak();\n    }\n\n    //\n    // Set the C specific handler for the module, such that structured\n    // exception handling will work.\n    //\n\n    AnyApi-&gt;Api.SetCSpecificHandler(Rtl-&gt;__C_specific_handler);\n\n    //\n    // Update the caller's pointer and return success.\n    //\n\n    if (ARGUMENT_PRESENT(ModulePointer)) {\n        *ModulePointer = Module;\n    }\n\n    return TRUE;\n}\n\n\nLIBRARY StringTable2\nEXPORTS\n    SetCSpecificHandler\n    CopyStringArray\n    CreateStringTable\n    DestroyStringTable\n    InitializeStringTableAllocator\n    InitializeStringTableAllocatorFromRtlBootstrap\n    CreateStringArrayFromDelimitedString\n    CreateStringTableFromDelimitedString\n    CreateStringTableFromDelimitedEnvironmentVariable\n    TestIsPrefixOfStringInTableFunctions\n    IsStringInTable\n    IsPrefixOfStringInTable_1\n    IsPrefixOfStringInTable_2\n    IsPrefixOfStringInTable_3\n    IsPrefixOfStringInTable_4\n    IsPrefixOfStringInTable_5\n    IsPrefixOfStringInTable_6\n    IsPrefixOfStringInTable_7\n    IsPrefixOfStringInTable_8\n    IsPrefixOfStringInTable_9\n    IsPrefixOfStringInTable_10\n    IsPrefixOfStringInTable_11\n    IsPrefixOfStringInTable_12\n    IsPrefixOfStringInTable_13\n    IsPrefixOfStringInTable_14\n    IsPrefixOfStringInTable_x64_1\n    IsPrefixOfStringInTable_x64_2\n    IsPrefixOfStringInTable_x64_3\n    IsPrefixOfStringInTable_x64_4\n    IsPrefixOfStringInTable_x64_5\n    IsPrefixOfCStrInArray\n    IntegerDivision_x64_1\n    IsPrefixOfStringInTable=IsPrefixOfStringInTable_13"
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#release-build-versus-profile-guided-optimization-build",
    "href": "articles/is-prefix-of-string-in-table/index.html#release-build-versus-profile-guided-optimization-build",
    "title": "Is Prefix Of String In Table?",
    "section": "Release Build versus Profile Guided Optimization Build",
    "text": "Release Build versus Profile Guided Optimization Build\nIt’s interesting to see a side-by-side comparison of the optimized release build next to the PGO build. The main changes are mostly all to do with branching and jump direction. The following diagram was generated via IDA Pro 6.95.\n\n\n\nIsPrefixOfStringInTable_13-Release-vs-PGO.png"
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#typedefs",
    "href": "articles/is-prefix-of-string-in-table/index.html#typedefs",
    "title": "Is Prefix Of String In Table?",
    "section": "Typedefs",
    "text": "Typedefs\nIf there’s one thing you can’t argue about with the Pascal-style Cutler Normal Form, is that it loves a good typedef. For the sake of completeness, here’s a list of all the explicit or implied typedefs featured in the code on this page.\n//\n// Standard NT/Windows typedefs (typically living in minwindef.h).\n//\n\ntypedef void *PVOID;\ntypedef char CHAR;\ntypedef short SHORT;\ntypedef long LONG;\ntypedef unsigned long ULONG;\ntypedef ULONG *PULONG;\ntypedef unsigned short USHORT;\ntypedef USHORT *PUSHORT;\ntypedef unsigned char UCHAR;\ntypedef UCHAR *PUCHAR;\ntypedef _Null_terminated_ char *PSZ;\ntypedef const _Null_terminated_ char *PCSZ;\n\ntypedef int BOOL;\ntypedef unsigned char BYTE;\ntypedef unsigned short WORD;\n\ntypedef BYTE BOOLEAN;\ntypedef BOOLEAN *PBOOLEAN;\n\n//\n// The STRING structure used by the NT kernel.  Our STRING_ARRAY structure\n// relies on an array of these structures.  We never pass raw 'char *'s\n// around, only STRING/PSTRING structs/pointers.\n//\n\ntypedef struct _STRING {\n    USHORT Length;\n    USHORT MaximumLength;\n    ULONG  Padding;\n    PCHAR Buffer;\n} STRING, *PSTRING;\ntypedef const STRING *PCSTRING;\n\n//\n// Our SIMD register typedefs.\n//\n\ntypedef __m128i DECLSPEC_ALIGN(16) XMMWORD, *PXMMWORD, **PPXMMWORD;\ntypedef __m256i DECLSPEC_ALIGN(32) YMMWORD, *PYMMWORD, **PPYMMWORD;\ntypedef __m512i DECLSPEC_ALIGN(64) ZMMWORD, *PZMMWORD, **PPZMMWORD;"
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#quarto-markdown",
    "href": "articles/is-prefix-of-string-in-table/index.html#quarto-markdown",
    "title": "Is Prefix Of String In Table?",
    "section": "Quarto & Markdown",
    "text": "Quarto & Markdown\nThe syntax highlighting for C and assembly is provided by c.xml and asm.xml respectively.\nThese files were copied from the KDE syntax-highlighting repository and then modified to add support for things like SIMD intrinsics, SAL annotations, NT types and definitions, custom types and definitions used in the article, etc.\nFor the syntax color scheme, I copied the dracula.theme from the Quarto repository into tpn.theme and then just hacked on it until I was mostly content with the results."
  },
  {
    "objectID": "articles/is-prefix-of-string-in-table/index.html#data-visualization",
    "href": "articles/is-prefix-of-string-in-table/index.html#data-visualization",
    "title": "Is Prefix Of String In Table?",
    "section": "Data Visualization",
    "text": "Data Visualization\n\nAlgorithm Diagrams\nThe algorithm diagrams at the start of the article were created using my trusty ol’ copy of Visio 2019. The diagrams were saved as SVG. I had to inject a &lt;rect width=\"100%\" height=\"100%\" fill=\"#ffffff\" /&gt; into the start of each SVG file when porting to Quarto/Markdown in order to support dark mode. This set a white background for the diagram, which was otherwise transparent and did not render correctly in dark mode.\n\n\nBenchmarks\nAll of the resources used to generate this article, including raw .csv data, supporting .svgs, etc., live in the resources directory.\nThe charts were created in Excel. Each .csv data file was added as a new data source and imported, and then a PivotTable was created to generate the desired bar graph. This was then saved as PDF, which I then edited with Inkscape, deleting the surrounding border, cropping the canvas to fit the diagram, and then saving as SVG.\nAfter saving as SVG, I then edited each chart in Vim and manually did some font corrections. Looking at my .vimrc file, I believe this was what I used:\n\"\n\" SVG helpers.\n\"\n\nmap &lt;leader&gt;v\n    \\ &lt;ESC&gt;:% s/GillSans;/Calibri,GillSans-Light;/ge&lt;CR&gt;\n    \\ &lt;ESC&gt;:% s/Monaco/Monaco,Consolas,Menlo,monospace/ge&lt;CR&gt;\nI can’t remember if I did any other modifications whilst in Vim (I’m writing this colophon in 2024, but the SVG hacking was done over six years ago)."
  },
  {
    "objectID": "articles/index.html",
    "href": "articles/index.html",
    "title": "Articles",
    "section": "",
    "text": "PyTorch and Python Free-Threading\n\n\nUnlocking multi-threaded parallel inference on PyTorch models \n\n\n\nPyTorch\n\n\nPython\n\n\nFree-Threading\n\n\nNo-GIL\n\n\nLLM\n\n\nGPT2\n\n\n\nThis post examines multi-threaded parallel inference on PyTorch models using the new No-GIL, free-threaded version of Python. Using a simple 124M parameter GPT2 model that we train from scratch, we explore the novel new territory unlocked by free-threaded Python: parallel PyTorch model inference, where multiple threads, unimpeded by the Python GIL, attempt to generate text from a transformer-based model in parallel. \n\n\n\n\n\nFeb 13, 2025\n\n\nTrent Nelson\n\n\n\n\n\n\n\n\n\n\n\n\nIs Prefix Of String In Table?\n\n\nA Journey Into SIMD String Processing\n\n\n\nAVX2\n\n\nSIMD\n\n\nC\n\n\nAssembly\n\n\nMASM\n\n\n\nThis article details an approach for efficiently determining if a given string prefix-matches a set of known strings. That is, do any of the known strings represent the prefix of a given string? A custom data structure is employed with successive implementations benchmarked to find the fastest possible solution. \n\n\n\n\n\nMay 4, 2018\n\n\nTrent Nelson\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html",
    "href": "articles/pytorch-and-python-free-threading/index.html",
    "title": "PyTorch and Python Free-Threading",
    "section": "",
    "text": "Introduction\n  Getting Started\n  PyTorch and LLM Crash Course\n  \n  Training GPT-2 (124M) Locally\n  \n  PyTorch GPT-2 Implementation\n  \n  Initial Implementation\n  Loading the Model\n  Generating Text\n  \n  Parallel PyTorch Inference\n  \n  Pure Python Multi-threaded HTTP Server\n  GPT2 HTTP App\n  \n  Synchronous Up-Front Generation\n  Our Goals\n  Asynchronous Token-by-Token Generation\n  \n  Step 1: Have generate() enqueue an async generate_response().\n  Step 2: Implement an async generate_response()\n  Step 3: Implement an async GPT.async_generate_for()\n  \n  \n  Test Drive!\n  \n  Launching the HTTP Server\n  Visualizing Chunked-Encoding\n  Verifying via Curl\n  Launching the React Bootstrap UI\n  \n  Parallel Generation\n  \n  Netcat Example\n  Curl Example\n  \n  Let’s Load Test This Sucker!\n  \n  Parallel Load Testing (No GIL)\n  Ablation Test: Re-enable the GIL\n  Parallel Load Testing: No GIL vs GIL\n  Parallel Load Testing: How does Plaintext Fare?\n  Parallel Load Test Summary\n  \n  \n  Finishing Up\n  \n  Reviewing Initial Implementation\n  \n  Skipping Weight Initialization\n  Can We Load Other Checkpoints?\n  Multi-GPU Support\n  \n  Model Optimization\n  \n  TorchScript\n  Torch Dynamo (torch.compile)\n  \n  Performance Comparison\n  Free-Threaded Python (py313t)\n  Normal Python (py313)\n  Explicit @torch.compile Decorator\n  \n  \n  \n  Conclusion\nThis post is sponsored in part by Meta in collaboration with Quansight and OpenTeams."
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#environments",
    "href": "articles/pytorch-and-python-free-threading/index.html#environments",
    "title": "PyTorch and Python Free-Threading",
    "section": "Environments",
    "text": "Environments\nIt is fiddly getting the environments set up in support of this post. Again, this is due to the infancy of free-threaded Python. So I apologize in advance for how long this environment setup section is.\nI reference two conda environments in this post: a Python 3.13 free-threaded one named py313t, and a normal, not-free-threaded Python 3.13 one named py313.\nThe primary motivation behind the second py313 environment is it allows us to install Jupyter Lab, which, at the time of writing, still isn’t compatible with a Python free-threaded installation. However, we can still register a free-threaded Python kernel with Jupyter, which is all we really care about when running the code in this post in a free-threaded environment.\nDetails on creating the conda environments follow.\n\nFree-Threaded 3.13 Env (py313t)\nI use conda to create the Python 3.13 free-threaded environment plus initial dependencies, activate it, then install the remaining dependencies via pip, as follows:\nconda create -n py313t python=3.13 python-freethreading \\\n    nodejs pip tqdm flake8 rust requests \\\n        -c conda-forge\nconda activate py313t\npip install numpy setuptools_rust regex safetensors\nnodejs is required for the UI component we’ll introduce later. regex, rust, and setuptools_rust are needed for tiktoken, described next. Finally, numpy is for torch, which we install later, too.\n\nTikToken\nTikToken is a fast BPE tokenizer from OpenAI that is used extensively in the emerging Python LLM landscape. At the time of writing, the latest TikToken release was 0.8.0, which was built against PyO3 0.22.2, which isn’t compatible with free-threaded Python.\nThankfully, it was trivial to get a local installation of tiktoken working by cloning the Github repo, bumping the PyO3 version in Cargo.toml, then rebuilding and installing.\n\n\n\n\n\n\nNote\n\n\n\nThis is a perfect example of the type of fiddling around I wanted to avoid by not depending on any external packages other than the bare necessities, such as PyTorch. I made an exception for tiktoken because a) it’s arguably an equally-important part of the LLM stack as torch, and b) it thankfully wasn’t too difficult getting a compatible version of tiktoken installed locally.\n\n\nClone the tiktoken git repo and cd into it as follows:\ngit clone https://github.com/openai/tiktoken\ncd tiktoken\nEdit the Cargo.toml file and change the pyo3 dependency version to at least 0.23.31:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 2eed0c1..6be5f63 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -9,7 +9,7 @@ name = \"_tiktoken\"\n crate-type = [\"cdylib\"]\n \n [dependencies]\n-pyo3 = { version = \"0.22.2\", default-features = false, features = [\"extension-module\", \"macros\"] }\n+pyo3 = { version = \"0.23.3\", default-features = false, features = [\"extension-module\", \"macros\"] }\n \n # tiktoken dependencies\n fancy-regex = \"0.13.0\"\nWith this patch applied, and the py313t conda environment active (with rust and setuptools_rust installed):\npython setup.py build\npython setup.py install\n\n\n\n\n\n\nShow Build & Install Output\n\n\n\n\n\n(py313t) {pytorch} [12.6] [trent@dgx/ttypts/3(~s/tiktoken)%] python setup.py build\nrunning build\nrunning build_py\ncopying tiktoken/_educational.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken/__init__.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken/registry.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken/model.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken/load.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken/core.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken_ext/openai_public.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken_ext\nrunning egg_info\nwriting tiktoken.egg-info/PKG-INFO\nwriting dependency_links to tiktoken.egg-info/dependency_links.txt\nwriting requirements to tiktoken.egg-info/requires.txt\nwriting top-level names to tiktoken.egg-info/top_level.txt\nreading manifest file 'tiktoken.egg-info/SOURCES.txt'\nreading manifest template 'MANIFEST.in'\nwarning: no files found matching 'Makefile'\nadding license file 'LICENSE'\nwriting manifest file 'tiktoken.egg-info/SOURCES.txt'\ncopying tiktoken/py.typed -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\nrunning build_ext\nrunning build_rust\ncargo rustc --lib --message-format=json-render-diagnostics --manifest-path Cargo.toml --release -v --features pyo3/extension-module --crate-type cdylib --\n   Compiling target-lexicon v0.12.16\n   Compiling once_cell v1.20.2\n   Compiling proc-macro2 v1.0.92\n   Compiling unicode-ident v1.0.14\n   Compiling memchr v2.7.4\n   Compiling regex-syntax v0.8.5\n   Compiling libc v0.2.169\n   Compiling autocfg v1.4.0\n   Compiling heck v0.5.0\n   Compiling bit-vec v0.6.3\n   Compiling unindent v0.2.3\n   Compiling indoc v2.0.5\n   Compiling cfg-if v1.0.0\n   Compiling rustc-hash v1.1.0\n     Running `rustc --crate-name build_script_build --edition=2018 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/target-lexicon-0.12.16/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=\"default\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"arch_zkasm\", \"default\", \"serde\", \"serde_support\", \"std\"))' -C metadata=826df8be4fa9ef21 -C extra-filename=-826df8be4fa9ef21 --out-dir /home/trent/src/tiktoken/target/release/build/target-lexicon-826df8be4fa9ef21 -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name once_cell --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/once_cell-1.20.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=\"alloc\"' --cfg 'feature=\"default\"' --cfg 'feature=\"race\"' --cfg 'feature=\"std\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"alloc\", \"atomic-polyfill\", \"critical-section\", \"default\", \"parking_lot\", \"portable-atomic\", \"race\", \"std\", \"unstable\"))' -C metadata=6870d82906744d65 -C extra-filename=-6870d82906744d65 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name build_script_build --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/proc-macro2-1.0.92/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=\"proc-macro\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"default\", \"nightly\", \"proc-macro\", \"span-locations\"))' -C metadata=4463b02a2f05d75c -C extra-filename=-4463b02a2f05d75c --out-dir /home/trent/src/tiktoken/target/release/build/proc-macro2-4463b02a2f05d75c -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name unicode_ident --edition=2018 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/unicode-ident-1.0.14/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values())' -C metadata=17278dafa5f26de9 -C extra-filename=-17278dafa5f26de9 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name memchr --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/memchr-2.7.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"alloc\"' --cfg 'feature=\"std\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"alloc\", \"compiler_builtins\", \"core\", \"default\", \"libc\", \"logging\", \"rustc-dep-of-std\", \"std\", \"use_std\"))' -C metadata=25fa9792dd9399b0 -C extra-filename=-25fa9792dd9399b0 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name regex_syntax --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"default\"' --cfg 'feature=\"std\"' --cfg 'feature=\"unicode\"' --cfg 'feature=\"unicode-age\"' --cfg 'feature=\"unicode-bool\"' --cfg 'feature=\"unicode-case\"' --cfg 'feature=\"unicode-gencat\"' --cfg 'feature=\"unicode-perl\"' --cfg 'feature=\"unicode-script\"' --cfg 'feature=\"unicode-segment\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"arbitrary\", \"default\", \"std\", \"unicode\", \"unicode-age\", \"unicode-bool\", \"unicode-case\", \"unicode-gencat\", \"unicode-perl\", \"unicode-script\", \"unicode-segment\"))' -C metadata=66f570e05dbe3825 -C extra-filename=-66f570e05dbe3825 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name build_script_build --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libc-0.2.169/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=\"default\"' --cfg 'feature=\"std\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"align\", \"const-extern-fn\", \"default\", \"extra_traits\", \"rustc-dep-of-std\", \"rustc-std-workspace-core\", \"std\", \"use_std\"))' -C metadata=42fd5088387abf7a -C extra-filename=-42fd5088387abf7a --out-dir /home/trent/src/tiktoken/target/release/build/libc-42fd5088387abf7a -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name autocfg --edition=2015 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/autocfg-1.4.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values())' -C metadata=b8e4c5d316ce5bfb -C extra-filename=-b8e4c5d316ce5bfb --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name bit_vec --edition=2015 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bit-vec-0.6.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"std\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"default\", \"serde\", \"serde_no_std\", \"serde_std\", \"std\"))' -C metadata=de2a0d1e2ef2490a -C extra-filename=-de2a0d1e2ef2490a --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name heck --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/heck-0.5.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values())' -C metadata=5e22b1dffa7f4255 -C extra-filename=-5e22b1dffa7f4255 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name once_cell --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/once_cell-1.20.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"alloc\"' --cfg 'feature=\"default\"' --cfg 'feature=\"race\"' --cfg 'feature=\"std\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"alloc\", \"atomic-polyfill\", \"critical-section\", \"default\", \"parking_lot\", \"portable-atomic\", \"race\", \"std\", \"unstable\"))' -C metadata=05003007543cfa87 -C extra-filename=-05003007543cfa87 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name unindent --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/unindent-0.2.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values())' -C metadata=d53e2a0385a47a80 -C extra-filename=-d53e2a0385a47a80 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name indoc --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/indoc-2.0.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values())' -C metadata=b4e94d9ecbd21a39 -C extra-filename=-b4e94d9ecbd21a39 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern proc_macro --cap-lints allow`\n     Running `rustc --crate-name cfg_if --edition=2018 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/cfg-if-1.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"compiler_builtins\", \"core\", \"rustc-dep-of-std\"))' -C metadata=e4ded2c19830fbdd -C extra-filename=-e4ded2c19830fbdd --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n     Running `rustc --crate-name rustc_hash --edition=2015 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rustc-hash-1.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"default\"' --cfg 'feature=\"std\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"default\", \"std\"))' -C metadata=b006f4d81e95dfaf -C extra-filename=-b006f4d81e95dfaf --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow`\n   Compiling bit-set v0.5.3\n     Running `rustc --crate-name bit_set --edition=2015 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bit-set-0.5.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"std\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"default\", \"std\"))' -C metadata=40d90f83eb5bab57 -C extra-filename=-40d90f83eb5bab57 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern bit_vec=/home/trent/src/tiktoken/target/release/deps/libbit_vec-de2a0d1e2ef2490a.rmeta --cap-lints allow`\n     Running `/home/trent/src/tiktoken/target/release/build/libc-42fd5088387abf7a/build-script-build`\n     Running `/home/trent/src/tiktoken/target/release/build/proc-macro2-4463b02a2f05d75c/build-script-build`\n   Compiling memoffset v0.9.1\n     Running `rustc --crate-name build_script_build --edition=2015 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/memoffset-0.9.1/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=\"default\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"default\", \"unstable_const\", \"unstable_offset_of\"))' -C metadata=679ebbc3261d6845 -C extra-filename=-679ebbc3261d6845 --out-dir /home/trent/src/tiktoken/target/release/build/memoffset-679ebbc3261d6845 -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern autocfg=/home/trent/src/tiktoken/target/release/deps/libautocfg-b8e4c5d316ce5bfb.rlib --cap-lints allow`\n     Running `rustc --crate-name libc --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libc-0.2.169/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"default\"' --cfg 'feature=\"std\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"align\", \"const-extern-fn\", \"default\", \"extra_traits\", \"rustc-dep-of-std\", \"rustc-std-workspace-core\", \"std\", \"use_std\"))' -C metadata=6b0fbe5bd5ba9d30 -C extra-filename=-6b0fbe5bd5ba9d30 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow --cfg freebsd11 --cfg libc_const_extern_fn --check-cfg 'cfg(emscripten_new_stat_abi)' --check-cfg 'cfg(espidf_time32)' --check-cfg 'cfg(freebsd10)' --check-cfg 'cfg(freebsd11)' --check-cfg 'cfg(freebsd12)' --check-cfg 'cfg(freebsd13)' --check-cfg 'cfg(freebsd14)' --check-cfg 'cfg(freebsd15)' --check-cfg 'cfg(libc_const_extern_fn)' --check-cfg 'cfg(libc_deny_warnings)' --check-cfg 'cfg(libc_thread_local)' --check-cfg 'cfg(libc_ctest)' --check-cfg 'cfg(target_os,values(\"switch\",\"aix\",\"ohos\",\"hurd\",\"rtems\",\"visionos\",\"nuttx\"))' --check-cfg 'cfg(target_env,values(\"illumos\",\"wasi\",\"aix\",\"ohos\"))' --check-cfg 'cfg(target_arch,values(\"loongarch64\",\"mips32r6\",\"mips64r6\",\"csky\"))'`\n     Running `rustc --crate-name proc_macro2 --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/proc-macro2-1.0.92/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=\"proc-macro\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"default\", \"nightly\", \"proc-macro\", \"span-locations\"))' -C metadata=4c69c42d9df03375 -C extra-filename=-4c69c42d9df03375 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern unicode_ident=/home/trent/src/tiktoken/target/release/deps/libunicode_ident-17278dafa5f26de9.rmeta --cap-lints allow --cfg wrap_proc_macro --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(no_is_available)' --check-cfg 'cfg(no_literal_byte_character)' --check-cfg 'cfg(no_literal_c_string)' --check-cfg 'cfg(no_source_text)' --check-cfg 'cfg(proc_macro_span)' --check-cfg 'cfg(procmacro2_backtrace)' --check-cfg 'cfg(procmacro2_nightly_testing)' --check-cfg 'cfg(procmacro2_semver_exempt)' --check-cfg 'cfg(randomize_layout)' --check-cfg 'cfg(span_locations)' --check-cfg 'cfg(super_unstable)' --check-cfg 'cfg(wrap_proc_macro)'`\n     Running `/home/trent/src/tiktoken/target/release/build/target-lexicon-826df8be4fa9ef21/build-script-build`\n     Running `rustc --crate-name target_lexicon --edition=2018 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/target-lexicon-0.12.16/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=\"default\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"arch_zkasm\", \"default\", \"serde\", \"serde_support\", \"std\"))' -C metadata=a879275207ec599a -C extra-filename=-a879275207ec599a --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow --cfg 'feature=\"rust_1_40\"'`\n     Running `/home/trent/src/tiktoken/target/release/build/memoffset-679ebbc3261d6845/build-script-build`\n     Running `rustc --crate-name memoffset --edition=2015 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/memoffset-0.9.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"default\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"default\", \"unstable_const\", \"unstable_offset_of\"))' -C metadata=65fe1a8a113b3005 -C extra-filename=-65fe1a8a113b3005 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --cap-lints allow --cfg tuple_ty --cfg allow_clippy --cfg maybe_uninit --cfg doctests --cfg raw_ref_macros --cfg stable_const --cfg stable_offset_of`\n   Compiling aho-corasick v1.1.3\n     Running `rustc --crate-name aho_corasick --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"perf-literal\"' --cfg 'feature=\"std\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"default\", \"logging\", \"perf-literal\", \"std\"))' -C metadata=6668c9f838fb89b3 -C extra-filename=-6668c9f838fb89b3 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern memchr=/home/trent/src/tiktoken/target/release/deps/libmemchr-25fa9792dd9399b0.rmeta --cap-lints allow`\n   Compiling pyo3-build-config v0.23.3\n     Running `rustc --crate-name build_script_build --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pyo3-build-config-0.23.3/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=\"default\"' --cfg 'feature=\"extension-module\"' --cfg 'feature=\"resolve-config\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"abi3\", \"abi3-py310\", \"abi3-py311\", \"abi3-py312\", \"abi3-py37\", \"abi3-py38\", \"abi3-py39\", \"default\", \"extension-module\", \"python3-dll-a\", \"resolve-config\"))' -C metadata=d8ab86bb094cf645 -C extra-filename=-d8ab86bb094cf645 --out-dir /home/trent/src/tiktoken/target/release/build/pyo3-build-config-d8ab86bb094cf645 -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern target_lexicon=/home/trent/src/tiktoken/target/release/deps/libtarget_lexicon-a879275207ec599a.rlib --cap-lints allow`\n   Compiling quote v1.0.38\n     Running `rustc --crate-name quote --edition=2018 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/quote-1.0.38/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=\"default\"' --cfg 'feature=\"proc-macro\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"default\", \"proc-macro\"))' -C metadata=169332b6fe3d21d6 -C extra-filename=-169332b6fe3d21d6 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern proc_macro2=/home/trent/src/tiktoken/target/release/deps/libproc_macro2-4c69c42d9df03375.rmeta --cap-lints allow`\n   Compiling syn v2.0.95\n     Running `rustc --crate-name syn --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.95/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=\"clone-impls\"' --cfg 'feature=\"default\"' --cfg 'feature=\"derive\"' --cfg 'feature=\"extra-traits\"' --cfg 'feature=\"full\"' --cfg 'feature=\"parsing\"' --cfg 'feature=\"printing\"' --cfg 'feature=\"proc-macro\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"clone-impls\", \"default\", \"derive\", \"extra-traits\", \"fold\", \"full\", \"parsing\", \"printing\", \"proc-macro\", \"test\", \"visit\", \"visit-mut\"))' -C metadata=29d4a0ddbd98f61f -C extra-filename=-29d4a0ddbd98f61f --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern proc_macro2=/home/trent/src/tiktoken/target/release/deps/libproc_macro2-4c69c42d9df03375.rmeta --extern quote=/home/trent/src/tiktoken/target/release/deps/libquote-169332b6fe3d21d6.rmeta --extern unicode_ident=/home/trent/src/tiktoken/target/release/deps/libunicode_ident-17278dafa5f26de9.rmeta --cap-lints allow`\n     Running `/home/trent/src/tiktoken/target/release/build/pyo3-build-config-d8ab86bb094cf645/build-script-build`\n     Running `rustc --crate-name pyo3_build_config --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pyo3-build-config-0.23.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=\"default\"' --cfg 'feature=\"extension-module\"' --cfg 'feature=\"resolve-config\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"abi3\", \"abi3-py310\", \"abi3-py311\", \"abi3-py312\", \"abi3-py37\", \"abi3-py38\", \"abi3-py39\", \"default\", \"extension-module\", \"python3-dll-a\", \"resolve-config\"))' -C metadata=b884267014f5753b -C extra-filename=-b884267014f5753b --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern once_cell=/home/trent/src/tiktoken/target/release/deps/libonce_cell-6870d82906744d65.rmeta --extern target_lexicon=/home/trent/src/tiktoken/target/release/deps/libtarget_lexicon-a879275207ec599a.rmeta --cap-lints allow`\n   Compiling pyo3-ffi v0.23.3\n   Compiling pyo3-macros-backend v0.23.3\n   Compiling pyo3 v0.23.3\n     Running `rustc --crate-name build_script_build --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pyo3-ffi-0.23.3/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type bin --emit=dep-info,link -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=off --cfg 'feature=\"default\"' --cfg 'feature=\"extension-module\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"abi3\", \"abi3-py310\", \"abi3-py311\", \"abi3-py312\", \"abi3-py37\", \"abi3-py38\", \"abi3-py39\", \"default\", \"extension-module\", \"generate-import-lib\"))' -C metadata=5c5f8f108a22b6ae -C extra-filename=-5c5f8f108a22b6ae --out-dir /home/trent/src/tiktoken/target/release/build/pyo3-ffi-5c5f8f108a22b6ae -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern pyo3_build_config=/home/trent/src/tiktoken/target/release/deps/libpyo3_build_config-b884267014f5753b.rlib --cap-lints allow`\n     Running `rustc --crate-name build_script_build --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pyo3-macros-backend-0.23.3/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type bin --emit=dep-info,link -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=off --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"experimental-async\"))' -C metadata=bb4a4b3911c85e51 -C extra-filename=-bb4a4b3911c85e51 --out-dir /home/trent/src/tiktoken/target/release/build/pyo3-macros-backend-bb4a4b3911c85e51 -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern pyo3_build_config=/home/trent/src/tiktoken/target/release/deps/libpyo3_build_config-b884267014f5753b.rlib --cap-lints allow`\n     Running `rustc --crate-name build_script_build --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pyo3-0.23.3/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type bin --emit=dep-info,link -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=off --cfg 'feature=\"extension-module\"' --cfg 'feature=\"indoc\"' --cfg 'feature=\"macros\"' --cfg 'feature=\"pyo3-macros\"' --cfg 'feature=\"unindent\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"abi3\", \"abi3-py310\", \"abi3-py311\", \"abi3-py312\", \"abi3-py37\", \"abi3-py38\", \"abi3-py39\", \"anyhow\", \"auto-initialize\", \"chrono\", \"chrono-tz\", \"default\", \"either\", \"experimental-async\", \"experimental-inspect\", \"extension-module\", \"eyre\", \"full\", \"generate-import-lib\", \"hashbrown\", \"indexmap\", \"indoc\", \"inventory\", \"macros\", \"multiple-pymethods\", \"nightly\", \"num-bigint\", \"num-complex\", \"num-rational\", \"py-clone\", \"pyo3-macros\", \"rust_decimal\", \"serde\", \"smallvec\", \"unindent\"))' -C metadata=65f0dbfaaf67ed5a -C extra-filename=-65f0dbfaaf67ed5a --out-dir /home/trent/src/tiktoken/target/release/build/pyo3-65f0dbfaaf67ed5a -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern pyo3_build_config=/home/trent/src/tiktoken/target/release/deps/libpyo3_build_config-b884267014f5753b.rlib --cap-lints allow`\n   Compiling regex-automata v0.4.9\n     Running `rustc --crate-name regex_automata --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"alloc\"' --cfg 'feature=\"dfa\"' --cfg 'feature=\"dfa-build\"' --cfg 'feature=\"dfa-onepass\"' --cfg 'feature=\"dfa-search\"' --cfg 'feature=\"hybrid\"' --cfg 'feature=\"meta\"' --cfg 'feature=\"nfa\"' --cfg 'feature=\"nfa-backtrack\"' --cfg 'feature=\"nfa-pikevm\"' --cfg 'feature=\"nfa-thompson\"' --cfg 'feature=\"perf\"' --cfg 'feature=\"perf-inline\"' --cfg 'feature=\"perf-literal\"' --cfg 'feature=\"perf-literal-multisubstring\"' --cfg 'feature=\"perf-literal-substring\"' --cfg 'feature=\"std\"' --cfg 'feature=\"syntax\"' --cfg 'feature=\"unicode\"' --cfg 'feature=\"unicode-age\"' --cfg 'feature=\"unicode-bool\"' --cfg 'feature=\"unicode-case\"' --cfg 'feature=\"unicode-gencat\"' --cfg 'feature=\"unicode-perl\"' --cfg 'feature=\"unicode-script\"' --cfg 'feature=\"unicode-segment\"' --cfg 'feature=\"unicode-word-boundary\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"alloc\", \"default\", \"dfa\", \"dfa-build\", \"dfa-onepass\", \"dfa-search\", \"hybrid\", \"internal-instrument\", \"internal-instrument-pikevm\", \"logging\", \"meta\", \"nfa\", \"nfa-backtrack\", \"nfa-pikevm\", \"nfa-thompson\", \"perf\", \"perf-inline\", \"perf-literal\", \"perf-literal-multisubstring\", \"perf-literal-substring\", \"std\", \"syntax\", \"unicode\", \"unicode-age\", \"unicode-bool\", \"unicode-case\", \"unicode-gencat\", \"unicode-perl\", \"unicode-script\", \"unicode-segment\", \"unicode-word-boundary\"))' -C metadata=01135b6ed6d4413e -C extra-filename=-01135b6ed6d4413e --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern aho_corasick=/home/trent/src/tiktoken/target/release/deps/libaho_corasick-6668c9f838fb89b3.rmeta --extern memchr=/home/trent/src/tiktoken/target/release/deps/libmemchr-25fa9792dd9399b0.rmeta --extern regex_syntax=/home/trent/src/tiktoken/target/release/deps/libregex_syntax-66f570e05dbe3825.rmeta --cap-lints allow`\n     Running `/home/trent/src/tiktoken/target/release/build/pyo3-macros-backend-bb4a4b3911c85e51/build-script-build`\n     Running `/home/trent/src/tiktoken/target/release/build/pyo3-ffi-5c5f8f108a22b6ae/build-script-build`\n     Running `/home/trent/src/tiktoken/target/release/build/pyo3-65f0dbfaaf67ed5a/build-script-build`\n     Running `rustc --crate-name pyo3_ffi --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pyo3-ffi-0.23.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' --cfg 'feature=\"default\"' --cfg 'feature=\"extension-module\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"abi3\", \"abi3-py310\", \"abi3-py311\", \"abi3-py312\", \"abi3-py37\", \"abi3-py38\", \"abi3-py39\", \"default\", \"extension-module\", \"generate-import-lib\"))' -C metadata=9ad2a4f2678f35bd -C extra-filename=-9ad2a4f2678f35bd --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern libc=/home/trent/src/tiktoken/target/release/deps/liblibc-6b0fbe5bd5ba9d30.rmeta --cap-lints allow --cfg Py_3_7 --cfg Py_3_8 --cfg Py_3_9 --cfg Py_3_10 --cfg Py_3_11 --cfg Py_3_12 --cfg Py_3_13 --cfg Py_GIL_DISABLED --cfg rustc_has_once_lock --cfg invalid_from_utf8_lint --cfg c_str_lit --cfg diagnostic_namespace --check-cfg 'cfg(Py_LIMITED_API)' --check-cfg 'cfg(Py_GIL_DISABLED)' --check-cfg 'cfg(PyPy)' --check-cfg 'cfg(GraalPy)' --check-cfg 'cfg(py_sys_config, values(\"Py_DEBUG\", \"Py_REF_DEBUG\", \"Py_TRACE_REFS\", \"COUNT_ALLOCS\"))' --check-cfg 'cfg(invalid_from_utf8_lint)' --check-cfg 'cfg(pyo3_disable_reference_pool)' --check-cfg 'cfg(pyo3_leak_on_drop_without_reference_pool)' --check-cfg 'cfg(diagnostic_namespace)' --check-cfg 'cfg(c_str_lit)' --check-cfg 'cfg(rustc_has_once_lock)' --check-cfg 'cfg(Py_3_7)' --check-cfg 'cfg(Py_3_8)' --check-cfg 'cfg(Py_3_9)' --check-cfg 'cfg(Py_3_10)' --check-cfg 'cfg(Py_3_11)' --check-cfg 'cfg(Py_3_12)' --check-cfg 'cfg(Py_3_13)'`\n     Running `rustc --crate-name pyo3_macros_backend --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pyo3-macros-backend-0.23.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=off --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"experimental-async\"))' -C metadata=c7424188824c71f8 -C extra-filename=-c7424188824c71f8 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern heck=/home/trent/src/tiktoken/target/release/deps/libheck-5e22b1dffa7f4255.rmeta --extern proc_macro2=/home/trent/src/tiktoken/target/release/deps/libproc_macro2-4c69c42d9df03375.rmeta --extern pyo3_build_config=/home/trent/src/tiktoken/target/release/deps/libpyo3_build_config-b884267014f5753b.rmeta --extern quote=/home/trent/src/tiktoken/target/release/deps/libquote-169332b6fe3d21d6.rmeta --extern syn=/home/trent/src/tiktoken/target/release/deps/libsyn-29d4a0ddbd98f61f.rmeta --cap-lints allow --cfg rustc_has_once_lock --cfg invalid_from_utf8_lint --cfg c_str_lit --cfg diagnostic_namespace --check-cfg 'cfg(Py_LIMITED_API)' --check-cfg 'cfg(Py_GIL_DISABLED)' --check-cfg 'cfg(PyPy)' --check-cfg 'cfg(GraalPy)' --check-cfg 'cfg(py_sys_config, values(\"Py_DEBUG\", \"Py_REF_DEBUG\", \"Py_TRACE_REFS\", \"COUNT_ALLOCS\"))' --check-cfg 'cfg(invalid_from_utf8_lint)' --check-cfg 'cfg(pyo3_disable_reference_pool)' --check-cfg 'cfg(pyo3_leak_on_drop_without_reference_pool)' --check-cfg 'cfg(diagnostic_namespace)' --check-cfg 'cfg(c_str_lit)' --check-cfg 'cfg(rustc_has_once_lock)' --check-cfg 'cfg(Py_3_7)' --check-cfg 'cfg(Py_3_8)' --check-cfg 'cfg(Py_3_9)' --check-cfg 'cfg(Py_3_10)' --check-cfg 'cfg(Py_3_11)' --check-cfg 'cfg(Py_3_12)' --check-cfg 'cfg(Py_3_13)'`\n   Compiling fancy-regex v0.13.0\n   Compiling regex v1.11.1\n   Compiling bstr v1.11.3\n     Running `rustc --crate-name regex --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-1.11.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"default\"' --cfg 'feature=\"perf\"' --cfg 'feature=\"perf-backtrack\"' --cfg 'feature=\"perf-cache\"' --cfg 'feature=\"perf-dfa\"' --cfg 'feature=\"perf-inline\"' --cfg 'feature=\"perf-literal\"' --cfg 'feature=\"perf-onepass\"' --cfg 'feature=\"std\"' --cfg 'feature=\"unicode\"' --cfg 'feature=\"unicode-age\"' --cfg 'feature=\"unicode-bool\"' --cfg 'feature=\"unicode-case\"' --cfg 'feature=\"unicode-gencat\"' --cfg 'feature=\"unicode-perl\"' --cfg 'feature=\"unicode-script\"' --cfg 'feature=\"unicode-segment\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"default\", \"logging\", \"pattern\", \"perf\", \"perf-backtrack\", \"perf-cache\", \"perf-dfa\", \"perf-dfa-full\", \"perf-inline\", \"perf-literal\", \"perf-onepass\", \"std\", \"unicode\", \"unicode-age\", \"unicode-bool\", \"unicode-case\", \"unicode-gencat\", \"unicode-perl\", \"unicode-script\", \"unicode-segment\", \"unstable\", \"use_std\"))' -C metadata=9ab83d1dbb2872e1 -C extra-filename=-9ab83d1dbb2872e1 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern aho_corasick=/home/trent/src/tiktoken/target/release/deps/libaho_corasick-6668c9f838fb89b3.rmeta --extern memchr=/home/trent/src/tiktoken/target/release/deps/libmemchr-25fa9792dd9399b0.rmeta --extern regex_automata=/home/trent/src/tiktoken/target/release/deps/libregex_automata-01135b6ed6d4413e.rmeta --extern regex_syntax=/home/trent/src/tiktoken/target/release/deps/libregex_syntax-66f570e05dbe3825.rmeta --cap-lints allow`\n     Running `rustc --crate-name fancy_regex --edition=2018 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/fancy-regex-0.13.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"default\"' --cfg 'feature=\"perf\"' --cfg 'feature=\"std\"' --cfg 'feature=\"unicode\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"default\", \"perf\", \"std\", \"track_caller\", \"unicode\"))' -C metadata=2bd42caf041ad10c -C extra-filename=-2bd42caf041ad10c --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern bit_set=/home/trent/src/tiktoken/target/release/deps/libbit_set-40d90f83eb5bab57.rmeta --extern regex_automata=/home/trent/src/tiktoken/target/release/deps/libregex_automata-01135b6ed6d4413e.rmeta --extern regex_syntax=/home/trent/src/tiktoken/target/release/deps/libregex_syntax-66f570e05dbe3825.rmeta --cap-lints allow`\n     Running `rustc --crate-name bstr --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bstr-1.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg 'feature=\"alloc\"' --cfg 'feature=\"default\"' --cfg 'feature=\"std\"' --cfg 'feature=\"unicode\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"alloc\", \"default\", \"serde\", \"std\", \"unicode\"))' -C metadata=cc96e78f4e9fd97f -C extra-filename=-cc96e78f4e9fd97f --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern memchr=/home/trent/src/tiktoken/target/release/deps/libmemchr-25fa9792dd9399b0.rmeta --extern regex_automata=/home/trent/src/tiktoken/target/release/deps/libregex_automata-01135b6ed6d4413e.rmeta --cap-lints allow`\n   Compiling pyo3-macros v0.23.3\n     Running `rustc --crate-name pyo3_macros --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pyo3-macros-0.23.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=off --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"experimental-async\", \"multiple-pymethods\"))' -C metadata=97a13ca0f34dda72 -C extra-filename=-97a13ca0f34dda72 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern proc_macro2=/home/trent/src/tiktoken/target/release/deps/libproc_macro2-4c69c42d9df03375.rlib --extern pyo3_macros_backend=/home/trent/src/tiktoken/target/release/deps/libpyo3_macros_backend-c7424188824c71f8.rlib --extern quote=/home/trent/src/tiktoken/target/release/deps/libquote-169332b6fe3d21d6.rlib --extern syn=/home/trent/src/tiktoken/target/release/deps/libsyn-29d4a0ddbd98f61f.rlib --extern proc_macro --cap-lints allow`\n     Running `rustc --crate-name pyo3 --edition=2021 /home/trent/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pyo3-0.23.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' --cfg 'feature=\"extension-module\"' --cfg 'feature=\"indoc\"' --cfg 'feature=\"macros\"' --cfg 'feature=\"pyo3-macros\"' --cfg 'feature=\"unindent\"' --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values(\"abi3\", \"abi3-py310\", \"abi3-py311\", \"abi3-py312\", \"abi3-py37\", \"abi3-py38\", \"abi3-py39\", \"anyhow\", \"auto-initialize\", \"chrono\", \"chrono-tz\", \"default\", \"either\", \"experimental-async\", \"experimental-inspect\", \"extension-module\", \"eyre\", \"full\", \"generate-import-lib\", \"hashbrown\", \"indexmap\", \"indoc\", \"inventory\", \"macros\", \"multiple-pymethods\", \"nightly\", \"num-bigint\", \"num-complex\", \"num-rational\", \"py-clone\", \"pyo3-macros\", \"rust_decimal\", \"serde\", \"smallvec\", \"unindent\"))' -C metadata=99d0b007138eadf4 -C extra-filename=-99d0b007138eadf4 --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern cfg_if=/home/trent/src/tiktoken/target/release/deps/libcfg_if-e4ded2c19830fbdd.rmeta --extern indoc=/home/trent/src/tiktoken/target/release/deps/libindoc-b4e94d9ecbd21a39.so --extern libc=/home/trent/src/tiktoken/target/release/deps/liblibc-6b0fbe5bd5ba9d30.rmeta --extern memoffset=/home/trent/src/tiktoken/target/release/deps/libmemoffset-65fe1a8a113b3005.rmeta --extern once_cell=/home/trent/src/tiktoken/target/release/deps/libonce_cell-05003007543cfa87.rmeta --extern pyo3_ffi=/home/trent/src/tiktoken/target/release/deps/libpyo3_ffi-9ad2a4f2678f35bd.rmeta --extern pyo3_macros=/home/trent/src/tiktoken/target/release/deps/libpyo3_macros-97a13ca0f34dda72.so --extern unindent=/home/trent/src/tiktoken/target/release/deps/libunindent-d53e2a0385a47a80.rmeta --cap-lints allow --cfg Py_3_7 --cfg Py_3_8 --cfg Py_3_9 --cfg Py_3_10 --cfg Py_3_11 --cfg Py_3_12 --cfg Py_3_13 --cfg Py_GIL_DISABLED --cfg rustc_has_once_lock --cfg invalid_from_utf8_lint --cfg c_str_lit --cfg diagnostic_namespace --check-cfg 'cfg(Py_LIMITED_API)' --check-cfg 'cfg(Py_GIL_DISABLED)' --check-cfg 'cfg(PyPy)' --check-cfg 'cfg(GraalPy)' --check-cfg 'cfg(py_sys_config, values(\"Py_DEBUG\", \"Py_REF_DEBUG\", \"Py_TRACE_REFS\", \"COUNT_ALLOCS\"))' --check-cfg 'cfg(invalid_from_utf8_lint)' --check-cfg 'cfg(pyo3_disable_reference_pool)' --check-cfg 'cfg(pyo3_leak_on_drop_without_reference_pool)' --check-cfg 'cfg(diagnostic_namespace)' --check-cfg 'cfg(c_str_lit)' --check-cfg 'cfg(rustc_has_once_lock)' --check-cfg 'cfg(Py_3_7)' --check-cfg 'cfg(Py_3_8)' --check-cfg 'cfg(Py_3_9)' --check-cfg 'cfg(Py_3_10)' --check-cfg 'cfg(Py_3_11)' --check-cfg 'cfg(Py_3_12)' --check-cfg 'cfg(Py_3_13)'`\n       Dirty tiktoken v0.8.0 (/home/trent/src/tiktoken): the toolchain changed\n   Compiling tiktoken v0.8.0 (/home/trent/src/tiktoken)\n     Running `rustc --crate-name _tiktoken --edition=2021 src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --diagnostic-width=254 --crate-type cdylib --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no --check-cfg 'cfg(docsrs)' --check-cfg 'cfg(feature, values())' -C metadata=2d15c1d1b98ec97b --out-dir /home/trent/src/tiktoken/target/release/deps -C linker=/home/trent/mambaforge/envs/py313t/bin/x86_64-conda-linux-gnu-cc -C strip=debuginfo -L dependency=/home/trent/src/tiktoken/target/release/deps --extern bstr=/home/trent/src/tiktoken/target/release/deps/libbstr-cc96e78f4e9fd97f.rlib --extern fancy_regex=/home/trent/src/tiktoken/target/release/deps/libfancy_regex-2bd42caf041ad10c.rlib --extern pyo3=/home/trent/src/tiktoken/target/release/deps/libpyo3-99d0b007138eadf4.rlib --extern regex=/home/trent/src/tiktoken/target/release/deps/libregex-9ab83d1dbb2872e1.rlib --extern rustc_hash=/home/trent/src/tiktoken/target/release/deps/librustc_hash-b006f4d81e95dfaf.rlib`\nwarning: use of deprecated method `pyo3::IntoPy::into_py`: `IntoPy` is going to be replaced by `IntoPyObject`. See the migration guide (https://pyo3.rs/v0.23.0/migration) for more information.\n   --&gt; src/lib.rs:508:16\n    |\n508 |         buffer.into_py(py)\n    |                ^^^^^^^\n    |\n    = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated associated function `pyo3::types::PyList::new_bound`: renamed to `PyList::new`\n   --&gt; src/lib.rs:555:38\n    |\n555 |         let py_completions = PyList::new_bound(\n    |                                      ^^^^^^^^^\n\nwarning: use of deprecated associated function `pyo3::types::PyList::new_bound`: renamed to `PyList::new`\n   --&gt; src/lib.rs:559:36\n    |\n559 |                 .map(|seq| PyList::new_bound(py, &seq[..])),\n    |                                    ^^^^^^^^^\n\nwarning: use of deprecated method `pyo3::IntoPy::into_py`: `IntoPy` is going to be replaced by `IntoPyObject`. See the migration guide (https://pyo3.rs/v0.23.0/migration) for more information.\n   --&gt; src/lib.rs:561:34\n    |\n561 |         (tokens, py_completions).into_py(py)\n    |                                  ^^^^^^^\n\nwarning: use of deprecated associated function `pyo3::types::PyBytes::new_bound`: renamed to `PyBytes::new`\n   --&gt; src/lib.rs:589:38\n    |\n589 |             Ok(bytes) =&gt; Ok(PyBytes::new_bound(py, &bytes).into()),\n    |                                      ^^^^^^^^^\n\nwarning: use of deprecated associated function `pyo3::types::PyBytes::new_bound`: renamed to `PyBytes::new`\n   --&gt; src/lib.rs:596:32\n    |\n596 |             return Ok(PyBytes::new_bound(py, bytes).into());\n    |                                ^^^^^^^^^\n\nwarning: use of deprecated associated function `pyo3::types::PyBytes::new_bound`: renamed to `PyBytes::new`\n   --&gt; src/lib.rs:599:32\n    |\n599 |             return Ok(PyBytes::new_bound(py, bytes).into());\n    |                                ^^^^^^^^^\n\nwarning: use of deprecated associated function `pyo3::types::PyBytes::new_bound`: renamed to `PyBytes::new`\n   --&gt; src/lib.rs:611:31\n    |\n611 |             .map(|x| PyBytes::new_bound(py, x).into())\n    |                               ^^^^^^^^^\n\nwarning: `tiktoken` (lib) generated 8 warnings\n    Finished `release` profile [optimized] target(s) in 13.17s\nCopying rust artifact from target/release/lib_tiktoken.so to build/lib.linux-x86_64-cpython-313t/tiktoken/_tiktoken.cpython-313t-x86_64-linux-gnu.so\n(py313t) {pytorch} [12.6] [trent@dgx/ttypts/3(~s/tiktoken)%] python setup.py install\nrunning install\n/home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/setuptools/_distutils/cmd.py:79: SetuptoolsDeprecationWarning: setup.py install is deprecated.\n!!\n\n        ********************************************************************************\n        Please avoid running ``setup.py`` directly.\n        Instead, use pypa/build, pypa/installer or other\n        standards-based tools.\n\n        See https://blog.ganssle.io/articles/2021/10/setup-py-deprecated.html for details.\n        ********************************************************************************\n\n!!\n  self.initialize_options()\nrunning build\nrunning build_py\ncopying tiktoken/_educational.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken/__init__.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken/registry.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken/model.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken/load.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken/core.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\ncopying tiktoken_ext/openai_public.py -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken_ext\nrunning egg_info\nwriting tiktoken.egg-info/PKG-INFO\nwriting dependency_links to tiktoken.egg-info/dependency_links.txt\nwriting requirements to tiktoken.egg-info/requires.txt\nwriting top-level names to tiktoken.egg-info/top_level.txt\nreading manifest file 'tiktoken.egg-info/SOURCES.txt'\nreading manifest template 'MANIFEST.in'\nwarning: no files found matching 'Makefile'\nadding license file 'LICENSE'\nwriting manifest file 'tiktoken.egg-info/SOURCES.txt'\ncopying tiktoken/py.typed -&gt; build/lib.linux-x86_64-cpython-313t/tiktoken\nrunning build_ext\nrunning build_rust\ncargo rustc --lib --message-format=json-render-diagnostics --manifest-path Cargo.toml --release -v --features pyo3/extension-module --crate-type cdylib --\n       Fresh target-lexicon v0.12.16\n       Fresh unicode-ident v1.0.14\n       Fresh memchr v2.7.4\n       Fresh regex-syntax v0.8.5\n       Fresh autocfg v1.4.0\n       Fresh aho-corasick v1.1.3\n       Fresh heck v0.5.0\n       Fresh bit-vec v0.6.3\n       Fresh indoc v2.0.5\n       Fresh cfg-if v1.0.0\n       Fresh once_cell v1.20.2\n       Fresh unindent v0.2.3\n       Fresh rustc-hash v1.1.0\n       Fresh proc-macro2 v1.0.92\n       Fresh regex-automata v0.4.9\n       Fresh libc v0.2.169\n       Fresh bit-set v0.5.3\n       Fresh pyo3-build-config v0.23.3\n       Fresh quote v1.0.38\n       Fresh memoffset v0.9.1\n       Fresh bstr v1.11.3\n       Fresh fancy-regex v0.13.0\n       Fresh regex v1.11.1\n       Fresh syn v2.0.95\n       Fresh pyo3-macros-backend v0.23.3\n       Fresh pyo3-ffi v0.23.3\n       Fresh pyo3-macros v0.23.3\n       Fresh pyo3 v0.23.3\n       Fresh tiktoken v0.8.0 (/home/trent/src/tiktoken)\nwarning: use of deprecated method `pyo3::IntoPy::into_py`: `IntoPy` is going to be replaced by `IntoPyObject`. See the migration guide (https://pyo3.rs/v0.23.0/migration) for more information.\n   --&gt; src/lib.rs:508:16\n    |\n508 |         buffer.into_py(py)\n    |                ^^^^^^^\n    |\n    = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated associated function `pyo3::types::PyList::new_bound`: renamed to `PyList::new`\n   --&gt; src/lib.rs:555:38\n    |\n555 |         let py_completions = PyList::new_bound(\n    |                                      ^^^^^^^^^\n\nwarning: use of deprecated associated function `pyo3::types::PyList::new_bound`: renamed to `PyList::new`\n   --&gt; src/lib.rs:559:36\n    |\n559 |                 .map(|seq| PyList::new_bound(py, &seq[..])),\n    |                                    ^^^^^^^^^\n\nwarning: use of deprecated method `pyo3::IntoPy::into_py`: `IntoPy` is going to be replaced by `IntoPyObject`. See the migration guide (https://pyo3.rs/v0.23.0/migration) for more information.\n   --&gt; src/lib.rs:561:34\n    |\n561 |         (tokens, py_completions).into_py(py)\n    |                                  ^^^^^^^\n\nwarning: use of deprecated associated function `pyo3::types::PyBytes::new_bound`: renamed to `PyBytes::new`\n   --&gt; src/lib.rs:589:38\n    |\n589 |             Ok(bytes) =&gt; Ok(PyBytes::new_bound(py, &bytes).into()),\n    |                                      ^^^^^^^^^\n\nwarning: use of deprecated associated function `pyo3::types::PyBytes::new_bound`: renamed to `PyBytes::new`\n   --&gt; src/lib.rs:596:32\n    |\n596 |             return Ok(PyBytes::new_bound(py, bytes).into());\n    |                                ^^^^^^^^^\n\nwarning: use of deprecated associated function `pyo3::types::PyBytes::new_bound`: renamed to `PyBytes::new`\n   --&gt; src/lib.rs:599:32\n    |\n599 |             return Ok(PyBytes::new_bound(py, bytes).into());\n    |                                ^^^^^^^^^\n\nwarning: use of deprecated associated function `pyo3::types::PyBytes::new_bound`: renamed to `PyBytes::new`\n   --&gt; src/lib.rs:611:31\n    |\n611 |             .map(|x| PyBytes::new_bound(py, x).into())\n    |                               ^^^^^^^^^\n\nwarning: `tiktoken` (lib) generated 8 warnings\n    Finished `release` profile [optimized] target(s) in 0.03s\nCopying rust artifact from target/release/lib_tiktoken.so to build/lib.linux-x86_64-cpython-313t/tiktoken/_tiktoken.cpython-313t-x86_64-linux-gnu.so\nrunning install_lib\ncreating /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken_ext\ncopying build/lib.linux-x86_64-cpython-313t/tiktoken_ext/openai_public.py -&gt; /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken_ext\ncreating /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken\ncopying build/lib.linux-x86_64-cpython-313t/tiktoken/_educational.py -&gt; /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken\ncopying build/lib.linux-x86_64-cpython-313t/tiktoken/__init__.py -&gt; /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken\ncopying build/lib.linux-x86_64-cpython-313t/tiktoken/py.typed -&gt; /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken\ncopying build/lib.linux-x86_64-cpython-313t/tiktoken/registry.py -&gt; /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken\ncopying build/lib.linux-x86_64-cpython-313t/tiktoken/model.py -&gt; /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken\ncopying build/lib.linux-x86_64-cpython-313t/tiktoken/load.py -&gt; /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken\ncopying build/lib.linux-x86_64-cpython-313t/tiktoken/_tiktoken.cpython-313t-x86_64-linux-gnu.so -&gt; /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken\ncopying build/lib.linux-x86_64-cpython-313t/tiktoken/core.py -&gt; /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken\nbyte-compiling /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken_ext/openai_public.py to openai_public.cpython-313.pyc\nbyte-compiling /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken/_educational.py to _educational.cpython-313.pyc\nbyte-compiling /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken/__init__.py to __init__.cpython-313.pyc\nbyte-compiling /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken/registry.py to registry.cpython-313.pyc\nbyte-compiling /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken/model.py to model.cpython-313.pyc\nbyte-compiling /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken/load.py to load.cpython-313.pyc\nbyte-compiling /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken/core.py to core.cpython-313.pyc\nrunning install_egg_info\nCopying tiktoken.egg-info to /home/trent/mambaforge/envs/py313t/lib/python3.13t/site-packages/tiktoken-0.8.0-py3.13.egg-info\nrunning install_scripts\n\n\n\nAfter this, you should be able to import the tiktoken module in Python:\n% cd ..\n% python -Xgil=0\nPython 3.13.1 experimental free-threading build | packaged by conda-forge | (main, Jan 13 2025, 09:59:40) [GCC 13.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import tiktoken\n&gt;&gt;&gt;\n\n\nTorch\nInstall PyTorch 2.6 via pip with the conda py313t environment active:\n% conda activate py313t\n% pip install torch==2.6 --index-url https://download.pytorch.org/whl/cu126\nIf you have trouble installing PyTorch, consult their Getting Started guide.\nYou can verify torch installed correctly as follows:\n% python -Xgil=0\nPython 3.13.1 experimental free-threading build | packaged by conda-forge | (main, Jan 13 2025, 09:59:40) [GCC 13.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; torch.cuda.is_available()\nTrue\n\n\nIPython Kernel\nInstalling IPython Kernel allows us to use our free-threaded Python installation via the Jupyter Lab instance we install in the py313 environment.\nconda activate py313t\npip install ipykernel\nOnce ipykernel is installed, run the following:\n% python3.13t -m ipykernel --install --name py313t --user\nInstalled kernelspec py313t in /home/trent/.local/share/jupyter/kernels/py313t\nThis will install a kernel configuration file, kernel.json, which we need to tweak by adding the -Xgil=0 startup flag to the Python interpreter:\n% cd ~/.local/jupyter/share/kernels/py313t\n% cp kernel.json kernel.json.orig\n% vi kernel.json\n# Edit kernel.json to make it look like the diff below.\n% diff -u kernel.json.orig kernel.json\n--- kernel.json.orig    2025-02-04 15:02:21.814112004 -0800\n+++ kernel.json 2025-02-04 15:02:36.553806199 -0800\n@@ -1,6 +1,7 @@\n {\n  \"argv\": [\n   \"/home/trent/mambaforge/envs/py313t/bin/python3.13t\",\n+  \"-Xgil=0\",\n   \"-Xfrozen_modules=off\",\n   \"-m\",\n   \"ipykernel_launcher\",\n@@ -12,4 +13,4 @@\n  \"metadata\": {\n   \"debugger\": true\n  }\n\n(Hidden for now as we removed the immediate need for datrie by fixing the HTTP server routing logic.)\n\nDatrie and Cython\ndatrie is a Python library that provides a trie (or digital search tree) data structure by way of the libdatrie C library. The Python datrie library isn’t strictly necessary to run parallelopedia.gpt2, but other components rely on it, so it’s handy to get installed now, if possible.\nIt relies upon Cython, and thus, for now, you need to install a free-threaded compatible version of Cython first, as follows:\nconda activate py313t\npip install git+https://github.com/cython/cython\nThen, clone the datrie repo and install as follows:\nconda activate py313t\ngit clone https://github.com/pytries/datrie --recursive\ncd datrie\npython setup.py build\npython setup.py install\nIf everything goes well, you should see something like this when you launch Python and import datrie:\n% python\nPython 3.13.1 experimental free-threading build | packaged by conda-forge | (main, Jan 13 2025, 09:59:40) [GCC 13.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import datrie\n&gt;&gt;&gt;\n\n\n\n\n\nNormal 3.13 Env (py313)\nThe second py313 environment is almost identical to py313t, except it is not a python-freethreading installation, and, additionally, we install Jupyter Lab. We can install tiktoken directly via pip, so we don’t need the supporting Rust cruft.\nconda create -n py313 python=3.13 \\\n    nodejs pip tqdm flake8 jupyterlab requests \\\n        -c conda-forge\nconda activate py313\npip install numpy tiktoken safetensors\npip install torch==2.6 --index-url https://download.pytorch.org/whl/cu126"
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#parallelopedia",
    "href": "articles/pytorch-and-python-free-threading/index.html#parallelopedia",
    "title": "PyTorch and Python Free-Threading",
    "section": "Parallelopedia",
    "text": "Parallelopedia\nAll of the code in this article is available in the Parallelopedia repository on Github. The code we’ll be focusing on in this post lives in the parallelopedia.gpt2 module.\nThere is also a web user interface component named Parallelopedia-UI, which we will use later in the post.\nClone the repositories as follows:\n% git clone https://github.com/tpn/parallelopedia\n% git clone https://github.com/tpn/parallelopedia-ui\n\n\n\n\n\n\nImportant Environment Variables\n\n\n\n\n\nThe code and command examples in this post will assume you’ve added the src directory to your PYTHONPATH, the bin directory to your PATH, and set the PARALLELOPEDIA_ROOT environment variable to the root of the repository. You can do this as follows:\ncd parallelopedia\nexport PYTHONPATH=$(pwd)/src:$PYTHONPATH\nexport PATH=$(pwd)/bin:$PATH\nexport PARALLELOPEDIA_ROOT=$(pwd)\ncd ..\ncd parallelopedia-ui\nexport PARALLELOPEDIA_UI=$(pwd)\nIt is recommended that you add these to your shell. For me, using zsh, I use the following:\nexport PARALLELOPEDIA_ROOT=~s1/parallelopedia\nexport PARALLELOPEDIA_UI=~s1/parallelopedia-ui\nexport PYTHONPATH=$PARALLELOPEDIA_ROOT/src:$PYTHONPATH\nexport PATH=$PARALLELOPEDIA_ROOT/bin:$PATH\n\n\n\nYou can perform a quick sanity check that things are working as follows:\n% python -Xgil=0 -m parallelopedia.http.server --help\nusage: server.py [-h] [--ip IP] [--port PORT] [--debug] [--log-level {DEBUG,INFO,WARNING,ERROR,CRITICAL}] [--threads THREADS] [--protocol-class PROTOCOL_CLASS] [--app-classes APP_CLASSES [APP_CLASSES ...]] [--listen-backlog LISTEN_BACKLOG]\n\nRun the HTTP server.\n\noptions:\n  -h, --help            show this help message and exit\n  --ip IP               IP address to bind the server to.\n  --port PORT           Port number to bind the server to.\n  --debug               Enable debug mode for asyncio.\n  --log-level {DEBUG,INFO,WARNING,ERROR,CRITICAL}\n                        Set the logging level.\n  --threads THREADS     Number of threads to use.\n  --protocol-class PROTOCOL_CLASS\n                        The protocol class to use for the server.\n  --app-classes APP_CLASSES [APP_CLASSES ...]\n                        Space-separated list of HTTP application classes.\n  --listen-backlog LISTEN_BACKLOG\n                        The listen backlog for the server."
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#training-gpt-2-124m-locally",
    "href": "articles/pytorch-and-python-free-threading/index.html#training-gpt-2-124m-locally",
    "title": "PyTorch and Python Free-Threading",
    "section": "Training GPT-2 (124M) Locally",
    "text": "Training GPT-2 (124M) Locally\nEquipped with my new knowledge about LLMs, PyTorch, and, thanks to Andrej’s final video in the series titled Let’s reproduce GPT-2 (124M) and the accompanying build-nanogpt Github repo, I was able to train a local GPT-2 model via PyTorch, from scratch, using the edu_fineweb10B dataset.\nI only had to make one change in order to run locally: Use 8 for micro batch size instead of 64. With that change in place, I was able to train GPT-2 from scratch as follows:\n% conda activate py313\n% git clone gh:tpn/build-nanogpt\n% cd build-nanogpt\n# Download the fineweb dataset.\n% python fineweb.py\n# Train!\n% torchrun --standalone --nproc_per_node=4 train_gpt2.py\nThis was run on an NVIDIA DGX workstation from 2017, which has an Intel Xeon(R) CPU E5-2698 v4 @ 2.20GHz (20 cores, 40 threads), and four Tesla V100-DGXS-32GB GPUs.\nTraining in parallel across all four GPUs yielded around 36,000 tokens/sec, with an average time of about 14.5 seconds per loop iteration. Training took about 3 days and 5 hours for 19,072 steps. All four GPUs were pegged close to their 300W power limit for those three days.\n\n\n\n\n\n\nNote\n\n\n\nAmusingly, well after the fact, I decided to see what kind of training performance I’d get on my Windows 11 gaming box (via WSL2 and Ubuntu 22.04), which has an AMD Ryzen 9 7950X3D (16 cores, 32 threads) and NVIDIA RTX 4090. Training via python train_gpt2.py (torchrun wasn’t needed as I wasn’t using multiple GPUs) yielded about 45,000 tokens/sec, which is a nice bump, but what was most impressive was the reduction to the loop iteration duration, which averaged out to about 180ms!\nSo, I could have completed the same training process in about an hour or so, at a vastly reduced impact on my electricity bill that month :-)\n\n\nOnce training completes, a log/model_19072.pt file is produced, which is the checkpoint of the model at that final step, obtained via a call to torch.save(). The model has 124M parameters—which is tiny by modern standards—and is just under 500MB on disk.\nYou can download that very model I trained via the HuggingFace dataset I set up here: model_19072.pt. Once downloaded, place the file in $PARALLELOPEDIA_ROOT/data; alternatively, if you run the Jupyter Notebook below, it’ll automatically download the model from HuggingFace on first run."
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#initial-implementation",
    "href": "articles/pytorch-and-python-free-threading/index.html#initial-implementation",
    "title": "PyTorch and Python Free-Threading",
    "section": "Initial Implementation",
    "text": "Initial Implementation\nThe code below roughly corresponds to my first version of the code in the commit 3ed4fe6: Add gpt2.py, with some formatting and style tweaks to ensure the code is viewable on mobile devices without requiring horizontal scrolling.\nWe’ll revise this code later in the post, but for now, it’s a good starting point to get a feel for how we can use PyTorch to load a GPT-2 model checkpoint, tokenize some input text, and generate some output text.\n\n\n\n\nCode\n# gpt2_v1.ipynb\n\n# ===================================================================\n# Imports\n# ===================================================================\nimport dataclasses\nfrom dataclasses import dataclass\nimport logging\nimport os\nfrom os.path import join, exists\nimport subprocess\nimport sys\nimport textwrap\nfrom textwrap import wrap\nimport time\n\nimport tiktoken\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\n\n# ===================================================================\n# Helper Timer Class\n# ===================================================================\nclass ElapsedTimer:\n    \"\"\"\n    Context manager and reusable timer to measure elapsed time.\n\n    Example:\n        timer = elapsed_timer()\n        with timer:\n            do_something()\n        print(f'Elapsed: {timer.elapsed:.3f}')\n\n        # Re-enterable:\n        with timer:\n            do_something_else()\n        print(f'Elapsed: {timer.elapsed:.3f}')\n    \"\"\"\n\n    def __init__(self):\n        self.start = None\n        self._elapsed = None\n\n    def __enter__(self):\n        self.start = time.perf_counter()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self._elapsed = time.perf_counter() - self.start\n\n    @property\n    def elapsed(self):\n        \"\"\"\n        Return the elapsed time for the most recent context.\n        \"\"\"\n        if self._elapsed is None:\n            raise ValueError(\"Timer has not been used in a context yet.\")\n        return self._elapsed\n\n\n# ===================================================================\n# Globals\n# ===================================================================\n\nLOG_LEVEL = 'DEBUG'\nPARALLELOPEDIA_ROOT = os.environ['PARALLELOPEDIA_ROOT']\nPARALLELOPEDIA_DATA_DIR = join(PARALLELOPEDIA_ROOT, 'data')\nMODEL_CHECKPOINT = join(\n    PARALLELOPEDIA_DATA_DIR,\n    'model_19072.pt',\n)\nMODEL_DOWNLOAD_URL = (\n    \"https://huggingface.co/datasets/trentnelson/\"\n    \"parallelopedia-data-gpt2/resolve/main/model_19072.pt\"\n)\n\n# Download the model from huggingface if necessary.\nos.makedirs(PARALLELOPEDIA_DATA_DIR, exist_ok=True)\n\nif not exists(MODEL_CHECKPOINT):\n    print(f'Downloading {MODEL_DOWNLOAD_URL} via wget '\n          'this might take a while...')\n    args = [\n        \"wget\",\n        \"--quiet\",\n        MODEL_DOWNLOAD_URL,\n        \"-P\",\n        PARALLELOPEDIA_DATA_DIR,\n    ]\n    timer = ElapsedTimer()\n    with timer:\n        subprocess.run(args, check=True)\n    print(f'Downloaded model in {timer.elapsed:.3f} seconds.')\n    \nassert exists(MODEL_CHECKPOINT), \"Missing checkpoint.\"\n\n# ===================================================================\n# Logging\n# ===================================================================\n# N.B. We redirect logs to sys.stdout in order for Quarto to pick\n#      them up and include them in rendering the output.\nlogging.basicConfig(\n    level=getattr(logging, LOG_LEVEL),\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    stream=sys.stdout\n)\n\n# ===================================================================\n# Setup\n# ===================================================================\n\n# Use bfloat16 for matmul precision where possible.\ntorch.set_float32_matmul_precision('high')\n\n# ===================================================================\n# GPT2 PyTorch Model Components\n# ===================================================================\n\n# Now define the classes making up our GPT2 implementation.\n# These map directly to the components introduced by the\n# now-seminal 2017 \"Attention Is All You Need\" paper.\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    Causal self-attention for the GPT2 model.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # Key, query, value projections for all heads, but in a batch.\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n\n        # Output projection.\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        self.c_proj.NANOGPT_SCALE_INIT = 1\n\n        # Regularization.\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        # Batch size, sequence length, embedding dimensionality.\n        B, T, C = (x.size())\n\n        # Calculate query, key, values for all heads in\n        # batch and move head forward to be the batch dim.\n        #\n        # N.B. nh is \"number of heads\", hs is \"head size\",\n        #      and C (number of channels) is nh * hs.\n        #      E.g. in GPT-2 (124M), n_head=12, hs=64, so\n        #      nh*hs=C=768 channels in the Transformer.\n        qkv = self.c_attn(x)\n        q, k, v = qkv.split(self.n_embd, dim=2)\n\n        head_dim = C // self.n_head\n\n        # (B, nh, T, hs)\n        k = k.view(B, T, self.n_head, head_dim).transpose(1, 2)\n\n        # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, head_dim).transpose(1, 2)\n\n        # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, head_dim).transpose(1, 2)\n\n        # Flash attention.\n        y = F.scaled_dot_product_attention(q, k, v, is_causal=True)\n\n        # Re-assemble all head outputs side by side.\n        y = (y.transpose(1, 2).contiguous().view(B, T, C))\n\n        # Output projection.\n        y = self.c_proj(y)\n        return y\n\n\nclass MLP(nn.Module):\n    \"\"\"\n    Multi-layer perceptron for the GPT2 model.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.c_fc = nn.Linear(config.n_embd, 4 * config.n_embd)\n        self.gelu = nn.GELU(approximate='tanh')\n        self.c_proj = nn.Linear(4 * config.n_embd, config.n_embd)\n        self.c_proj.NANOGPT_SCALE_INIT = 1\n\n    def forward(self, x):\n        x = self.c_fc(x)\n        x = self.gelu(x)\n        x = self.c_proj(x)\n        return x\n\n\nclass Block(nn.Module):\n    \"\"\"\n    Transformer block for the GPT2 model.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = MLP(config)\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlp(self.ln_2(x))\n        return x\n\n# ===================================================================\n# GPT2 Supporting Classes\n# ===================================================================\n\n# N.B. These differ slightly from Andrej's classes in\n#      `train_gpt2.py`.  `GPTCheckpoint` is a helper\n#      class I wrote that has no analog in the former.\n\n@dataclass\nclass GPTConfig:\n    \"\"\"\n    Configuration class for GPT model.\n\n    Attributes:\n\n        block_size (int): Maximum sequence length.\n\n        vocab_size (int): Number of tokens.  GPT2 from\n            huggingface has a vocab size of 50257, which\n            includes 50,000 BPE merges, 256 byte tokens,\n            and 1 &lt;|endoftext|&gt; token.  However, Andrej\n            Karpathy's `build-nanogpt/train_gpt2.py`\n            uses a vocab size of 50304.  I vaguely recall\n            the explanation for this discrepancy as a local\n            optimization to yield better alignment sizes,\n            but I'm not 100% certain.\n\n            The local GPT2 training that we did on\n            edu_fineweb10b used 50304, so we will use\n            that here.\n\n        n_layer (int): Number of layers.\n\n        n_head (int): Number of attention heads.\n\n        n_embd (int): Embedding dimension.\n    \"\"\"\n    block_size: int = 1024\n    vocab_size: int = 50304\n    n_layer: int = 12\n    n_head: int = 12\n    n_embd: int = 768\n\n\n\n# ===================================================================\n# GPT2 Model Implementation\n# ===================================================================\n\nclass GPT(nn.Module):\n\n    def __init__(self, config, device):\n        super().__init__()\n        self.config = config\n        self.device = device\n        self.manual_seed = 42\n\n        self.transformer = nn.ModuleDict(\n            dict(\n                wte=nn.Embedding(config.vocab_size, config.n_embd),\n                wpe=nn.Embedding(config.block_size, config.n_embd),\n                h=nn.ModuleList(\n                    [Block(config) for _ in range(config.n_layer)]\n                ),\n                ln_f=nn.LayerNorm(config.n_embd),\n            )\n        )\n        self.lm_head = nn.Linear(\n            config.n_embd, config.vocab_size, bias=False\n        )\n\n        self.transformer.wte.weight = self.lm_head.weight\n        self.apply(self._init_weights)\n\n    def _init_weights(self, module):\n        if isinstance(module, nn.Linear):\n            std = 0.02\n            if hasattr(module, \"NANOGPT_SCALE_INIT\"):\n                std *= (2 * self.config.n_layer) ** -0.5\n            torch.nn.init.normal_(module.weight, mean=0.0, std=std)\n            if module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n\n    def forward(self, idx, targets=None):\n        \"\"\"\n        Forward pass of the GPT model.\n\n        Args:\n            idx (torch.Tensor): Supplies the input tensor of shape\n                (B, T).\n            targets (torch.Tensor): Optionally supplies the target\n                tensor of shape (B, T) for computing the loss.\n\n        \"\"\"\n        (B, T) = idx.size()\n\n        # Forward the token and position embeddings.\n\n        # Shape (T)\n        pos = torch.arange(0, T, dtype=torch.long, device=idx.device)\n\n        # Position embeddings of shape (T, n_embd).\n        pos_emb = self.transformer.wpe(pos)\n\n        # Token embeddings of shape (B, T, n_embd).\n        tok_emb = self.transformer.wte(idx)\n\n        x = tok_emb + pos_emb\n\n        # Forward the blocks of the transformer.\n        for block in self.transformer.h:\n            x = block(x)\n\n        # Forward the final layernorm and the classifier.\n        x = self.transformer.ln_f(x)\n\n        # (B, T, vocab_size)\n        logits = self.lm_head(x)\n\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(\n                logits.view(-1, logits.size(-1)), targets.view(-1)\n            )\n\n        return (logits, loss)\n\n    @classmethod\n    def from_local_pretrained(\n        cls, model_path: str, map_location: str = \"cuda\"\n    ):\n        \"\"\"\n        Load a model from a local checkpoint.\n\n        N.B. This is a new method based off GPT.from_pretrained\n             in Andrej Karpathy's train_gpt2.py.\n\n        Args:\n            cls (type): Supplies the class type.\n\n            model_path (str): Supplies the path to the model\n                checkpoint.\n\n            map_location (str): Supplies the device to which\n                the model will be mapped.\n        \"\"\"\n        with torch.serialization.safe_globals([GPTConfig]):\n            checkpoint = torch.load(\n                model_path,\n                map_location=map_location,\n            )\n\n        config = checkpoint[\"config\"]\n        config = GPTConfig(**checkpoint[\"config\"])\n        model = cls(config, device=map_location)\n        model.load_state_dict(checkpoint[\"model\"])\n        model.eval()\n\n        msg = (\n            f\"Loaded model from step {checkpoint['step']}, \"\n            f\"val_loss {checkpoint['val_loss']}\"\n        )\n        logging.info(msg)\n        return model\n\n    def generate(\n        self, text: str, max_length: int = 1024, top_k: int = 50,\n        seed: int = None,\n    ) -&gt; str:\n        \"\"\"\n        Generate text from the model.\n\n        N.B. This is a new method based off the generation code\n             present in Andrej Karpathy's train_gpt2.py.\n\n        Args:\n\n            text (str): Supplies the prompt.\n\n            max_length (int): Supplies the maximum total length,\n                including prompt.\n\n            top_k (int): Supplies the number of tokens to consider\n                at each generation step.\n\n            seed (int): Optionally supplies the manual seed to use\n                for the generator.  If None, the model's manual\n                seed will be used.\n\n        Returns:\n\n            str: The generated text (including the initial prompt).\n        \"\"\"\n        self.eval()\n        device = self.device\n        # Obtain our GPT2 tokenizer, and resolve the stop token.\n        enc = tiktoken.get_encoding(\"gpt2\")\n        stop_string = '&lt;|endoftext|&gt;'\n        stop_token = enc.n_vocab - 1\n        actual = enc.decode([stop_token])\n        assert actual == stop_string, (\n            f\"expected {stop_string}, got {actual}\"\n        )\n\n        # Encode the prompt.\n        tokens = enc.encode(text)\n        x = torch.tensor(\n            tokens, dtype=torch.long, device=device\n        ).unsqueeze(0)\n\n        # Create a random generator for reproducibility.\n        if seed is None:\n            seed = self.manual_seed\n        sample_rng = torch.Generator(device=device)\n        sample_rng.manual_seed(seed)\n\n        # Generate tokens up to our max length, or until we hit the\n        # stop token.\n        start = time.perf_counter()\n        count = 0\n        while x.size(1) &lt; max_length:\n            count += 1\n            with torch.no_grad():\n                # Forward pass, ignoring the returned loss.\n                (logits, _) = self(x)\n\n            # Take the logits at the last time-step (shape:\n            # (1, vocab_size)).\n            logits = logits[:, -1, :]\n\n            # Convert to probabilities.\n            probs = F.softmax(logits, dim=-1)\n\n            # Top-k sampling.\n            topk_probs, topk_indices = torch.topk(\n                probs, k=top_k, dim=-1\n            )\n\n            # Sample the next token.\n            next_idx = torch.multinomial(\n                topk_probs, num_samples=1, generator=sample_rng\n            )\n            next_token = torch.gather(topk_indices, -1, next_idx)\n\n            # If the next token is the stop token, we're done.\n            if next_token.item() == stop_token:\n                break\n\n            # Otherwise, append the token to the current sequence\n            # and continue generation.\n            x = torch.cat((x, next_token), dim=1)\n\n        end = time.perf_counter()\n        elapsed = end - start\n        tokens_per_sec = float(count) / elapsed\n\n        msg = (\n            f'Generated {count} tokens in {elapsed:.2f} seconds '\n            f'({tokens_per_sec:.2f} tokens/sec)'\n        )\n        logging.debug(msg)\n\n        # Decode the output tokens and return the generated text,\n        # including the initial prompt.\n        output_tokens = x[0].tolist()\n        return enc.decode(output_tokens)"
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#loading-the-model",
    "href": "articles/pytorch-and-python-free-threading/index.html#loading-the-model",
    "title": "PyTorch and Python Free-Threading",
    "section": "Loading the Model",
    "text": "Loading the Model\nWith the code above executed in a preceding Jupyter Notebook cell, we can load the model as follows:\n\n\nmodel = GPT.from_local_pretrained(\n    MODEL_CHECKPOINT,\n    map_location='cuda',\n)\nmodel.to('cuda')\n\n2025-02-09 15:26:39,136 - INFO - Loaded model from step 19072, val_loss 3.0519702434539795\n\n\nGPT(\n  (transformer): ModuleDict(\n    (wte): Embedding(50304, 768)\n    (wpe): Embedding(1024, 768)\n    (h): ModuleList(\n      (0-11): 12 x Block(\n        (ln_1): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n        (attn): CausalSelfAttention(\n          (c_attn): Linear(in_features=768, out_features=2304, bias=True)\n          (c_proj): Linear(in_features=768, out_features=768, bias=True)\n        )\n        (ln_2): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n        (mlp): MLP(\n          (c_fc): Linear(in_features=768, out_features=3072, bias=True)\n          (gelu): GELU(approximate='tanh')\n          (c_proj): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n    )\n    (ln_f): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n  )\n  (lm_head): Linear(in_features=768, out_features=50304, bias=False)\n)"
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#generating-text",
    "href": "articles/pytorch-and-python-free-threading/index.html#generating-text",
    "title": "PyTorch and Python Free-Threading",
    "section": "Generating Text",
    "text": "Generating Text\nOnce we’ve got a model instance, text can be generated by simply calling the model’s generate() function with a prompt, and, optionally, some additional parameters like seed and max length. This is also referred to as inference—the two terms are interchangeable, and mean the same thing: the act of providing some input tokens—your encoded prompt—to your trained model, and having it generate tokens in response.\nNote that this isn’t a chat or instruction model, nor has it been fine-tuned to remotely resemble something actually usable. So you can’t ask it questions or have it write code for you.\nWhat you can do, though, is provide it with a half written sentence, and then laugh at the ridiculous content it generates in response. Although note that its syntax is pretty good—the model has clearly learned enough during training about how the English language is structured, which words make sense when placed together, that sort of thing. It just has no clue about underlying semantics.\n\n\n\nprompt = \"Albert Einstein's Theory of Relativity stated that\"\nresult = model.generate(prompt, seed=42)\nprint('\\n' + textwrap.fill(result, width=105))\n\n2025-02-09 15:26:40,464 - DEBUG - Generated 79 tokens in 0.81 seconds (98.10 tokens/sec)\n\nAlbert Einstein's Theory of Relativity stated that the speed of light was approximately 10 000 of\nparsecs, whereas quantum physicists have suggested that, as we move further into the universe, the\nuniverse might grow older. The new experiment, conducted by researchers at the University of New Jersey,\nNew York, and the University of California, Berkeley shows that photons travelling at the speed of light\nwill be around 30 to 65 kilometres per second.\n\n\n\n\n\n\n\nprompt = \"Albert Einstein's Theory of Relativity stated that\"\nresult = model.generate(prompt, seed=42)\nprint('\\n' + textwrap.fill(result, width=58))\n\n2025-02-09 15:26:41,014 - DEBUG - Generated 79 tokens in 0.54 seconds (145.49 tokens/sec)\n\nAlbert Einstein's Theory of Relativity stated that the\nspeed of light was approximately 10 000 of parsecs,\nwhereas quantum physicists have suggested that, as we move\nfurther into the universe, the universe might grow older.\nThe new experiment, conducted by researchers at the\nUniversity of New Jersey, New York, and the University of\nCalifornia, Berkeley shows that photons travelling at the\nspeed of light will be around 30 to 65 kilometres per\nsecond.\n\n\n\n\n\n\n\nprompt = \"Albert Einstein's Theory of Relativity stated that\"\nresult = model.generate(prompt, seed=42)\nprint('\\n' + textwrap.fill(result, width=45))\n\n2025-02-09 15:26:41,565 - DEBUG - Generated 79 tokens in 0.54 seconds (145.05 tokens/sec)\n\nAlbert Einstein's Theory of Relativity stated\nthat the speed of light was approximately 10\n000 of parsecs, whereas quantum physicists\nhave suggested that, as we move further into\nthe universe, the universe might grow older.\nThe new experiment, conducted by researchers\nat the University of New Jersey, New York,\nand the University of California, Berkeley\nshows that photons travelling at the speed of\nlight will be around 30 to 65 kilometres per\nsecond.\n\n\n\n\nNow, it’s worth noting at this point that a 124 million parameter GPT2 model, trained from scratch for 19,072 iterations on the edu_fineweb10b data set, with a final loss score of 3.052, is, quite frankly, hot garbage :-)\nDo not be expecting output from this model to rival anything close to what you’d expect from a contemporary LLM. In fact, we can’t even rely on it to even remotely generate content that is factual in nature. It spews hot probabilisitic garbage that mostly conforms to the structure of the English language.\nBut at least it’s our hot garbage that we trained from nothing, and it’s all we need to start playing around with generating text in parallel.\n\n\n\n\n\n\nHot Garbage Example\n\n\n\n\n\nProvide a slightly different seed to the prompt above and you’ll precisely see some hot garbage generation in action. In the following example, with an identical prompt as the one prior, it just streams nonsense until hitting its max token limit, nary a stop token in sight.\n\n\n\nresult = model.generate(prompt, seed=20190903)\nprint('\\n' + textwrap.fill(result, width=100))\n\n2025-02-09 15:26:57,518 - DEBUG - Generated 1015 tokens in 15.95 seconds (63.65 tokens/sec)\n\nAlbert Einstein's Theory of Relativity stated that the speed of light is the same as it is in two\nplaces, which means that a given speed can either be described by two different speed equations\ndirectly or they may be both equations. It is then assumed that the speed of light is the speed of\nthe universe or the universe's existence relative to Earth. In relativity, a measure of the speed of\nlight is the absolute speed of the light. As long as the speed of light is less than its speed in\ntwo different places, the absolute speed can be calculated. For example, the absolute speed is\n1/2990000000 (2,299,792,458) km/hr with an absolute speed about 10 times as fast as it is in two\ndifferent places. Now we can use the following equation to describe the speed of light: E = C/C2 The\nspeed of light, as a function of C, is a constant. By Einstein's definition of relativity, the speed\nof light is a constant. This is because light travels at its maximum speed along the direction (if\nit's travelling above the speed of light, the point where light must be observed is called\n\"aperture\" of the speed of light). The speed of light is about half as fast as the speed of light\nbecause the speed of light has a smaller varying velocity for each direction of radiation. The speed\nof light, as a function of C, is a constant. The speed of a wave is the constant measured along the\ndirection of the wave relative to its location in space. E = C/C2 where E is the speed of light\nalong the direction of the wave. Because the speed of the wave is the speed of the particle in the\nwave, and c the speed of the particle, E's is also given by the speed of light. For example, a light\nparticle is moving from its place of greatest velocity to its location of greatest velocity. E.g. C\n= F/d, C = d/d For most materials and most other objects, the speed of light is the same for all\nwavelengths. The speed of light is, on the other hand, the speed of the energy form of a photon.\nE.g. c = C/d, C = e/d For most particles, light travels over one degree of separation and this is\nhow photons interact with other particles. We can compare a particle's velocity to an object's\nvelocity. The speed of light is measured by the distance between the particle's nose and the surface\nof the object. For example, a photon of light emits the energy of a single photon. If a photon of\nanother type is fired at the same speed as the first, it will get out of the light, but a photon of\nthe other type will not get back to the ground. The fractional energy will be reduced. The distance\nbetween two photons of the same type will be reduced to the square of their energies. E.g. C = C/C2,\nC = -D/d., D = 9/6 A photon of color does not have sufficient energy to be emitted by that color and\nis therefore subject to The speed of light is the change in velocity over time. This is a constant,\nbut sometimes it is possible to express it like this: E = c2/e In relativity, the length of the\ndistance is the length of time the length of wave is divided by the speed of light. E.g. a beam of\nlight travelling at about 9.2 miles per second must travel at around 7.3 miles per second to get\nE.g. a beam moving at 3.2 miles per second must travel at around 8 miles per second to get E.g. a\nbeam moving at 1.8 miles per second must travel at 9.0 miles per second to get E.g. an object going\nat 2.3 miles per second must travel at 1.8 miles per second to get E.g. a beam moving at 2.3 miles\nper second must travel at 3.4 miles per second to get E.g.. a beam traveling at 3.4 miles per second\nto get E.g.. a beam moving at 2.3 miles per second must travel at 3.8 miles per second to get E.g..\na beam traveling at 3.8 miles per second to get E.g.. a beam moving at about 4.4 miles per second\nmust travel at about 3.9 miles per second to get E.g.. a beam moving at 5.5 miles per second to get\na beam moving at 5.9 miles per S.G.D.. is the same thing as a mass. The distance is a unit in terms\nof the speed of light. Determining the speed of light is an additional measure of the energy. For\nmost things\n\n\n\n\n\n\n\nresult = model.generate(prompt, seed=20190903)\nprint('\\n' + textwrap.fill(result, width=54))\n\n2025-02-09 15:27:13,333 - DEBUG - Generated 1015 tokens in 15.81 seconds (64.21 tokens/sec)\n\nAlbert Einstein's Theory of Relativity stated that the\nspeed of light is the same as it is in two places,\nwhich means that a given speed can either be described\nby two different speed equations directly or they may\nbe both equations. It is then assumed that the speed\nof light is the speed of the universe or the\nuniverse's existence relative to Earth. In relativity,\na measure of the speed of light is the absolute speed\nof the light. As long as the speed of light is less\nthan its speed in two different places, the absolute\nspeed can be calculated. For example, the absolute\nspeed is 1/2990000000 (2,299,792,458) km/hr with an\nabsolute speed about 10 times as fast as it is in two\ndifferent places. Now we can use the following\nequation to describe the speed of light: E = C/C2 The\nspeed of light, as a function of C, is a constant. By\nEinstein's definition of relativity, the speed of\nlight is a constant. This is because light travels at\nits maximum speed along the direction (if it's\ntravelling above the speed of light, the point where\nlight must be observed is called \"aperture\" of the\nspeed of light). The speed of light is about half as\nfast as the speed of light because the speed of light\nhas a smaller varying velocity for each direction of\nradiation. The speed of light, as a function of C, is\na constant. The speed of a wave is the constant\nmeasured along the direction of the wave relative to\nits location in space. E = C/C2 where E is the speed\nof light along the direction of the wave. Because the\nspeed of the wave is the speed of the particle in the\nwave, and c the speed of the particle, E's is also\ngiven by the speed of light. For example, a light\nparticle is moving from its place of greatest velocity\nto its location of greatest velocity. E.g. C = F/d, C\n= d/d For most materials and most other objects, the\nspeed of light is the same for all wavelengths. The\nspeed of light is, on the other hand, the speed of the\nenergy form of a photon. E.g. c = C/d, C = e/d For\nmost particles, light travels over one degree of\nseparation and this is how photons interact with other\nparticles. We can compare a particle's velocity to an\nobject's velocity. The speed of light is measured by\nthe distance between the particle's nose and the\nsurface of the object. For example, a photon of light\nemits the energy of a single photon. If a photon of\nanother type is fired at the same speed as the first,\nit will get out of the light, but a photon of the\nother type will not get back to the ground. The\nfractional energy will be reduced. The distance\nbetween two photons of the same type will be reduced\nto the square of their energies. E.g. C = C/C2, C =\n-D/d., D = 9/6 A photon of color does not have\nsufficient energy to be emitted by that color and is\ntherefore subject to The speed of light is the change\nin velocity over time. This is a constant, but\nsometimes it is possible to express it like this: E =\nc2/e In relativity, the length of the distance is the\nlength of time the length of wave is divided by the\nspeed of light. E.g. a beam of light travelling at\nabout 9.2 miles per second must travel at around 7.3\nmiles per second to get E.g. a beam moving at 3.2\nmiles per second must travel at around 8 miles per\nsecond to get E.g. a beam moving at 1.8 miles per\nsecond must travel at 9.0 miles per second to get E.g.\nan object going at 2.3 miles per second must travel at\n1.8 miles per second to get E.g. a beam moving at 2.3\nmiles per second must travel at 3.4 miles per second\nto get E.g.. a beam traveling at 3.4 miles per second\nto get E.g.. a beam moving at 2.3 miles per second\nmust travel at 3.8 miles per second to get E.g.. a\nbeam traveling at 3.8 miles per second to get E.g.. a\nbeam moving at about 4.4 miles per second must travel\nat about 3.9 miles per second to get E.g.. a beam\nmoving at 5.5 miles per second to get a beam moving at\n5.9 miles per S.G.D.. is the same thing as a mass. The\ndistance is a unit in terms of the speed of light.\nDetermining the speed of light is an additional\nmeasure of the energy. For most things\n\n\n\n\n\n\n\nresult = model.generate(prompt, seed=20190903)\nprint('\\n' + textwrap.fill(result, width=40))\n\n2025-02-09 15:27:56,654 - DEBUG - Generated 1015 tokens in 15.89 seconds (63.87 tokens/sec)\n\nAlbert Einstein's Theory of Relativity\nstated that the speed of light is the\nsame as it is in two places, which means\nthat a given speed can either be\ndescribed by two different speed\nequations directly or they may be both\nequations. It is then assumed that the\nspeed of light is the speed of the\nuniverse or the universe's existence\nrelative to Earth. In relativity, a\nmeasure of the speed of light is the\nabsolute speed of the light. As long as\nthe speed of light is less than its\nspeed in two different places, the\nabsolute speed can be calculated. For\nexample, the absolute speed is\n1/2990000000 (2,299,792,458) km/hr with\nan absolute speed about 10 times as fast\nas it is in two different places. Now we\ncan use the following equation to\ndescribe the speed of light: E = C/C2\nThe speed of light, as a function of C,\nis a constant. By Einstein's definition\nof relativity, the speed of light is a\nconstant. This is because light travels\nat its maximum speed along the direction\n(if it's travelling above the speed of\nlight, the point where light must be\nobserved is called \"aperture\" of the\nspeed of light). The speed of light is\nabout half as fast as the speed of light\nbecause the speed of light has a smaller\nvarying velocity for each direction of\nradiation. The speed of light, as a\nfunction of C, is a constant. The speed\nof a wave is the constant measured along\nthe direction of the wave relative to\nits location in space. E = C/C2 where E\nis the speed of light along the\ndirection of the wave. Because the speed\nof the wave is the speed of the particle\nin the wave, and c the speed of the\nparticle, E's is also given by the speed\nof light. For example, a light particle\nis moving from its place of greatest\nvelocity to its location of greatest\nvelocity. E.g. C = F/d, C = d/d For most\nmaterials and most other objects, the\nspeed of light is the same for all\nwavelengths. The speed of light is, on\nthe other hand, the speed of the energy\nform of a photon. E.g. c = C/d, C = e/d\nFor most particles, light travels over\none degree of separation and this is how\nphotons interact with other particles.\nWe can compare a particle's velocity to\nan object's velocity. The speed of light\nis measured by the distance between the\nparticle's nose and the surface of the\nobject. For example, a photon of light\nemits the energy of a single photon. If\na photon of another type is fired at the\nsame speed as the first, it will get out\nof the light, but a photon of the other\ntype will not get back to the ground.\nThe fractional energy will be reduced.\nThe distance between two photons of the\nsame type will be reduced to the square\nof their energies. E.g. C = C/C2, C =\n-D/d., D = 9/6 A photon of color does\nnot have sufficient energy to be emitted\nby that color and is therefore subject\nto The speed of light is the change in\nvelocity over time. This is a constant,\nbut sometimes it is possible to express\nit like this: E = c2/e In relativity,\nthe length of the distance is the length\nof time the length of wave is divided by\nthe speed of light. E.g. a beam of light\ntravelling at about 9.2 miles per second\nmust travel at around 7.3 miles per\nsecond to get E.g. a beam moving at 3.2\nmiles per second must travel at around 8\nmiles per second to get E.g. a beam\nmoving at 1.8 miles per second must\ntravel at 9.0 miles per second to get\nE.g. an object going at 2.3 miles per\nsecond must travel at 1.8 miles per\nsecond to get E.g. a beam moving at 2.3\nmiles per second must travel at 3.4\nmiles per second to get E.g.. a beam\ntraveling at 3.4 miles per second to get\nE.g.. a beam moving at 2.3 miles per\nsecond must travel at 3.8 miles per\nsecond to get E.g.. a beam traveling at\n3.8 miles per second to get E.g.. a beam\nmoving at about 4.4 miles per second\nmust travel at about 3.9 miles per\nsecond to get E.g.. a beam moving at 5.5\nmiles per second to get a beam moving at\n5.9 miles per S.G.D.. is the same thing\nas a mass. The distance is a unit in\nterms of the speed of light. Determining\nthe speed of light is an additional\nmeasure of the energy. For most things\n\n\n\n\nlolwat."
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#pure-python-multi-threaded-http-server",
    "href": "articles/pytorch-and-python-free-threading/index.html#pure-python-multi-threaded-http-server",
    "title": "PyTorch and Python Free-Threading",
    "section": "Pure Python Multi-threaded HTTP Server",
    "text": "Pure Python Multi-threaded HTTP Server\nFirst thing we need is a nice and simple asyncio-based HTTP server, that also happens to work with multi-threading now that we have a free-threaded Python at our disposal.\nLuckily, I have one of those laying around already! In support of another article I’m actively working on (which was meant to get published before this post), I ported the HTTP Server I wrote many years ago for PyParallel2 to use the new asyncio facilities available with Python, and then slapped multiple threads on it, where each thread gets its own asyncio event loop.\nTurns out, thankfully, that this Just Works, at least on Linux3—we can now have a pure Python HTTP server, running in a single Python process, that’ll happily saturate every CPU core under load.\nThe server code lives in parallelopedia.http.server, and it includes a super janky little notion of “HTTP Apps”, the purpose of which can be best demonstrated with a simple example:\nclass PlaintextApp(HttpApp):\n    @route\n    def plaintext(self, request):\n        response = text_response(request, 'Hello, World!')\n        self.server.send_response(response)\n\nclass SleeperApp(HttpApp):\n    @route\n    def sleep(self, request, seconds):\n        time.sleep(int(seconds))\n        msg = f'Slept for {seconds} seconds.')\n        response = text_response(request, msg)\n        self.server.send_response(response)\n\n# Create a server with the two apps.\napp_classes=[PlaintextApp, SleeperApp]\nserver = HttpServer(app_classes=app_classes)\nIn the above example, the HTTP server will route requests for the /plaintext endpoint to an instance of the PlaintextApp’s plaintext() routine, and /sleep requests get routed to the SleeperApp’s sleep() routine.\nThe “slapped multiple threads on it” activity I refered to earlier is handled by some new async and threading scaffolding added to the bottom of that module, with the pertinent pieces reproduced below:\n\nasync def main_async(\n    args: argparse.Namespace,\n    protocol_class: type,\n    *protocol_args: Tuple\n) -&gt; None:\n    \"\"\"\n    This is the main function for the server when it is running in\n    asynchronous mode.  It will create a server instance and then\n    call serve_forever() on it.\n\n    Arguments:\n\n        args (argparse.Namespace): Supplies the command-line arguments.\n\n        protocol_class (type): Supplies the protocol class to use.\n\n        protocol_args (tuple): Supplies the arguments to pass to the\n            protocol class constructor.\n\n    \"\"\"\n    loop = asyncio.get_running_loop()\n\n    if os.name in ('nt', 'cygwin'):\n        reuse_port = False\n    else:\n        reuse_port = True\n\n    reuse_address = True\n\n    server = await loop.create_server(\n        lambda: protocol_class(*protocol_args),\n        args.ip,\n        args.port,\n        backlog=args.listen_backlog,\n        reuse_address=reuse_address,\n        reuse_port=reuse_port,\n    )\n\n    async with server:\n        await server.serve_forever()\n\n\ndef start_event_loop(\n    args: argparse.Namespace,\n    protocol_class: type,\n    *protocol_args: Tuple\n) -&gt; None:\n    \"\"\"\n    This function will start the asyncio event loop and run\n    the main_async() function.  It is intended to be the\n    target of a threading.Thread.\n\n    Arguments:\n\n        args (argparse.Namespace): Supplies the command-line arguments.\n\n        protocol_class (type): Supplies the protocol class to use.\n\n        protocol_args (tuple): Supplies the arguments to pass to the\n            protocol class constructor.\n    \"\"\"\n    asyncio.run(\n        main_async(\n            args,\n            protocol_class,\n            *protocol_args,\n        ),\n        debug=args.debug,\n    )\n\n\ndef main_threaded_multi_accept(\n    args: argparse.Namespace,\n    protocol_class: type,\n    *protocol_args: Tuple\n) -&gt; None:\n    \"\"\"\n    This is the main function for the server when it is running in\n    multi-threaded mode with multiple accept sockets.  Each thread\n    will have its own asyncio loop issue a create_server() call for\n    the given host/port and protocol.\n\n    Arguments:\n\n        args (argparse.Namespace): Supplies the command-line arguments.\n\n        protocol_class (type): Supplies the protocol class to use.\n\n        protocol_args (tuple): Supplies the arguments to pass to the\n            protocol class constructor.\n    \"\"\"\n    import threading\n\n    threads = []\n    for _ in range(args.threads):\n        thread = threading.Thread(\n            target=start_event_loop,\n            args=(args, protocol_class, *protocol_args),\n        )\n        threads.append(thread)\n        thread.start()\n\n    for thread in threads:\n        thread.join()\n\n\ndef main(args: Optional[argparse.Namespace] = None):\n    \"\"\"\n    Main entry point for parallelopedia.http.server module.\n    \"\"\"\n    args = parse_arguments()\n\n    logging.basicConfig(\n        level=getattr(logging, args.log_level),\n        format='%(asctime)s - %(levelname)s - %(message)s',\n    )\n\n    # Use multiple threads to load the application classes.\n    app_classes = get_classes_from_strings_parallel(\n        args.app_classes,\n    )\n\n    protocol_class = get_class_from_string(args.protocol_class)\n    protocol_args = (app_classes,)\n\n    if args.threads == 1:\n        asyncio.run(\n            main_async(\n                args,\n                protocol_class,\n                *protocol_args,\n            ),\n            debug=args.debug,\n        )\n    else:\n        main_threaded_multi_accept(\n            args,\n            protocol_class,\n            *protocol_args,\n        )\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#gpt2-http-app",
    "href": "articles/pytorch-and-python-free-threading/index.html#gpt2-http-app",
    "title": "PyTorch and Python Free-Threading",
    "section": "GPT2 HTTP App",
    "text": "GPT2 HTTP App\nWith the HTTP server scaffolding in place, we can now whip up a little Gpt2App class that has a generate() method. Incoming requests to the /generate endpoint will be routed to that routine by the server.\n\nSynchronous Up-Front Generation\nNow, we could take the simple approach, where the Gpt2App.generate() call goes off and calls model.generate() and then patiently waits for the entire response to be generated before sending anything back to the user.\nThat code would look something like this:\nclass Gpt2App(HttpApp):\n    @route\n    def generate(self, request: Request,\n                 *args: List,\n                 **kwds: Dict) -&gt; None:\n        prompt = args[0]\n        model = get_model()\n        result = model.generate(prompt=prompt)\n        respose = text_response(request, result)\n        self.server.send_response(response)\nBut when have you ever interacted with an LLM via a web interface where it waits until it generates all of the response up-front before sending it back to you? Never; you can see it generate the response in real time, and that’s what we want to mimic here in this experiment.\n\n\nOur Goals\nThe high-level goals for our solution are thus:\n\nWe want to send a generated token back to the user as soon as it becomes available.\nWe want to ensure the client receiving the token can display it as soon as they receive it—so we need to be cognizant of what HTTP transfer protocol we use to send bytes back. If we just used normal HTTP transfer encoding, the client would wait until we’ve sent everything before the user sees it, despite the fact that we’ve been trickling individual tokens to them the entire time.\nWe want to play nicely with the asyncio ecosystem upon which our hosting HTTP server is based—so we need to be cognizant of the current thread’s event loop, and make sure we don’t impede that thread’s ability to concurrently serve other clients that are being handled by the event loop.\n\nThankfully, as we saw earlier with the implementation of the GPT.generate() routine, generating tokens in response to a prompt is inherently a token-by-token process. So the algorithm at least provides us with the means to obtain a single token at a time, which takes care of the first point.\nSecond, HTTP’s chunked-encoding transfer protocol will allow a HTTP client to immediately “see” the tokens we send back to it as soon as we send them, provided we enable TCP_NODELAY on the underlying socket to ensure the operating system sends the bytes out to the client as soon as we send them.\n\n\n\n\n\n\nNote\n\n\n\nIf we didn’t do this, the default behavior of Nagle’s algorithm would apply, and the operating system would delay sending individual bytes back when we request, in the hope that it can accumulate more bytes to send all at once at a slightly later point in time. This is advantageous for maximizing throughput, but it impedes latency, and in our case, we want the lower latency afforded by immediately sending the bytes back to the client as soon as we generate them.\n\n\nChunked-encoding works by setting an HTTP response header Transfer-Encoding: chunked, and then in the body, each chunk is transmitted by its length and then the chunk itself. The server communicates to the client that the transfer has completed once a zero-length chunk is received.\nSo, as long as we send our tokens back via chunked-encoding, any HTTP/1.1 client will be able to reassemble them back into the generated text, giving the visual appearance of real time model generation. That will take care of the second point.\nLastly, in order to play nice within the greater asyncio ecosystem, we need to give control back to the underlying thread’s asyncio event loop after we generate a token and yield a decoded text fragment, which can thankfully be done via a simple call to await asyncio.sleep(0), provided we’re generating text from the model from within an async callback.\nThis ensures multiple concurrent clients being handled by our thread’s event loop will be handled fairly; they’ll all receive generated tokens at the same rate.\n\n\nAsynchronous Token-by-Token Generation\nThe first thing we need to do is to change our Gpt2App.generate() call into something that is async compatible, in anticipation of some later code that we write needing to issue an await asyncio.sleep(0), which can only be done within a call frame of an asynchronous method.\nWhen our Gpt2App.generate() routine is called, we’re still within the context of the asyncio protocol’s data_received() routine, which is a normal, synchronous method, not an enlightened async method that can participate in an asyncio event loop.\nSo, in order to transition from a synchronous callback to an asynchronous one, we can use the current event loop’s create_task() routine to enqueue an async method for execution.\n\nStep 1: Have generate() enqueue an async generate_response().\nThus, our Gpt2App.generate() call will look something like this:\n\nclass Gpt2App(HttpApp):\n\n    ...\n\n    @route\n    def generate(self, request: Request,\n                 *args: List,\n                 **kwds: Dict) -&gt; None:\n\n        # Extract the \"prompt\" provided in the incoming request.\n        text = args[0]\n\n        # Obtain the event loop and schedule the response\n        # generation via our async generation coroutine.\n        # We have to do it like this as at this point we're\n        # still within the call frame of the data_received()\n        # protocol callback, which isn't an async function.\n        loop = asyncio.get_running_loop()\n        async_task = self.generate_response(request, text, **kwds)\n        loop.create_task(async_task)\n\n\nStep 2: Implement an async generate_response()\nOur asynchronous generate_response() routine will be the bridge between generating tokens from the model, and sending those tokens back to the client via chunked-encoding.\nIt is responsible for preparing the response to use chunked-encoding, and then enabling TCP_NODELAY on the socket.\nThen, assuming that our model has an async_generate_for() routine, which we’ll implement in the next step, we perform an async for loop over that routine in order to obtain individual decoded tokens. As soon as we receive a token, we can send it back to the client via the response object’s send_chunk() routine.\nOnce we’ve exhausted the async generator (i.e. it either generated the maximum number of requested tokens, or it encountered a stop token), we can re-enable TCP_NODELAY, and then return.\nA simplified version of the Python code is presented below. I have omitted most of the error handling and query parameter parsing code for simplicity; see the expandable code block at the end for the full version.\n\nclass Gpt2App(HttpApp):\n\n    ...\n\n    async def generate_response(\n        self, request: Request,\n        prompt: str,\n        **kwds: Dict\n    ) -&gt; None:\n\n        # Prepare a chunked-encoding response.\n        response = request.response\n        response.code = 200\n        response.message = 'OK'\n        response.chunked_response = True\n        response.content_type = 'text/plain'\n\n        # Obtain the model.\n        model = get_model()\n\n        # We want to enable TCP_NODELAY for the duration of\n        # the response.  This ensures packets are sent\n        # immediately without any internal buffering.\n        try:\n            response.enable_tcp_nodelay()\n            enabled_nodelay = True\n        except Exception as e:\n            logging.error(f'Error enabling TCP_NODELAY: {e}')\n            enabled_nodelay = False\n\n        # Write the chunked header immediately.\n        response_bytes = bytes(response)\n        if not self.write(response_bytes):\n            # Encountered a disconnect, return.\n            return\n\n        # N.B. From herein, all data must be transferred to\n        #      the client via chunked encoding with the\n        #      `response.send_chunk()` routine.\n\n        # Send the initial prompt text.\n        response.send_chunk(prompt)\n\n        # Obtain decoded tokens from the model one at a time\n        # via an `async for` loop, sending the token back to\n        # the client as soon as it's available.\n        async for decoded_token in model.generate_async_for(prompt):\n            response.send_chunk(decoded_token)\n\n        # Terminate the chunked-encoding response.\n        response.end_chunks()\n\n        # Disable TCP_NODELAY now that the response is complete.\n        # The reasoning behind this is that the client may have\n        # issued the HTTP request with a keep-alive header, and\n        # plans on reusing this connection for a different request\n        # next, which won't necessarily want `TCP_NODELAY` active.\n        if enabled_nodelay:\n            response.disable_tcp_nodelay()\n\n\n\n\n\n\nFull Code for async Gpt2App.generate_response()\n\n\n\n\n\nThe actual code has more robust error-handling facilities and support for extracting the query string parameters from the incoming request URI and converting them into keyword arguments suitable for passing to the model.\nAdditionally, we haven’t touched on how we initialize or obtain instances of our models yet, so the model-related code won’t make much sense until later in the article.\n\nclass Gpt2App(HttpApp):\n    routes = make_routes()\n    route = router(routes)\n\n    def __init__(self, server: HttpServer) -&gt; None:\n        super().__init__(server)\n        self.printable = PRINTABLE\n\n    def is_connected(self):\n        # server.transport will be severed when the client\n        # disconnects, so we can use this to determine if\n        # the client is still connected.\n        server = self.server\n        transport = None\n        try:\n            transport = server.transport\n        except AttributeError:\n            pass\n        return transport is not None\n\n    def write(self, response_bytes):\n        server = self.server\n        transport = None\n        try:\n            transport = server.transport\n        except AttributeError:\n            pass\n        if transport is not None:\n            transport.write(response_bytes)\n            return True\n        else:\n            return False\n\n    async def generate_response(\n        self, request: Request, prompt: str, **kwds: Dict\n    ) -&gt; None:\n\n        response = request.response\n\n        response.code = 200\n        response.message = 'OK'\n        response.chunked_response = True\n        response.content_type = 'text/plain'\n\n        if kwds is None:\n            kwds = {}\n        max_length = min(int(kwds.get('max_length', 100) or 100), 1024)\n        top_k = min(int(kwds.get('top_k', 50) or 50), 50)\n        seed = kwds.get('seed', None)\n        if seed:\n            try:\n                seed = int(seed)\n            except ValueError:\n                seed = None\n        if not seed:\n            seed = random.randint(0, 2**32 - 1)\n\n        device = kwds.get('device', None)\n\n        model_name = kwds.get('model', None)\n        if model_name == 'gpt2-xl':\n            models = PRETRAINED_MODELS\n            get_next = get_next_pretrained_model\n        else:\n            model_name = 'gpt2'\n            models = MODELS\n            get_next = get_next_model\n\n        model = None\n        if device is not None:\n            if device == 'cpu':\n                model = models[-1]\n            elif device.startswith('cuda:'):\n                try:\n                    index = int(device[5:])\n                except ValueError:\n                    index = -1\n                if index &lt; 0 or index &gt;= NUM_GPUS:\n                    index = -1\n                if index != -1:\n                    model = models[index]\n            elif device == 'cuda':\n                model = models[random.randint(0, NUM_GPUS - 1)]\n\n        if not model:\n            # Get a model.  If there are multiple models available, e.g. if we\n            # have multiple GPUs, this will balance the load a bit.\n            model = get_next()\n\n        expose_headers = (\n            'Access-Control-Expose-Headers: '\n            'X-Max-Length, '\n            'X-Top-K, '\n            'X-Seed, '\n            'X-Model-Name, '\n            'X-Model-Device'\n        )\n        response.other_headers.extend([\n            expose_headers,\n            f'X-Max-Length: {max_length}',\n            f'X-Top-K: {top_k}',\n            f'X-Seed: {seed}',\n            f'X-Model-Name: {model_name}',\n            f'X-Model-Device: {model.device}',\n        ])\n\n        # We want to enable TCP_NODELAY for the duration of\n        # the response.  This ensures packets are sent\n        # immediately without any internal buffering.\n        try:\n            response.enable_tcp_nodelay()\n            enabled_nodelay = True\n        except Exception as e:\n            logging.error(f'Error enabling TCP_NODELAY: {e}')\n            enabled_nodelay = False\n\n        # Write the chunked header immediately.\n        response_bytes = bytes(response)\n        if not self.write(response_bytes):\n            # Encountered a disconnect, return.\n            return\n\n        # N.B. From herein, all data must be transferred to\n        #      the client via chunked encoding with the\n        #      `response.send_chunk()` routine.\n\n        # Send the initial prompt text.\n        response.send_chunk(prompt)\n\n        # Obtain an async generator instance to the model's\n        # new async token generation routine.\n        generate_tokens = model.generate_async_for(\n            prompt,\n            max_length=max_length,\n            top_k=top_k,\n            seed=seed,\n        )\n        async for decoded_token in generate_tokens:\n            if decoded_token == -1:\n                # A non-printable token was generated,\n                # terminating generation.\n                response.send_chunk(\n                    OOPS_NON_PRINTABLE_ENCOUNTERED\n                )\n                break\n\n            # If the client has forcibly disconnected,\n            # terminate generation.\n            if not self.is_connected():\n                break\n\n            # Otherwise, send the decoded token to the client\n            # via chunked encoding.\n            response.send_chunk(decoded_token)\n\n        # Send the termination chunk.  This may fail at the\n        # socket.send() level if the client has already\n        # disconnected, which is harmless.\n        response.end_chunks()\n\n        # Disable TCP_NODELAY now that the response is complete.\n        # Again, this may fail at the socket level if the client\n        # has already disconnected, which is harmless.\n        if enabled_nodelay:\n            try:\n                response.disable_tcp_nodelay()\n            except Exception as e:\n                msg = f'Error disabling TCP_NODELAY: {e}'\n                logging.error(msg)\n\n\n\n\n\nStep 3: Implement an async GPT.async_generate_for()\nIn the code example above, we assumed the GPT model we’ve been using had grown a new async routine named async_generate_for(), which we’ll cover now.\nThis routine is essentially an asyncio-friendly version of the original generate() routine we wrote. It shares a lot of the same code, with a few notable tweaks in order to support the fact that it is being called from a callback that was enqueued on a thread’s asyncio event loop, and it is expected to yield a token as soon as it is available, and then pass control back to the event loop in order for it to service other clients before it continues with generating the next token.\nIt also has the notion of checking for “printable” characters. This came about when I was initially testing this code via curl which would sometimes balk and exit in the middle of streaming the response, citing that it encountered corrupted data or something like that.\nAfter investigation, it turned out that sometimes, for whatever reason, the model just generates a junk, nonsensical token (like 65534, which is well outside the highest token number of 50384). I have no idea why it happens, although I’ll note it happens on the OpenAI GPT2 XL model available on HuggingFace (which we’ll discuss later) too, so, eh.\nI deal with this by checking if we’ve generated a non-printable token after decoding it, and, if so, return -1 and terminate the loop. The full version of the Gpt2App.generate_response() routine that we introduced above checks if we return -1, and if so, terminates generation with an oopsie message, e.g.:\nOOPS_NON_PRINTABLE_ENCOUNTERED = (\n    'Oops! Non-printable token encountered.  Generation terminated.'\n)\n...\n\nasync for decoded_token in generate_tokens:\n    if decoded_token == -1:\n        # A non-printable token was generated,\n        # terminating generation.\n        response.send_chunk(\n            OOPS_NON_PRINTABLE_ENCOUNTERED\n        )\n        break\nAfter yielding a valid decoded token, we issue an await asyncio.sleep(0) call, which returns control back to the event loop for it to potentially handle other concurrent clients. If there are no other clients, or after it has handled all other enqueued work, generation resumes.\nThe full code follows, it is simple enough as-is that I didn’t feel the need to omit any details like in the prior example.\n\nclass GPT:\n\n    ...\n\n    async def generate_async_for(\n        self, text: str, max_length: int = 1024, top_k: int = 50,\n        seed: int = None,\n    ):\n        \"\"\"\n        Asynchronously generate text from the model, yielding tokens\n        one at a time as soon as they are available.\n\n        Args:\n\n            text (str): Supplies the prompt.\n\n            max_length (int): Supplies the maximum total length,\n                including prompt.\n\n            top_k (int): Supplies the number of tokens to consider\n                at each generation step.\n\n            seed (int): Optionally supplies the manual seed to use\n                for the generator.  If None, the model's manual\n                seed will be used.\n\n        Yields:\n\n            byte: The newly generated decoded token.  If -1, a\n            non-printable token was generated, and generation\n            was terminated.\n        \"\"\"\n\n        enc = self.enc\n        stop_token = self.stop_token\n\n        # Encode the prompt -&gt; tensor of shape (1, T)\n        tokens = enc.encode(text)\n        x = torch.tensor(\n            tokens, dtype=torch.long, device=self.device\n        ).unsqueeze(0)\n\n        sample_rng = torch.Generator(device=self.device)\n        if seed is None:\n            seed = self.manual_seed\n        sample_rng.manual_seed(seed)\n\n        logging.debug(\n            f'[generate_async_for] Starting generation loop for {text} '\n            f'with seed {seed}.'\n        )\n\n        start_time = time.perf_counter()\n        count = 0\n        while x.size(1) &lt; max_length:\n            count += 1\n            with torch.no_grad():\n                # Forward pass, ignoring the returned loss.\n                (logits, _) = self(x)\n\n            # Take the logits at the last time-step (shape:\n            # (1, vocab_size)).\n            logits = logits[:, -1, :]\n\n            # Convert to probabilities.\n            probs = F.softmax(logits, dim=-1)\n\n            # Top-k sampling.\n            topk_probs, topk_indices = torch.topk(\n                probs, k=top_k, dim=-1,\n            )\n\n            # Sample the next token.\n            next_idx = torch.multinomial(\n                topk_probs,\n                num_samples=1,\n                generator=sample_rng,\n            )\n            next_token = torch.gather(topk_indices, -1, next_idx)\n\n            # If the next token is the stop token, we're done.\n            next_token_item = next_token.item()\n            if next_token_item == stop_token:\n                break\n\n            # Append token to current sequence.  Although we only\n            # yield a singular decoded token below, we still need\n            # to keep track of the entire sequence for subsequent\n            # generation steps.\n            x = torch.cat((x, next_token), dim=1)\n\n            # Decode the newly-generated token.  Note that a single\n            # token will often be decoded to multiple characters.\n            new_text_fragment = enc.decode([next_token.item()])\n\n            # If any of the characters in the decoded text\n            # representation aren't printable, terminate\n            # generation.\n            if not all(c in self.printable for c in new_text_fragment):\n                yield -1\n                break\n\n            yield new_text_fragment\n\n            # Yield control back to the event loop before continuing\n            # generation.  If we didn't do this, this client would\n            # hog the thread's event loop, preventing other clients\n            # associated with the loop from getting serviced.  (As\n            # we're now running multiple threads in parallel, other\n            # clients associated with event loops on other threads\n            # would not be impacted.)\n            await asyncio.sleep(0)\n\n        elapsed = time.perf_counter() - start_time\n        logging.debug(\n            f\"[generate_async_for] Generated {count} tokens in \"\n            f\"{elapsed:.2f} seconds (~{count / elapsed:.2f} tok/s)\"\n        )\nThis routine was the last piece we needed to implement to satisfy our three goals captured earlier, so, we’re now ready to test it out!"
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#test-drive",
    "href": "articles/pytorch-and-python-free-threading/index.html#test-drive",
    "title": "PyTorch and Python Free-Threading",
    "section": "Test Drive!",
    "text": "Test Drive!\n\nLaunching the HTTP Server\nWe can launch an instance of our multi-threaded HTTP web server with our new Gpt2App HTTP application via the command line as follows:\n% python -Xgil=0 -m parallelopedia.http.server  \\\n    --threads 40 --ip 0.0.0.0 --port 4444       \\\n    --app-classes parallelopedia.gpt2.Gpt2App   \\\n                  parallelopedia.http.server.PlaintextApp\nThis will start up a multi-threaded HTTP server listening on all interfaces on port 4444, with 40 threads, and two HTTP applications: our Gpt2App, which will service requests to the /generate endpoint, and a PlaintextApp that just returns “Hello, World!” to any incoming request received for the /plaintext endpoint.\n\n\nVisualizing Chunked-Encoding\nLet’s visualize the generation response in a way that shows us the raw chunked-encoding, without doing any client-side reassembly. We can achieve that with echo and netcat (nc):\n% echo -en \\\n 'GET /generate/The%20quick%20brown%20fox?max_length=20&device=cuda&seed=42 ' \\\n 'HTTP/1.1\\r\\nConnection: close\\r\\nHost: dgx\\r\\n\\r\\n' | nc dgx 4444\nThat should yield the following raw output:\nHTTP/1.1 200 OK\nServer: Parallelopedia Web Server v1.0\nDate: Fri, 07 Feb 2025 23:32:02 GMT\nAccept-Ranges: bytes\nContent-Type: text/plain\nAccess-Control-Allow-Origin: *\nConnection: close\nTransfer-Encoding: chunked\nAccess-Control-Expose-Headers: X-Max-Length, X-Top-K, X-Seed, X-Model-Name, X-Model-Device\nX-Max-Length: 20\nX-Top-K: 50\nX-Seed: 42\nX-Model-Name: gpt2\nX-Model-Device: cuda:0\n\n13\nThe quick brown fox\n3\n is\n2\n a\n4\n sub\n7\nspecies\n5\n that\nB\n originated\n3\n in\n9\n southern\n9\n Scotland\n3\n as\n2\n a\n8\n variety\n3\n of\n4\n fox\n1\n.\n5\n This\n0\n\nAs you can see, we’ve enabled chunked-encoding by way of the Transfer-Encoding: chunked header. And the body of the response is comprised of these “chunks”; specifically, each bit of decoded text is preceded by its length, in bytes, then followed by \\r\\n, then followed by the text itself.\nThe zero-length chunk at the end indicates completion of the transfer, and as we requested Connection: close in our headers, our HTTP server closes the connection once the generation has completed.\n\n\n\n\n\n\nNote\n\n\n\nIn HTTP/1.1, “keep-alive” is the default behavior—i.e., a server won’t close a connection unless the client specifically requests it. This is the opposite of HTTP/1.0 behavior, where the server will close a connection by default unless a client furnishes a Connection: keep-alive header.\n\n\n\n\nVerifying via Curl\nIf we switch over to curl and run the same generation request, we’ll see the reassembled text, and, provided we supply the --no-buffer argument, curl will also display decoded text as soon as it receives it.\n% curl --no-buffer --verbose \\\n    'http://dgx:4444/generate/The%20quick%20brown%20fox?' \\\n        'max_length=20&seed=42&device=cuda'\n*   Trying 10.0.132.48:4444...\n* Connected to dgx (10.0.132.48) port 4444 (#0)\n&gt; GET /generate/The%20quick%20brown%20fox?max_length=20&seed=42&device=cuda HTTP/1.1\n&gt; Host: dgx:4444\n&gt; User-Agent: curl/7.81.0\n&gt; Accept: */*\n&gt; \n* Mark bundle as not supporting multiuse\n&lt; HTTP/1.1 200 OK\n&lt; Server: Parallelopedia Web Server v1.0\n&lt; Date: Fri, 07 Feb 2025 23:05:34 GMT\n&lt; Accept-Ranges: bytes\n&lt; Content-Type: text/plain\n&lt; Access-Control-Allow-Origin: *\n&lt; Transfer-Encoding: chunked\n&lt; Access-Control-Expose-Headers: X-Max-Length, X-Top-K, X-Seed, X-Model-Name, X-Model-Device\n&lt; X-Max-Length: 20\n&lt; X-Top-K: 50\n&lt; X-Seed: 42\n&lt; X-Model-Name: gpt2\n&lt; X-Model-Device: cuda:2\n&lt; \nThe quick brown fox is a subspecies that originated in southern Scotland as a variety of fox. This* Connection #0 to host dgx left intact\n\n\nLaunching the React Bootstrap UI\nThe React Bootstrap UI can be launched as follows:\n% cd $PARALLELOPEDIA_UI # i.e. root of gh:tpn/parallelopedia-ui\n% conda activate py313t # or whatever has recent nodejs/npm\n% npm start run\n\n\n\n\n\n\nNote\n\n\n\nFull disclaimer: I’m not a web developer. I don’t know JavaScript, React, or Bootstrap, or anything else in the modern web stack. So like any good developer in 2025 when confronted with a task they have absolutely no business doing… I palmed it off to AI—either ChatGPT, local LLMs via LM Studio, or, more recently, Aider.\nTL;DR: the web interface code probably sucks.\n\n\nRunning npm start run should open up a browser window pointing at http://localhost:3000. Ignore the Wiki tab—that’s for another article—and switch to the GPT2 tab. You should see something similar to the GIF below, which is a demo of me using the interface to generate some text:\n\n\n\n\n\n\nParallelopedia UI Demo\n\n\n\n\n\n\n\n\nParallelopedia UI Demo\n\n\nGPT2.jsx Code\n\n\n\nNot too shabby! Granted, it’s a tad jarring seeing characters per second instead of tokens per second. If we wanted to display a live tokens/sec rate, some possible options might be:\n\nAlter GPT.async_generate_for() to calculate how long it took to generate each token (whilst we’re in the main generation loop), convert that into a tokens/sec rate, and then change our API on both the server side and the JavaScript UI side such that each chunk that gets sent back is encoded with both the rate and the actual chunk. A drawback of this approach is that hitting the /generate endpoint with curl or netcat would look wacky, as you’d see token/sec floats in between each generated set of decoded characters.\nSend the raw integer tokens back as they’re generated, instead of first decoding them. That would allow client-side JavaScript to calculate tokens/sec, but it would make it impossible to easily inspect the output with our command line tools like curl or echo ... | nc. It would also require adding a JavaScript decoding library on the client side (although that’s not such a big deal, I think you can just do npm    install tiktoken these days).\nHave the JavaScript client re-encode the decoded characters received back into their GPT2-tokenizer token representation in order to determine actual underlying token count, and recalculate the rate based off that. This rate would differ from the tokens/sec rate observed on the server because it would also include network latency.\nDo something more advanced with a separate WebSocket or something, where the live tokens/sec generation rate can be displayed independently to the generated decoded tokens.\nJust YOLO it and have the JavaScript code divide the characters per second by, say, three, and pretend that’s roughly the tokens/sec rate (assuming that on average, one token represents three characters in any given response).\n\nI don’t want to do any of that! So characters per second it is, for now, however jarring it may be."
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#parallel-generation",
    "href": "articles/pytorch-and-python-free-threading/index.html#parallel-generation",
    "title": "PyTorch and Python Free-Threading",
    "section": "Parallel Generation",
    "text": "Parallel Generation\nAlright, we’ve exercised the /generate endpoint a few different ways via a single client connection, and it looks like it’s behaving the way we hoped it would, albeit with a whopping simultaneous client count of, precisely, one.\nLet’s look at introducing some simultaneous load by way of multiple machines all issuing /generate requests at the same time, first via the echo ... | nc approach, and then via curl.\nI’ll leverage tmux and the :setw synchronize-panes command, which sends my console keystrokes to all active panes within a given tmux session window.\n\nNetcat Example\nI captured a 15 frames-per-second GIF of this in action, which you can view below. It shows terminal sessions to six machines, arranged vertically, all executing the same echo ... | nc command depicted above.\n\n\n\n\n\n\nNote\n\n\n\nThis might seem like a bit of a silly test, especially when it’s working correctly, because the output is pretty benign, and we don’t really know that these requests were actually being served simultaneously by different threads on the server side.\nWhen I first tried it, though, it absolutely did not work correctly—one server would get correct output, another would get the HTTP headers in triplicate, whilst two other sessions just went straight into the chunked responses, with no preceding HTTP headers in sight. I had a bug in my HTTP routing code (that exists in the PyParallel code I wrote ten years ago upon which I based the new HTTP server on!) which was entirely to blame. With that code ripped out and @route reimplemented in a much simpler fashion, everything worked well.\n\n\n\n\n\n\n\n\nParallel Netcat Generation\n\n\n\n\n\n\n\n\nParallel Netcat Generation\n\n\n\n\n\nI extracted the last frame of the GIF, below, where you can see that at least there was some variance between which GPUs were selected:\n\n\n\nParallel Netcat Generation - Last Frame\n\n\n\n\nCurl Example\nI did the same thing with the panes arranged horizontally, using curl instead and a max_length=1000 and no seed, which helps in visualizing the parallel generation, as you can clearly see different clients are receiving completely different outputs.\n\n\n\n\n\n\nParallel Curl Generation\n\n\n\n\n\n\n\n\nParallel Curl Generation"
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#lets-load-test-this-sucker",
    "href": "articles/pytorch-and-python-free-threading/index.html#lets-load-test-this-sucker",
    "title": "PyTorch and Python Free-Threading",
    "section": "Let’s Load Test This Sucker!",
    "text": "Let’s Load Test This Sucker!\nSo far so good! Looks like we can absolutely do PyTorch model generation in parallel via multiple threads thanks to free-threaded Python.\nLet’s ramp it up a notch and see what happens if we attempt to load test the /generate endpoint from a different server. The leopard server you see in the next example is an Intel(R) Xeon(R) W-2275 CPU @ 3.30GHz (14 cores, 28 threads) and is connected to the dgx box via a 10G Ethernet link.\nUsing the fork of wrk I hacked together some ten years ago or so whilst load testing PyParallel, let’s kick off a run with 14 threads for 30 seconds. There will be one connection per thread, and HTTP/1.1 will be used, so the implicit keep-alive behavior means that as soon as one /generate request completes, another one is immediately dispatched.\nFor posterity, the console command being used is as follows:\n% time ./wrk -v --latency -c14 -t14 -d30s \\\n    'http://dgx:4444/generate/'\n    'The%20quick%20brown%20fox?max_length=20&device=cuda&seed=42'\nIn the GIF below you’ll see two terminal windows. The smaller foreground window on the left is leopard, the session doing the wrk load test. The background window that takes up the rest of the screen is logged in to dgx, our server, and it’s running a GPU-enabled build of btop, which is a beautiful console app for displaying resource usage. I particularly like btop in this example as it does a good job of conveying the CPU and GPU load that kicks in when the load test starts.\nThe 40 CPU cores can be seen in the top pane, and, as expected, about 14 of them whirr into life as soon as the load test begins, which tracks, as there are now 14 clients attempting to hammer our /generate end point.\nBelow that, you can see the four Tesla V100-DGXS-32GB GPUs also whirr into action, handling the generation between them with relative ease.\nOn the bottom right, I’ve filtered the process tree to just display our python HTTP server invocation. (I would love it if btop showed the individual threads and their load, as it would beautifully depict Python saturating cores in parallel now that there’s no GIL impeding execution, however, I don’t believe that’s currently possible with this version of btop.)\n\nParallel Load Testing (No GIL)\n\n\n\n\n\n\nParallel Generation Load Test: No GIL\n\n\n\n\n\n\n\n\nParallel Generation Load Test - No GIL\n\n\n\n\n\nI’ve extracted the last frame, below, to allow closer inspection at the end of the run, without the annoyance of the GIF looping.\n\n\n\nParallel Generation Load Test No GIL - Last Frame\n\n\nThe console output from wrk is captured in the callout below.\n\n\n\n\n\n\nConsole Output of wrk: No GIL\n\n\n\n\n\nwrk 4.0.0 [epoll] Copyright (C) 2012 Will Glozer\nRunning 30s test @ http://dgx:4444/generate/The%20quick%20brown%20fox?max_length=20&device=cuda&seed=42\n  14 threads and 14 connections\n  Thread Stats   Min      Avg       Stdev     Max     +/- Stdev\n    Latency   130.40ms  197.38ms   54.41ms 528.61ms   89.19%\n    Req/Sec     1.00      5.63      2.32    10.00     67.76%\n  Latency Distribution\n      0%  130.40ms\n      1%  139.79ms\n      2%  143.50ms\n      3%  145.78ms\n      4%  147.53ms\n      5%  149.78ms\n      6%  151.18ms\n      7%  152.43ms\n      8%  153.42ms\n      9%  155.29ms\n     10%  156.15ms\n     11%  157.29ms\n     12%  158.27ms\n     13%  158.90ms\n     14%  159.70ms\n     15%  160.73ms\n     16%  161.64ms\n     17%  162.32ms\n     18%  163.09ms\n     19%  163.60ms\n     20%  164.41ms\n     21%  165.17ms\n     22%  165.61ms\n     23%  166.08ms\n     24%  166.75ms\n     25%  167.36ms\n     26%  167.93ms\n     27%  168.51ms\n     28%  169.05ms\n     29%  169.49ms\n     30%  170.23ms\n     31%  170.92ms\n     32%  171.54ms\n     33%  172.10ms\n     34%  172.66ms\n     35%  173.29ms\n     36%  173.98ms\n     37%  174.39ms\n     38%  174.96ms\n     39%  175.47ms\n     40%  176.17ms\n     41%  176.80ms\n     42%  177.24ms\n     43%  177.75ms\n     44%  178.49ms\n     45%  178.92ms\n     46%  179.57ms\n     47%  180.15ms\n     48%  180.62ms\n     49%  181.31ms\n     50%  182.00ms\n     51%  182.60ms\n     52%  183.22ms\n     53%  184.14ms\n     54%  185.01ms\n     55%  185.53ms\n     56%  186.21ms\n     57%  187.30ms\n     58%  188.03ms\n     59%  188.66ms\n     60%  189.14ms\n     61%  190.47ms\n     62%  191.13ms\n     63%  191.69ms\n     64%  192.34ms\n     65%  193.06ms\n     66%  193.87ms\n     67%  194.51ms\n     68%  195.63ms\n     69%  196.68ms\n     70%  197.67ms\n     71%  198.34ms\n     72%  199.90ms\n     73%  201.43ms\n     74%  202.66ms\n     75%  203.56ms\n     76%  205.00ms\n     77%  206.48ms\n     78%  207.76ms\n     79%  209.30ms\n     80%  210.53ms\n     81%  212.11ms\n     82%  213.30ms\n     83%  215.90ms\n     84%  218.09ms\n     85%  220.16ms\n     86%  224.57ms\n     87%  227.99ms\n     88%  230.93ms\n     89%  234.77ms\n     90%  241.08ms\n     91%  252.68ms\n     92%  302.34ms\n     93%  321.04ms\n     94%  335.47ms\n     95%  339.80ms\n     96%  358.81ms\n     97%  369.67ms\n     98%  379.52ms\n     99%  397.66ms\n    100%  411.36ms\n  2128 requests in 30.06s, 1.17MB read\nRequests/sec:     70.80\nTransfer/sec:     39.75KB\n\n\n\n\nA visualization of the latencies is presented below. All code for visualization is from the Data Visualization Jupyter Notebook, which you can preview here, or access directly on Github.\n\n\n\n\nParallel Load Test Latency Distribution (No GIL)\n\n\n\n\n\n\n\nParallel Load Test Latency Distribution (No GIL)\n\n\n\n\n\nAblation Test: Re-enable the GIL\nLet’s see what happens if we re-enable the GIL. We should see poor resource utilization on the server side, as only one Python thread can run at a time, and the statistics reported on the client side should be equally dismal.\nExpand the callout below to view the GIF. I have used another terminal window to launch the server with the -Xgil=1 argument, which re-enables the GIL. I then switch back over to leopard and perform the wrk load test like before.\n\n\n\n\n\n\nParallel Generation Load Test: GIL Enabled\n\n\n\n\n\n\n\n\nParallel Generation Load Test - GIL Enabled\n\n\n\n\n\nAs with before, I’ve extracted the last frame, below, to allow closer inspection at the end of the run, without the annoyance of the GIF looping.\n\n\n\nParallel Generation Load Test - GIL Enabled - Last Frame\n\n\nAs we expected: re-enabling the GIL absolutely murders resource utilization.\nThe console output from wrk follows in the next callout.\n\n\n\n\n\n\nConsole Output of wrk: GIL Enabled\n\n\n\n\n\nwrk 4.0.0 [epoll] Copyright (C) 2012 Will Glozer\nRunning 30s test @ http://dgx:4444/generate/The%20quick%20brown%20fox?max_length=20&device=cuda&seed=42\n  14 threads and 14 connections\n  Thread Stats   Min      Avg       Stdev     Max     +/- Stdev\n    Latency     1.11s     1.46s    92.76ms   1.82s    84.47%\n    Req/Sec     0.00      0.00      0.00     0.00    100.00%\n  Latency Distribution\n      0%    1.11s\n      1%    1.16s\n      2%    1.22s\n      3%    1.24s\n      4%    1.29s\n      5%    1.36s\n      6%    1.37s\n      7%    1.37s\n      8%    1.37s\n      9%    1.38s\n     10%    1.38s\n     11%    1.39s\n     12%    1.39s\n     13%    1.39s\n     14%    1.40s\n     15%    1.40s\n     16%    1.40s\n     17%    1.41s\n     18%    1.41s\n     19%    1.41s\n     20%    1.41s\n     21%    1.41s\n     22%    1.41s\n     23%    1.42s\n     24%    1.42s\n     25%    1.42s\n     26%    1.42s\n     27%    1.42s\n     28%    1.42s\n     29%    1.42s\n     30%    1.42s\n     31%    1.43s\n     32%    1.43s\n     33%    1.43s\n     34%    1.43s\n     35%    1.43s\n     36%    1.43s\n     37%    1.43s\n     38%    1.44s\n     39%    1.44s\n     40%    1.44s\n     41%    1.44s\n     42%    1.44s\n     43%    1.45s\n     44%    1.45s\n     45%    1.45s\n     46%    1.45s\n     47%    1.45s\n     48%    1.45s\n     49%    1.45s\n     50%    1.46s\n     51%    1.46s\n     52%    1.46s\n     53%    1.46s\n     54%    1.46s\n     55%    1.47s\n     56%    1.47s\n     57%    1.47s\n     58%    1.47s\n     59%    1.47s\n     60%    1.47s\n     61%    1.48s\n     62%    1.48s\n     63%    1.48s\n     64%    1.48s\n     65%    1.48s\n     66%    1.49s\n     67%    1.49s\n     68%    1.49s\n     69%    1.49s\n     70%    1.49s\n     71%    1.49s\n     72%    1.49s\n     73%    1.50s\n     74%    1.50s\n     75%    1.50s\n     76%    1.50s\n     77%    1.50s\n     78%    1.51s\n     79%    1.51s\n     80%    1.51s\n     81%    1.51s\n     82%    1.51s\n     83%    1.51s\n     84%    1.52s\n     85%    1.52s\n     86%    1.52s\n     87%    1.53s\n     88%    1.53s\n     89%    1.53s\n     90%    1.54s\n     91%    1.55s\n     92%    1.56s\n     93%    1.56s\n     94%    1.59s\n     95%    1.59s\n     96%    1.60s\n     97%    1.70s\n     98%    1.75s\n     99%    1.77s\n    100%    1.82s\n  221 requests in 30.07s, 129.42KB read\n  Socket errors: connect 0, read 0, write 0, timeout 60\nRequests/sec:      7.35\nTransfer/sec:      4.30KB\n\n\n\n\nAnd a visualization of the latencies follows. Note that there were 60 socket timeouts in this case, whereas no timeouts were encountered in the prior run with the GIL disabled.\n\n\n\n\nParallel Load Test Latency Distribution (GIL Enabled)\n\n\n\n\n\n\n\nParallel Load Test Latency Distribution (GIL Enabled)\n\n\n\n\n\nParallel Load Testing: No GIL vs GIL\nViewing them side by side:\n\n\n\n\nParallel Load Test Latency Distribution (No GIL & GIL Enabled Combined)\n\n\n\n\n\n\n\nParallel Load Test Latency Distribution (No GIL & GIL Enabled Combined)\n\n\n\nRemember to keep in mind that the No GIL vs GIL requests/sec was 70.80 vs 7.35, nearly a ten-fold increase:\n\n\n\n\nParallel Load Test Requests/sec (No GIL vs GIL)\n\n\n\n\n\n\n\nParallel Load Test Requests/sec (No GIL vs GIL)\n\n\n\n\n\nParallel Load Testing: How does Plaintext Fare?\nAs we launched our HTTP server invocation earlier with the PlaintextApp class, which simply responds to the /plaintext endpoint with b'Hello World\\n', let’s throw some load at that too.\nThis doesn’t have anything to do with PyTorch; it’s an orthogonal load test that’s fun because it depicts the stark difference between GIL vs no GIL.\nThe console command was issued on leopard, like last time, as follows:\n% time ./wrk -v --latency -c14 -t14 -d30s 'http://dgx:4444/plaintext'\nConsole outputs for both tests follow.\n\n\n\n\n\n\nConsole Output of wrk Plaintext: No GIL\n\n\n\n\n\nwrk 4.0.0 [epoll] Copyright (C) 2012 Will Glozer\nRunning 30s test @ http://dgx:4444/plaintext\n  14 threads and 14 connections\n  Thread Stats   Min      Avg       Stdev     Max     +/- Stdev\n    Latency   127.00us   11.68ms   55.98ms 818.74ms   94.91%\n    Req/Sec    20.00      4.89k     1.46k    6.43k    87.86%\n  Latency Distribution\n      0%  127.00us\n      1%  148.00us\n      2%  150.00us\n      3%  152.00us\n      4%  153.00us\n      5%  154.00us\n      6%  155.00us\n      7%  156.00us\n      8%  157.00us\n      9%  157.00us\n     10%  158.00us\n     11%  159.00us\n     12%  159.00us\n     13%  160.00us\n     14%  161.00us\n     15%  161.00us\n     16%  162.00us\n     17%  162.00us\n     18%  163.00us\n     19%  163.00us\n     20%  164.00us\n     21%  165.00us\n     22%  165.00us\n     23%  166.00us\n     24%  166.00us\n     25%  167.00us\n     26%  167.00us\n     27%  168.00us\n     28%  168.00us\n     29%  169.00us\n     30%  169.00us\n     31%  170.00us\n     32%  170.00us\n     33%  171.00us\n     34%  171.00us\n     35%  172.00us\n     36%  172.00us\n     37%  173.00us\n     38%  173.00us\n     39%  174.00us\n     40%  174.00us\n     41%  175.00us\n     42%  175.00us\n     43%  176.00us\n     44%  176.00us\n     45%  177.00us\n     46%  178.00us\n     47%  178.00us\n     48%  179.00us\n     49%  179.00us\n     50%  180.00us\n     51%  181.00us\n     52%  181.00us\n     53%  182.00us\n     54%  183.00us\n     55%  183.00us\n     56%  184.00us\n     57%  185.00us\n     58%  186.00us\n     59%  186.00us\n     60%  187.00us\n     61%  188.00us\n     62%  189.00us\n     63%  190.00us\n     64%  191.00us\n     65%  192.00us\n     66%  193.00us\n     67%  194.00us\n     68%  195.00us\n     69%  196.00us\n     70%  197.00us\n     71%  198.00us\n     72%  199.00us\n     73%  200.00us\n     74%  202.00us\n     75%  203.00us\n     76%  205.00us\n     77%  207.00us\n     78%  208.00us\n     79%  211.00us\n     80%  213.00us\n     81%  216.00us\n     82%  219.00us\n     83%  223.00us\n     84%  229.00us\n     85%  236.00us\n     86%  246.00us\n     87%  263.00us\n     88%  308.00us\n     89%  599.00us\n     90%    8.77ms\n     91%   19.48ms\n     92%   30.74ms\n     93%   42.55ms\n     94%   54.97ms\n     95%   68.92ms\n     96%   85.23ms\n     97%  106.42ms\n     98%  139.96ms\n     99%  282.83ms\n    100%  462.36ms\n  1970103 requests in 30.01s, 420.86MB read\nRequests/sec:  65652.68\nTransfer/sec:     14.02MB\n\n\n\n\n\n\n\n\n\n\nConsole Output of wrk Plaintext: GIL Enabled\n\n\n\n\n\nwrk 4.0.0 [epoll] Copyright (C) 2012 Will Glozer\nRunning 30s test @ http://dgx:4444/plaintext\n  14 threads and 14 connections\n  Thread Stats   Min      Avg       Stdev     Max     +/- Stdev\n    Latency   187.00us    4.81ms   19.24ms 295.28ms   97.89%\n    Req/Sec     4.00    442.80    133.07   666.00     66.01%\n  Latency Distribution\n      0%  187.00us\n      1%  577.00us\n      2%  645.00us\n      3%  670.00us\n      4%  684.00us\n      5%  698.00us\n      6%  712.00us\n      7%  724.00us\n      8%  735.00us\n      9%  745.00us\n     10%  755.00us\n     11%  763.00us\n     12%  770.00us\n     13%  778.00us\n     14%  789.00us\n     15%  801.00us\n     16%  814.00us\n     17%  831.00us\n     18%    0.85ms\n     19%    0.88ms\n     20%    0.95ms\n     21%    1.19ms\n     22%    1.25ms\n     23%    1.27ms\n     24%    1.29ms\n     25%    1.31ms\n     26%    1.33ms\n     27%    1.34ms\n     28%    1.36ms\n     29%    1.37ms\n     30%    1.38ms\n     31%    1.40ms\n     32%    1.42ms\n     33%    1.43ms\n     34%    1.46ms\n     35%    1.48ms\n     36%    1.52ms\n     37%    1.63ms\n     38%    1.80ms\n     39%    1.84ms\n     40%    1.87ms\n     41%    1.89ms\n     42%    1.90ms\n     43%    1.92ms\n     44%    1.93ms\n     45%    1.95ms\n     46%    1.96ms\n     47%    1.97ms\n     48%    1.99ms\n     49%    2.01ms\n     50%    2.02ms\n     51%    2.05ms\n     52%    2.07ms\n     53%    2.11ms\n     54%    2.17ms\n     55%    2.31ms\n     56%    2.39ms\n     57%    2.44ms\n     58%    2.48ms\n     59%    2.50ms\n     60%    2.53ms\n     61%    2.55ms\n     62%    2.57ms\n     63%    2.59ms\n     64%    2.61ms\n     65%    2.64ms\n     66%    2.66ms\n     67%    2.69ms\n     68%    2.73ms\n     69%    2.77ms\n     70%    2.84ms\n     71%    2.96ms\n     72%    3.04ms\n     73%    3.09ms\n     74%    3.12ms\n     75%    3.15ms\n     76%    3.18ms\n     77%    3.22ms\n     78%    3.26ms\n     79%    3.31ms\n     80%    3.38ms\n     81%    3.51ms\n     82%    3.65ms\n     83%    3.74ms\n     84%    3.82ms\n     85%    3.90ms\n     86%    4.01ms\n     87%    4.21ms\n     88%    4.33ms\n     89%    4.41ms\n     90%    4.48ms\n     91%    4.58ms\n     92%    4.82ms\n     93%    5.03ms\n     94%    5.30ms\n     95%    5.72ms\n     96%    6.34ms\n     97%    7.54ms\n     98%   31.73ms\n     99%  116.44ms\n    100%  169.73ms\n  183217 requests in 30.02s, 39.14MB read\nRequests/sec:   6102.29\nTransfer/sec:      1.30MB\n\n\n\n\nCombined requests/sec visualization depicts a similar 10x improvement:\n\n\n\n\nPlaintext Parallel Load Test Requests/sec (No GIL vs GIL)\n\n\n\n\n\n\n\nPlaintext Parallel Load Test Requests/sec (No GIL vs GIL)\n\n\n\nThe latencies are a bit misleading when viewed in isolation, as you can see the tail end of the No GIL run incur higher latencies compared to the GIL run—however, as can be seen above, the No GIL run was doing 10x more requests/sec.\n\n\n\n\nPlaintext Parallel Load Test Latency Distribution (No GIL vs GIL)\n\n\n\n\n\n\n\nPlaintext Parallel Load Test Latency Distribution (No GIL vs GIL)\n\n\n\n\n\nParallel Load Test Summary\nI think it’s safe to say we’ve achieved our original goals in a satisfactory manner. We can absolutely now do parallel model inference in a single Python process, thanks to free-threading, and the whole thing works great when wrapped around an asyncio-based HTTP server that yields tokens one-by-one as soon as they’re generated, which is a closer representation of what you’d want in the real world if you were to deploy such a thing.\nMy takeaway from all of this: free-threading kicks ass. Having devoted so much time toward a parallel Python solution with PyParallel over a decade ago, it makes me incredibly happy to see a working, performant solution finally getting mainlined into the core Python language.\nIt’s important to consider how many other things are simultaneously unlocked by Python free-threading. The HTTP server we’ve demonstrated above also has directory/file-serving behavior built-in, so it also functions like a normal web server would. In a separate article, I’ll introduce the Wiki server component, which features a WikiApp HTTP app that loads a 56GB XML file, plus about 12GB of supporting index structures (by way of datrie digital search tries, and NumPy arrays). This app happily loads in the same single Python process as our existing Gpt2App—demonstrating the power of accessing huge data structures in parallel by multiple threads, something that couldn’t be done with multiprocessing without paying for the cost to replicate that memory overhead in every process."
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#reviewing-initial-implementation",
    "href": "articles/pytorch-and-python-free-threading/index.html#reviewing-initial-implementation",
    "title": "PyTorch and Python Free-Threading",
    "section": "Reviewing Initial Implementation",
    "text": "Reviewing Initial Implementation\n\nSkipping Weight Initialization\nThe first version of the GPT class we introduced here looked like this:\nclass GPT(nn.Module):\n\n    def __init__(self, config, device):\n        super().__init__()\n        self.config = config\n        self.device = device\n        self.manual_seed = 42\n\n        self.transformer = nn.ModuleDict(\n            dict(\n                wte=nn.Embedding(config.vocab_size, config.n_embd),\n                wpe=nn.Embedding(config.block_size, config.n_embd),\n                h=nn.ModuleList(\n                    [Block(config) for _ in range(config.n_layer)]\n                ),\n                ln_f=nn.LayerNorm(config.n_embd),\n            )\n        )\n        self.lm_head = nn.Linear(\n            config.n_embd, config.vocab_size, bias=False\n        )\n\n        self.transformer.wte.weight = self.lm_head.weight\n        self.apply(self._init_weights)\n\n    def _init_weights(self, module):\n        if isinstance(module, nn.Linear):\n            std = 0.02\n            if hasattr(module, \"NANOGPT_SCALE_INIT\"):\n                std *= (2 * self.config.n_layer) ** -0.5\n            torch.nn.init.normal_(module.weight, mean=0.0, std=std)\n            if module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\nAs I mentioned earlier, I ripped that almost verbatim from Andrej’s train_gpt2.py code. For about two weeks during development of this work, I was using a local free-threaded build of PyTorch, but had forgotten that I had built it in debug configuration.\nEverything was dog slow, but I had no frame of reference for how long things should have been taking, having had no real prior experience with PyTorch, but I was getting annoyed enough at how long it seemed to take to load the model—which I was doing frequently during development—so I added a bunch of timing code around things to try and bisect where the overhead was being introduced.\nLooking at the __init__() code above, though, I was thoroughly perplexed by the _init_weights(self, module) function. Why would we be initializing weights at the end of the GPT constructor if we were just about to override them with the weights we were loading from the checkpoint?\nEliminating the call to _init_weights() entirely shaved off 15 seconds from the time it took to simply create an “empty” GPT() instance—i.e. before we’d even loaded the weights. However, it was still taking 15 seconds just to execute this block of code:\n\n    self.transformer = nn.ModuleDict(\n        dict(\n            wte=nn.Embedding(config.vocab_size, config.n_embd),\n            wpe=nn.Embedding(config.block_size, config.n_embd),\n            h=nn.ModuleList(\n                [Block(config) for _ in range(config.n_layer)]\n            ),\n            ln_f=nn.LayerNorm(config.n_embd),\n        )\n    )\n    self.lm_head = nn.Linear(\n        config.n_embd, config.vocab_size, bias=False\n    )\nI hoisted that code out into a separate _init_transformer() routine and surrounded it with some optional torch.profiler.profile() glue:\n\n    timer = ElapsedTimer()\n\n    with timer:\n        if not self.torch_profile_activities:\n            self._init_transformer()\n        else:\n            with torch.profiler.profile(\n                activities=self.torch_profile_activities,\n                with_stack=True,\n            ) as prof:\n                self._init_transformer()\n            self.torch_profile_init_transformer = prof\n\n    msg = f'Initialized GPT model in {timer.elapsed:.3f} seconds.'\n    logging.info(msg)\nThe profiling data yielded some interesting insight:\n&gt; print(model.torch_profile_init_transformer.key_averages().table(sort_by='cpu_time_total'))\n-------------------------  ------------  ------------  ------------  ------------  ------------  ------------\n                     Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls\n-------------------------  ------------  ------------  ------------  ------------  ------------  ------------\n           aten::uniform_        74.31%       10.861s        74.31%       10.861s     111.966ms            97\n            aten::normal_        25.64%        3.747s        25.64%        3.747s        1.873s             2\n             aten::detach         0.01%       1.408ms         0.03%       3.712ms      24.914us           149\n              aten::empty         0.02%       2.570ms         0.02%       2.570ms      17.247us           149\n                   detach         0.02%       2.304ms         0.02%       2.304ms      15.464us           149\n              aten::fill_         0.01%       1.013ms         0.01%       1.013ms      40.500us            25\n              aten::zero_         0.00%     305.888us         0.00%     305.888us      12.236us            25\n    cudaDeviceSynchronize         0.00%      16.073us         0.00%      16.073us      16.073us             1\n-------------------------  ------------  ------------  ------------  ------------  ------------  ------------\nSelf CPU time total: 14.615s\nSo aten::uniform_ and aten::normal_ were taking up, literally, 99.95% of the time during the transformer initialization. That also seemed bananas for the exact same reason calling _init_weights() seemed bananas: why was so much time and effort being spent initializing distributions when we were going to immediately overwrite all the weights when we load the model from the checkpoint?\nNow, granted, had I not been using a debug build of PyTorch, those 14.597 seconds spent on weight initialization would be more like unnoticeable milliseconds at best. But I didn’t know that at the time, so after a bit of digging, I found out I could subclass my Embedding and Linear layers (which were the ones contributing to the uniform and normal distribution setup time overhead) in such a way that weight initialization would be skipped entirely.\nSo, if you look at the gpt2.py implementation on Github, you’ll see that I’m using a bunch of NoInit classes, as follows:\n# ==============================================================\n# Classes\n# ==============================================================\n\n# N.B. We have simple \"no-init\" overrides for nn.Embedding and\n#      nn.Linear which skip the default initialization routines,\n#      significantly reducing the time to load the model by\n#      avoiding uniform and random distribution initialization.\n#      As we immediately load all the weights from the model\n#      checkpoint straight after creating the model, we don't\n#      need the default initialization routines.\n\nclass NoInitEmbedding(nn.Embedding):\n    def reset_parameters(self):\n        # Skip default uniform initialization.\n        pass\n\n\nclass NoInitLinear(nn.Linear):\n    def reset_parameters(self):\n        # Skip default Kaiming initialization.\n        pass\n\n\nclass CausalSelfAttention(nn.Module):\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # Key, query, value projections for all heads, but in a batch.\n        self.c_attn = NoInitLinear(config.n_embd, 3 * config.n_embd)\n\n        # Output projection.\n        self.c_proj = NoInitLinear(config.n_embd, config.n_embd)\n        self.c_proj.NANOGPT_SCALE_INIT = 1\n\n        # Regularization.\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    ...\n\nclass MLP(nn.Module):\n\n    def __init__(self, config):\n        super().__init__()\n        self.c_fc = NoInitLinear(config.n_embd, 4 * config.n_embd)\n        self.gelu = nn.GELU(approximate='tanh')\n        self.c_proj = NoInitLinear(4 * config.n_embd, config.n_embd)\n        self.c_proj.NANOGPT_SCALE_INIT = 1\n\n    ...\n\nclass GPT:\n\n    ...\n\n    def _init_transformer(self):\n        \"\"\"\n        Initialize the transformer.\n        \"\"\"\n        config = self.config\n        self.transformer = nn.ModuleDict(\n            dict(\n                wte=NoInitEmbedding(config.vocab_size, config.n_embd),\n                wpe=NoInitEmbedding(config.block_size, config.n_embd),\n                h=nn.ModuleList(\n                    [Block(config) for _ in range(config.n_layer)]\n                ),\n                ln_f=nn.LayerNorm(config.n_embd),\n            )\n        )\n        self.lm_head = NoInitLinear(\n            config.n_embd,\n            config.vocab_size,\n            bias=False,\n        )\n        self.transformer.wte.weight = self.lm_head.weight\nA few weeks after I’d put this code in, I came across this HuggingFace article on Big Model Inference where they discuss the very problem I was hitting, which is problematic on much larger models even when you’re using a release build of PyTorch—not just pip-squeak GPT2 models with a debug build—and they have a decorator-oriented solution:\nfrom accelerate import init_empty_weights\nwith init_empty_weights():\n    my_model = ModelClass(...)\nGranted, I couldn’t use accelerate because it depends on packages that are not available for free-threaded builds yet, but I wanted to include the information here for future reference.\n\n\nCan We Load Other Checkpoints?\nGPT2 was the last model where OpenAI made the weights publicly available. So, in theory, I should be able to download their largest GPT2 model—GPT2 XL—figure out how to extract the weights, and then load them into our janky little GPT class instead of the ones from the locally-trained checkpoint.\nTurns out downloading it is easy via huggingface-cli (again, not something that works with free-threading, so you’ll need to activate the py313 environment and pip install -U \"huggingface_hub[cli]\" per these instructions):\n% huggingface-cli download openai-community/gpt2-xl\n# That should download the model into the following directory.\n% cd ~/.cache/huggingface/hub/models--openai-community--gpt2-xl\n% tree -h .\ntree -h\n[4.0K]  .\n├── [4.0K]  blobs\n│   ├── [ 124]  057e43033439e068b325f32af95dde9efc9552ae\n│   ├── [6.0G]  0f8b28eb05a8075f48b61b6f35332978c74fc7763fa9fb4051a1c30511736a6a\n│   ├── [1018K]  1f1d9aaca301414e7f6c9396df506798ff4eb9a6\n│   ├── [446K]  226b0752cac7789c48f0cb3ec53eda48b7be36cc\n│   ├── [ 12K]  34f1cc31333e001c3047539dd604123dafd37346\n│   ├── [5.8G]  47d4a280f9274f015e8dd1e7e2e1066415fc1f37030ec30d00615973e750e578\n│   ├── [1.3M]  4b988bccc9dc5adacd403c00b4704976196548f8\n│   ├── [ 445]  602b71f15d40ed68c5f96330e3f3175a76a32126\n│   ├── [6.3G]  7b92a55d852494754e2856681833ee0ff05580ee32c1d8d60a1177bbf1f4703a\n│   ├── [ 689]  932bdee9f4b3878f7f285187564b46f256243aff\n│   ├── [  26]  be4d21d94f3b4687e5a54d84bf6ab46ed0f8defd\n│   ├── [ 165]  c791c4d01fc484a57262ee57c878dd5b35863fe7\n│   ├── [6.0G]  cd2a29e31040ef64d9362cb96801969c9f67b9e0bdbd6e00b9dda57cdbe17435\n│   └── [5.8G]  fbc167e52fa30c56fbed46e8b45c25893c4afb165ef666864abc0e70d5c117a4\n├── [4.0K]  refs\n│   └── [  40]  main\n└── [4.0K]  snapshots\n    └── [4.0K]  15ea56dee5df4983c59b2538573817e1667135e2\n        ├── [  52]  config.json -&gt; ../../blobs/932bdee9f4b3878f7f285187564b46f256243aff\n        ├── [  76]  flax_model.msgpack -&gt; ../../blobs/fbc167e52fa30c56fbed46e8b45c25893c4afb165ef666864abc0e70d5c117a4\n        ├── [  52]  generation_config_for_text_generation.json -&gt; ../../blobs/c791c4d01fc484a57262ee57c878dd5b35863fe7\n        ├── [  52]  generation_config.json -&gt; ../../blobs/057e43033439e068b325f32af95dde9efc9552ae\n        ├── [  52]  merges.txt -&gt; ../../blobs/226b0752cac7789c48f0cb3ec53eda48b7be36cc\n        ├── [  76]  model.safetensors -&gt; ../../blobs/0f8b28eb05a8075f48b61b6f35332978c74fc7763fa9fb4051a1c30511736a6a\n        ├── [  76]  pytorch_model.bin -&gt; ../../blobs/cd2a29e31040ef64d9362cb96801969c9f67b9e0bdbd6e00b9dda57cdbe17435\n        ├── [  52]  README.md -&gt; ../../blobs/34f1cc31333e001c3047539dd604123dafd37346\n        ├── [  76]  rust_model.ot -&gt; ../../blobs/7b92a55d852494754e2856681833ee0ff05580ee32c1d8d60a1177bbf1f4703a\n        ├── [  76]  tf_model.h5 -&gt; ../../blobs/47d4a280f9274f015e8dd1e7e2e1066415fc1f37030ec30d00615973e750e578\n        ├── [  52]  tokenizer_config.json -&gt; ../../blobs/be4d21d94f3b4687e5a54d84bf6ab46ed0f8defd\n        ├── [  52]  tokenizer.json -&gt; ../../blobs/4b988bccc9dc5adacd403c00b4704976196548f8\n        └── [  52]  vocab.json -&gt; ../../blobs/1f1d9aaca301414e7f6c9396df506798ff4eb9a6\nWell that’s pretty neat, if not a tad duplicative, given the 1.5B parameter model is shipped in five different ~6GB encodings:\n│   ├── [6.0G]  model.safetensors   (0f8b28...)\n│   ├── [5.8G]  tf_model.h5         (47d4a2...)\n│   ├── [6.3G]  rust_model.ot       (7b92a5...)\n│   ├── [6.0G]  pytorch_model.bin   (cd2a29...)\n│   └── [5.8G]  flax_model.msgpack  (fbc167...)\nThe pytorch_model.bin one is a pickled dict of tensors obtained from a torch.save() call—i.e. basically equivalent to the checkpoint we’d been using for the locally trained GPT2 model we used. For whatever reason, that one didn’t interest me much, but model.safetensors did.\nThankfully, I could pip install safetensors in the free-threaded py313t environment, so I wrote some helper glue to give me back a HuggingFaceModel with the tensors accessible via a safetensors attribute if I passed it the appropriate model name, e.g.:\n@dataclass\nclass HuggingFaceModel:\n    name: str\n    config: dict\n    safetensors: \"safetensors.safe_open\"\n    tokenizer: dict\n    tokenizer_config: dict\n    vocab: dict\n\ndef get_huggingface_model(model_name: str) -&gt; HuggingFaceModel:\n    \"\"\"\n    Returns a Hugging Face model object for the given model name.\n\n    Args:\n\n        model_name (str): Supplies the name of the Hugging Face model.  This\n            should be in the format of `namespace/model`, e.g. for GPT2 XL:\n            `openai-community/gpt2-xl`.  This will be expanded out to the\n            following directory:\n                `~/.cache/huggingface/hub/models--openai-community--gpt2-xl`\n\n    Returns:\n\n        HuggingFaceModel: Returns a HuggingFaceModel object containing the\n            model name, configuration, and SafeTensors object.\n    \"\"\"\n    base = os.path.expanduser('~/.cache/huggingface/hub/models--')\n    (namespace, model) = model_name.split('/')\n    base_path = f'{base}{namespace}--{model}'\n    ref_path = f'{base_path}/refs/main'\n    with open(ref_path, 'r') as f:\n        ref = f.read().strip()\n    snapshots_dir = f'{base_path}/snapshots/{ref}'\n    safetensors_path = f'{snapshots_dir}/model.safetensors'\n    import safetensors\n    timer = ElapsedTimer()\n    logging.debug(f'About to load safetensors from {safetensors_path}...')\n    with timer:\n        st = safetensors.safe_open(\n            safetensors_path,\n            framework=\"pt\",\n            device=\"cpu\",\n        )\n    msg = (\n        f'Loaded safetensors from {safetensors_path} '\n        f'in {timer.elapsed:.4f} seconds.'\n    )\n    logging.info(msg)\n\n    config_path = f'{snapshots_dir}/config.json'\n    with open(config_path, 'r') as f:\n        config = json.load(f)\n\n    tokenizer_path = f'{snapshots_dir}/tokenizer.json'\n    with open(tokenizer_path, 'r') as f:\n        tokenizer = json.load(f)\n\n    tokenizer_config_path = f'{snapshots_dir}/tokenizer_config.json'\n    with open(tokenizer_config_path, 'r') as f:\n        tokenizer_config = json.load(f)\n\n    vocab_path = f'{snapshots_dir}/vocab.json'\n    with open(vocab_path, 'r') as f:\n        vocab = json.load(f)\n\n    return HuggingFaceModel(\n        model_name,\n        config,\n        st,\n        tokenizer,\n        tokenizer_config,\n        vocab,\n    )\nNow, I remember Andrej had a GPT.from_pretrained() routine that was geared toward loading the GPT2 models via the transformers Python package along the following lines:\nfrom transformers import GPT2LMHeadModel\nhf_model = GPT2LMHeadModel.from_pretrained('gpt2-xl')\nThe technique he used to prime is local GPT class from the larger model loaded from HuggingFace piqued my interest. I’ve reproduced the applicable code below, with some formatting tweaks only.\n# create a from-scratch initialized minGPT model\nconfig = GPTConfig(**config_args)\nmodel = GPT(config)\nsd = model.state_dict()\nsd_keys = sd.keys()\n# discard this mask / buffer, not a param\nsd_keys = [\n    key for key in sd_keys if not key.endswith('.attn.bias')\n]\n\n# init a huggingface/transformers model\nmodel_hf = GPT2LMHeadModel.from_pretrained(model_type)\nsd_hf = model_hf.state_dict()\n\n# copy while ensuring all of the parameters are aligned\n# and match in names and shapes\nsd_keys_hf = sd_hf.keys()\n\n# ignore `.attn.masked_bias`; just a buffer\nsd_keys_hf = [\n    key for key in sd_keys_hf\n        if not k.endswith('.attn.masked_bias')\n]\n\n# ditto; ignore `.attn.bias`, just the mask (buffer)\nsd_keys_hf = [\n    key for key in sd_keys_hf\n        if not key.endswith('.attn.bias')\n]\n\ntransposed = [\n    'attn.c_attn.weight',\n    'attn.c_proj.weight',\n    'mlp.c_fc.weight',\n    'mlp.c_proj.weight',\n]\n\n# basically the openai checkpoints use a \"Conv1D\" module,\n# but we only want to use a vanilla Linear, this means\n# that we have to transpose these weights when we import them\nassert len(sd_keys_hf) == len(sd_keys), (\n    f\"mismatched keys: {len(sd_keys_hf)} != {len(sd_keys)}\"\n)\n\nfor k in sd_keys_hf:\n    if any(k.endswith(w) for w in transposed):\n        # special treatment for the Conv1D weights\n        # we need to transpose\n        assert sd_hf[k].shape[::-1] == sd[k].shape\n        with torch.no_grad():\n            sd[k].copy_(sd_hf[k].t())\n    else:\n        # vanilla copy over the other parameters\n        assert sd_hf[k].shape == sd[k].shape\n        with torch.no_grad():\n            sd[k].copy_(sd_hf[k])\nDo all of that fiddling and et voilà, you’ve just primed your GPT model with the OpenAI weights!\nThe reason Andrej’s approach piqued my interest—in combination with poking around at a safetensors instance and realizing I could easily extract all 147-or-so tensors by name—was that it may allow us to copy the tensors from the model read from disk into our model in parallel, using multiple threads.\nSo I hacked together a variant of Andrej’s GPT.from_pretrained() that looked as follows:\nclass GPT:\n\n    ...\n\n    @classmethod\n    def from_pretrained(cls,\n                        model_name: str,\n                        map_location: Optional[str] = None,\n                        manual_seed: Optional[int] = None,\n                        torch_profile_activities: Optional[List[type]] = None,\n                        ) -&gt; \"GPT\":\n        \"\"\"\n        Load a GPT model from a pretrained model.\n\n        Arguments:\n\n            model_name (str): Supplies the model name to use.  See the\n                docstring for `.util.get_huggingface_safetensors()` for\n                more information about the format.\n\n            map_location (str): Optionally supplies the device to map the\n                loaded tensor parameters to.  If None, \"cuda\" will be used\n                if available, otherwise \"cpu\".\n\n            manual_seed (int): Optionally supplies the manual seed to use for\n                the model.  If None, a random seed will be used.\n\n            torch_profile_activities (list): Optionally supplies a list of\n                torch.profiler.ProfilerActivity to profile.\n\n        \"\"\"\n        if manual_seed is None:\n            # Use a random seed.\n            manual_seed = random.randint(0, 2**32 - 1)\n\n        if map_location is None:\n            if torch.cuda.is_available():\n                map_location = \"cuda\"\n            else:\n                map_location = \"cpu\"\n\n        timer = ElapsedTimer()\n        with timer:\n            hf_model = get_huggingface_model(model_name)\n        msg = (\n            f'Loaded HuggingFace model {model_name} in '\n            f'{timer.elapsed:.3f} seconds.'\n        )\n        logging.info(msg)\n\n        config = GPTConfig(**{\n            'block_size': hf_model.config['n_ctx'],\n            'vocab_size': hf_model.config['vocab_size'],\n            'n_layer': hf_model.config['n_layer'],\n            'n_head': hf_model.config['n_head'],\n            'n_embd': hf_model.config['n_embd'],\n        })\n        checkpoint = GPTCheckpoint(**{\n            'model': None,\n            'step': 0,\n            'val_loss': 0.0,\n            'config': config,\n        })\n\n        with timer:\n            model = cls(\n                checkpoint=checkpoint,\n                device=map_location,\n                manual_seed=manual_seed,\n                torch_profile_activities=torch_profile_activities,\n            )\n        logging.info(f'Created GPT model in {timer.elapsed:.3f} seconds.')\n\n        # This logic is based heavily off build-nanogpt's `train_gpt2.py`;\n        # specifically: GPT.from_pretrained().\n\n        exclude = ('.attn.bias', '.attn.masked_bias', 'lm_head.weight')\n        transpose = (\n            'attn.c_attn.weight',\n            'attn.c_proj.weight',\n            'mlp.c_fc.weight',\n            'mlp.c_proj.weight',\n        )\n\n        # Identify the HuggingFace keys we're interested in.\n        st = hf_model.safetensors\n\n        # Identify our model keys we're interested in.\n        sd = model.state_dict()\n        sd_keys = [k for k in sd.keys() if not k.endswith(exclude)]\n        hf_keys = [k.replace('transformer.', '') for k in sd_keys]\n\n        # Copying tensors in parallel yields decent speedups,\n        # at least on my V100s which have five concurrent copy\n        # engines.\n1        def copy_tensor(hf_key, sd_key):\n            hf_tensor = st.get_tensor(hf_key)\n            if hf_key.endswith(transpose):\n                assert hf_tensor.shape[::-1] == sd[sd_key].shape\n                with torch.no_grad():\n                    sd[sd_key].copy_(hf_tensor.t())\n            else:\n                assert hf_tensor.shape == sd[sd_key].shape\n                with torch.no_grad():\n                    sd[sd_key].copy_(hf_tensor)\n\n        keys = zip(hf_keys, sd_keys)\n        max_workers = min(os.cpu_count(), len(sd_keys))\n        with timer:\n2            with ThreadPoolExecutor(\n                max_workers=max_workers\n            ) as executor:\n                futures = {\n                    executor.submit(copy_tensor, hf_key, sd_key):\n                        (hf_key, sd_key)\n                            for (hf_key, sd_key) in keys\n                }\n                for future in as_completed(futures):\n                    future.result()\n        logging.info(\n            f'Copied weights with {max_workers} thread(s) '\n            f'in {timer.elapsed:.3f} seconds.'\n        )\n\n        device = map_location\n        with timer:\n            model.to(device)\n        msg = f'Moved model to {device} in {timer.elapsed:.3f} seconds.'\n        logging.info(msg)\n\n        return model\n\n1\n\nDefine a copy_tensor function that is provided with the name of a tensor key as it appears in the HuggingFace model (hf_key) and as it appears in our state_dict model (sd_key). The sd state dict is accessible to all threads, so they can simply copy their tensor via sd[sd_key].copy_(hf_tensor).\n\n2\n\nUse a ThreadPoolExecutor() to dispatch the copy_tensor operations in parallel. In this case I’m using workers equivalent to the number of CPU cores, or number of tensors, whichever is fewer.\n\n\nSo that all worked pretty well, free-threading can absolutely be used to speed up things like loading tensors.\nAdditionally, if you play around with this locally, the gpt2-xl model will be available to select from the drop-down in the UI and also can be used via the command line (--model gpt2-xl) or in the REST /generate endpoint as a query parameter (/generate/foo...?model=gpt2-xl).\n\n\nMulti-GPU Support\nThe final big change I introduced was multi-GPU support plus some very rudimentary round-robin-esque behavior that could be used from the generate() routines to obtain a reference to a model depending on the incoming user’s request.\nThe generate() routine now obtains a model by the following:\nmodel = get_next_model()\nThe implementation for which is here, reproduced in part below:\nNUM_GPUS = torch.cuda.device_count()\n# Add a CPU version at the end.\nTOTAL_MODELS = NUM_GPUS + 1\nMODELS = [None] * TOTAL_MODELS\nMODELS_ROUND_ROBIN = itertools.cycle(range(TOTAL_MODELS))\n\ndef get_next_model_random():\n    # Randomly select a GPU to use.\n    return MODELS[random.randint(0, TOTAL_MODELS - 1)]\n\ndef get_next_model_round_robin():\n    with MODELS_LOCK:\n        index = next(MODELS_ROUND_ROBIN)\n    return MODELS[index]\n\nget_next_model = get_next_model_round_robin\n\ndef load_models():\n    global MODELS\n    max_workers = min(TOTAL_MODELS, os.cpu_count())\n    timer = ElapsedTimer()\n    with timer:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = {\n                executor.submit(\n                    GPT.from_local_pretrained,\n                    model_path=MODEL_CHECKPOINT,\n                    map_location=f'cuda:{i}',\n                    torch_profile_activities=TORCH_PROFILE_ACTIVITIES,\n                ): i for i in range(NUM_GPUS)\n            }\n            # Add the CPU model.\n            futures[executor.submit(\n                GPT.from_local_pretrained,\n                model_path=MODEL_CHECKPOINT,\n                map_location='cpu',\n                torch_profile_activities=TORCH_PROFILE_ACTIVITIES,\n            )] = NUM_GPUS\n            for future in as_completed(futures):\n                i = futures[future]\n                model = future.result()\n                MODELS[i] = model\n    msg = (\n        f'Loaded model on {NUM_GPUS} GPU(s) and 1 CPU in '\n        f'{timer.elapsed:.3f} seconds.'\n    )\n    logging.info(msg)\n\nPRETRAINED_MODELS = [None] * TOTAL_MODELS\nPRETRAINED_MODELS_ROUND_ROBIN = itertools.cycle(range(TOTAL_MODELS))\n\ndef get_next_pretrained_model_random():\n    # Randomly select a GPU to use.\n    return PRETRAINED_MODELS[random.randint(0, TOTAL_MODELS - 1)]\n\ndef get_next_pretrained_model_round_robin():\n    with PRETRAINED_MODELS_LOCK:\n        index = next(PRETRAINED_MODELS_ROUND_ROBIN)\n    return PRETRAINED_MODELS[index]\n\nget_next_pretrained_model = get_next_pretrained_model_round_robin\n\ndef load_pretrained_models():\n    global PRETRAINED_MODELS\n    max_workers = min(TOTAL_MODELS, os.cpu_count())\n    timer = ElapsedTimer()\n    with timer:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = {\n                executor.submit(\n                    GPT.from_pretrained,\n                    model_name='openai-community/gpt2-xl',\n                    map_location=f'cuda:{i}',\n                    torch_profile_activities=TORCH_PROFILE_ACTIVITIES,\n                ): i for i in range(NUM_GPUS)\n            }\n            # Add the CPU model.\n            futures[executor.submit(\n                GPT.from_pretrained,\n                model_name='openai-community/gpt2-xl',\n                map_location='cpu',\n                torch_profile_activities=TORCH_PROFILE_ACTIVITIES,\n            )] = NUM_GPUS\n            for future in as_completed(futures):\n                i = futures[future]\n                model = future.result()\n                PRETRAINED_MODELS[i] = model\n    msg = (\n        f'Loaded gpt2-xl model on {NUM_GPUS} GPU(s) and 1 CPU in '\n        f'{timer.elapsed:.3f} seconds.'\n    )\n    logging.info(msg)"
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#model-optimization",
    "href": "articles/pytorch-and-python-free-threading/index.html#model-optimization",
    "title": "PyTorch and Python Free-Threading",
    "section": "Model Optimization",
    "text": "Model Optimization\nTwo facilities are available to speed up your model in PyTorch: TorchScript, and Torch Dynamo, with the latter being a newer approach than the former.\nIn our parallelopedia.gpt2 module, our Gpt2App class has a classmethod named init_once(), which, as you can probably guess, gets called once by the HTTP server when starting up. This is where you stash expensive setup code like loading and compiling models.\nThe code looks similar to the following. We have two globals, TORCH_JIT_COMPILE and TORCH_DYNAMO_COMPILE that, when set, will attempt to optimize the models using the selected method.\n\nclass Gpt2App(HttpApp):\n\n    ...\n\n    @classmethod\n    def init_once(cls):\n        load_models()\n        load_pretrained_models()\n\n        global MODELS, PRETRAINED_MODELS\n\n        # This doesn't work because torch.jit doesn't handle our\n        # async generator.\n        global TRY_JIT_COMPILE\n        if TRY_JIT_COMPILE:\n            for (i, model) in enumerate(MODELS):\n                model.config = dataclasses.asdict(model.config)\n                timer = ElapsedTimer()\n                with timer:\n                    model = torch.jit.script(model)\n                    MODELS[i] = model\n                logging.info(\n                    f'JIT compiled model {i} in {timer.elapsed:.3f} seconds.'\n                )\n\n        global TRY_TORCH_COMPILE\n        if TRY_TORCH_COMPILE:\n            for (i, model) in enumerate(MODELS):\n                model.config = dataclasses.asdict(model.config)\n                timer = ElapsedTimer()\n                with timer:\n                    model = torch.compile(model)\n                    MODELS[i] = model\n                logging.info(\n                    f'torch.compiled model {i} in '\n                    f'{timer.elapsed:.3f} seconds.'\n                )\n\n            for (i, model) in enumerate(PRETRAINED_MODELS):\n                model.config = dataclasses.asdict(model.config)\n                timer = ElapsedTimer()\n                with timer:\n                    model = torch.compile(model)\n                    PRETRAINED_MODELS[i] = model\n                logging.info(\n                    f'torch.compiled pretrained model {i} in '\n                    f'{timer.elapsed:.3f} seconds.'\n                )\n\nTorchScript\nTorchScript doesn’t work at all for our model—it balks on the async def generate_async_for() routine that is the workhorse of our asynchronous token-by-token generation.\nAnd that ended my TorchScript experiment :-)\n\n\nTorch Dynamo (torch.compile)\nTorch Dynamo is a new feature that was introduced by PyTorch 2.0 that hooks into the Python interpreter and traces model execution and then builds optimized kernels based on the information observed during runtime tracing.\nWhen it works, it works really well, and you can get significant speedups both in training and inference with literally a single line:\nmodel = torch.compile(model)\nThe first problem we hit with Dynamo is that it’s explicitly not supported by PyTorch on free-threaded builds:\n&gt;&gt;&gt; model = torch.compile(model)\n---------------------------------------------------------------------------\nRuntimeError                              Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 model = torch.compile(model)\n\nFile ~/mambaforge/envs/py313t/lib/python3.13t/site-packages/torch/__init__.py:2526, in compile(model, fullgraph, dynamic, backend, mode, options, disable)\n   2524     raise RuntimeError(\"torch.compile is not supported on Python 3.14+\")\n   2525 elif sysconfig.get_config_var(\"Py_GIL_DISABLED\") == 1:\n-&gt; 2526     raise RuntimeError(\n   2527         \"torch.compile is not supported on Python built with GIL disabled\"\n   2528     )\n   2530 # Decorator mode\n   2531 if model is None:\n\nRuntimeError: torch.compile is not supported on Python built with GIL disabled\nLet’s hack that torch/__init__.py file as follows and try again.\n--- __init__.py.orig    2025-02-09 13:28:27.892979258 -0800\n+++ __init__.py 2025-02-09 13:30:13.879909529 -0800\n@@ -2523,9 +2523,7 @@\n     if sys.version_info &gt;= (3, 14):\n         raise RuntimeError(\"torch.compile is not supported on Python 3.14+\")\n     elif sysconfig.get_config_var(\"Py_GIL_DISABLED\") == 1:\n-        raise RuntimeError(\n-            \"torch.compile is not supported on Python built with GIL disabled\"\n-        )\n+        print(\"torch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\")\n\n     # Decorator mode\n     if model is None:\n&gt;&gt;&gt; model = torch.compile(model)\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\n---------------------------------------------------------------------------\nRuntimeError                              Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 model = torch.compile(model)\n\nFile ~/mambaforge/envs/py313t/lib/python3.13t/site-packages/torch/__init__.py:2563, in compile(model, fullgraph, dynamic, backend, mode, options, disable)\n   2560 else:\n   2561     backend = _TorchCompileWrapper(backend, mode, options, dynamic)\n-&gt; 2563 return torch._dynamo.optimize(\n   2564     backend=backend,\n   2565     nopython=fullgraph,\n   2566     dynamic=dynamic,\n   2567     disable=disable,\n   2568 )(model)\n\nFile ~/mambaforge/envs/py313t/lib/python3.13t/site-packages/torch/_dynamo/eval_frame.py:842, in optimize(*args, **kwargs)\n    839         kwargs[\"nopython\"] = ca_kwargs_override[\"fullgraph\"]\n    840     return optimize(*args, **kwargs)\n--&gt; 842 return _optimize(rebuild_ctx, *args, **kwargs)\n\nFile ~/mambaforge/envs/py313t/lib/python3.13t/site-packages/torch/_dynamo/eval_frame.py:881, in _optimize(rebuild_ctx, backend, nopython, guard_export_fn, guard_fail_fn, disable, dynamic)\n    845 def _optimize(\n    846     rebuild_ctx: Callable[[], Union[OptimizeContext, _NullDecorator]],\n    847     backend=\"inductor\",\n   (...)\n    853     dynamic=None,\n    854 ) -&gt; Union[OptimizeContext, _NullDecorator]:\n    855     \"\"\"\n    856     The main entrypoint of TorchDynamo.  Do graph capture and call\n    857     backend() to optimize extracted graphs.\n   (...)\n    879             ...\n    880     \"\"\"\n--&gt; 881     check_if_dynamo_supported()\n    882     # Note: The hooks object could be global instead of passed around, *however* that would make\n    883     # for a confusing API usage and plumbing story wherein we nest multiple .optimize calls.\n    884     # There is some prior art around this, w/r/t nesting backend calls are enforced to be the same\n    885     # compiler, however, this feels onerous for callback and hooks, and it feels better to give our users an\n    886     # easier to understand UX at the cost of a little more plumbing on our end.\n    887     hooks = Hooks(guard_export_fn=guard_export_fn, guard_fail_fn=guard_fail_fn)\n\nFile ~/mambaforge/envs/py313t/lib/python3.13t/site-packages/torch/_dynamo/eval_frame.py:805, in check_if_dynamo_supported()\n    803     raise RuntimeError(\"Python 3.14+ not yet supported for torch.compile\")\n    804 elif sysconfig.get_config_var(\"Py_GIL_DISABLED\") == 1:\n--&gt; 805     raise RuntimeError(\n    806         \"torch.compile is not supported on Python built with GIL disabled\"\n    807     )\n\nRuntimeError: torch.compile is not supported on Python built with GIL disabled\nLet’s hack torch/_dynamo/eval_frame.py too:\n--- eval_frame.py.orig  2025-02-09 13:32:18.266470283 -0800\n+++ eval_frame.py       2025-02-09 13:32:32.746291774 -0800\n@@ -802,9 +802,7 @@\n     if sys.version_info &gt;= (3, 14):\n         raise RuntimeError(\"Python 3.14+ not yet supported for torch.compile\")\n     elif sysconfig.get_config_var(\"Py_GIL_DISABLED\") == 1:\n-        raise RuntimeError(\n-            \"torch.compile is not supported on Python built with GIL disabled\"\n-        )\n+        print(\"torch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\")\n\n\n def is_dynamo_supported():\nNow let’s try again:\n&gt;&gt;&gt; model = torch.compile(model)\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\n&gt;&gt;&gt;\nSo, we can forcibly coerce PyTorch Dynamo to compile our model even if we’re in free-threaded mode.\nBut does it work? And is it faster? Let’s investigate.\nWe can invoke our parallelopedia.gpt2 module directly with various command line arguments to test out generation performance. The accompanying --help is furnished below for reference:\n% python -m parallelopedia.gpt2 --help\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\nusage: gpt2.py [-h] [--log-level {DEBUG,INFO,WARNING,ERROR,CRITICAL}] [--model {gpt2,gpt2-xl}] [--device DEVICE]\n               [--max-length MAX_LENGTH] [--top-k TOP_K] [--seed SEED] [--prompt PROMPT] [--torch-compile] [--torch-jit]\n               [--torch-compile-fullgraph] [--torch-compile-reduce-overhead] [--torch-compile-max-autotune]\n               [--generate-slim] [--rounds ROUNDS] [--wrap WRAP] [--note NOTE]\n\nRun the GPT2 module.\n\noptions:\n  -h, --help            show this help message and exit\n  --log-level {DEBUG,INFO,WARNING,ERROR,CRITICAL}\n                        Set the logging level.\n  --model {gpt2,gpt2-xl}\n                        Select the model to use.\n  --device DEVICE       Select the device to use.\n  --max-length MAX_LENGTH\n                        Set the maximum length of the generated text.\n  --top-k TOP_K         Set the top-k value for sampling.\n  --seed SEED           Set the random seed for generation.\n  --prompt PROMPT       Set the prompt for generation.\n  --torch-compile       Compile the models using torch.compile().\n  --torch-jit           Compile the models using torch.jit.script().\n  --torch-compile-fullgraph\n                        Compile the models using torch.compile() with fullgraph=True.\n  --torch-compile-reduce-overhead\n                        Compile the models using torch.compile() with mode=\"reduce-overhead\"\n  --torch-compile-max-autotune\n                        Compile the models using torch.compile() with mode=\"max_autotune\".\n  --generate-slim       Use the generate_slim() method for generation.\n  --rounds ROUNDS       Set the number of rounds for generation.\n  --wrap WRAP           Set the wrap width for text output.\n  --note NOTE           Set a note to include in the JSON output.\nThe full source code for the module’s main() function follows. Based on the command line parameters furnished, we can test various generation variants, such as no torch.compile(), torch.compile() and nothing else, and more advanced permutations such as the following:\nkwds = {\n    'fullgraph': True,\n    'model': 'max-autotune',\n}\nmodel = torch.compile(model, **kwds)\n\n\n\n\n\n\nFull Source Code for parallelopedia.gpt2.main()\n\n\n\n\n\ndef main():\n    \"\"\"\n    Main entry point for the parallelopedia.gpt2 module.\n    \"\"\"\n    args = parse_arguments()\n\n    logging.basicConfig(\n        level=getattr(logging, args.log_level),\n        format='%(asctime)s - %(levelname)s - %(message)s',\n    )\n\n    start_time = time.time()\n    start_timestamp = datetime.datetime.now().isoformat()\n\n    timer = ElapsedTimer()\n    with timer:\n        if args.model == 'gpt2-xl':\n            model = GPT.from_pretrained(\n                model_name='openai-community/gpt2-xl',\n                map_location=args.device,\n            )\n        else:\n            model = GPT.from_local_pretrained(\n                model_path=MODEL_CHECKPOINT,\n                map_location=args.device,\n                manual_seed=args.seed,\n            )\n    logging.info(\n        f'Loaded {args.model} on {args.device} '\n        f'in {timer.elapsed:.3f} seconds.'\n    )\n\n    if args.torch_compile:\n        if args.torch_jit:\n            msg = 'Cannot specify both --torch-compile and --torch-jit.'\n            raise ValueError(msg)\n        model.config = dataclasses.asdict(model.config)\n        kwds = {}\n        if args.torch_compile_fullgraph:\n            kwds['fullgraph'] = True\n        if args.torch_compile_reduce_overhead:\n            if args.torch_compile_max_autotune:\n                msg = (\n                    'Cannot specify both --torch-compile-reduce-overhead '\n                    'and --torch-compile-max-autotune.'\n                )\n                raise ValueError(msg)\n            kwds['mode'] = 'reduce-overhead'\n        elif args.torch_compile_max_autotune:\n            kwds['mode'] = 'max-autotune'\n        with timer:\n            model = torch.compile(model, **kwds)\n        msg = f'torch.compiled model in {timer.elapsed:.3f} seconds.'\n        logging.info(msg)\n    elif args.torch_jit:\n        model.config = dataclasses.asdict(model.config)\n        with timer:\n            model = torch.jit.script(model)\n        msg = f'JIT compiled model in {timer.elapsed:.3f} seconds.')\n        logging.info(msg)\n\n    seed = args.seed\n    if seed is None or seed == '':\n        seed = random.randint(0, 2**32 - 1)\n\n    if args.generate_slim:\n        text_tokens = model.enc.encode(args.prompt)\n        prompt_token_length = len(text_tokens)\n\n    rates = []\n    for i in range(args.rounds):\n        logging.info(f'Round {i + 1} of {args.rounds}.')\n        if args.generate_slim:\n            with timer:\n                x = model.generate_slim(\n                    text_tokens,\n                    max_length=args.max_length,\n                    top_k=args.top_k,\n                    seed=seed,\n                )\n            elapsed = timer.elapsed\n            count = x.size(1) - prompt_token_length\n            tokens_per_sec = count / elapsed\n            rates.append(tokens_per_sec)\n            logging.info(\n                f'Generated {count} tokens in {elapsed:.2f} seconds '\n                f'({tokens_per_sec:.2f} tokens/sec)'\n            )\n            output = model.enc.decode(x[0].tolist())\n        else:\n            save_rate = lambda x: rates.append(x)\n            output = model.generate(\n                args.prompt,\n                max_length=args.max_length,\n                top_k=args.top_k,\n                seed=seed,\n                save_rate=save_rate,\n            )\n\n        if args.wrap:\n            output = textwrap.fill(output, width=args.wrap)\n        logging.info(f'Output:\\n{output}')\n\n    # The filename is of the form:\n    #   `gpt2-rates-&lt;yyyy-mm-dd-hh-ss-mm.sss&gt;-[optional].json`\n    now = datetime.datetime.now()\n    timestamp = now.strftime('%Y-%m-%d-%H-%M-%S-%f')\n    filename = f\"gpt2-rates-{timestamp}\"\n    if args.torch_compile:\n        filename += '-torch-compile'\n        if args.torch_compile_reduce_overhead:\n            filename += '-reduce-overhead'\n        elif args.torch_compile_max_autotune:\n            filename += '-max-autotune'\n        if args.torch_compile_fullgraph:\n            filename += '-fullgraph'\n    if args.generate_slim:\n        filename += '-generate-slim'\n\n    conda_env_name = os.environ.get('CONDA_DEFAULT_ENV', 'Unknown')\n    filename += f'-{conda_env_name}'\n\n    filename += '.json'\n\n    if not isinstance(model.config, dict):\n        model_config = dataclasses.asdict(model.config)\n    else:\n        model_config = model.config\n\n    end_time = time.time()\n    end_timestamp = datetime.datetime.now().isoformat()\n\n    if args.device.startswith('cuda'):\n        ix = args.device.find(':')\n        if ix == -1:\n            device_index = 0\n        else:\n            device_index = int(args.device[ix+1:])\n\n        device_name = torch.cuda.get_device_name(device_index)\n    else:\n        device_name = 'CPU'\n\n    try:\n        is_gil_enabled = sys._is_gil_enabled()\n    except AttributeError:\n        is_gil_enabled = False\n\n    # Prepare a dictionary with the details to save.\n    run_details = {\n        \"rates\": rates,\n        \"model_config\": model_config,\n        \"args\": vars(args),\n        \"start_timestamp\": start_timestamp,\n        \"end_timestamp\": end_timestamp,\n        \"elapsed\": f'{end_time - start_time:.3f}',\n        \"device_name\": device_name,\n        \"conda_env_name\": conda_env_name,\n        \"is_gil_enabled\": is_gil_enabled,\n        \"note\": args.note,\n    }\n\n    # Write the JSON file.\n    with open(filename, \"w\") as json_file:\n        json.dump(run_details, json_file, indent=4)\n\n    logging.info(f\"Run details saved to {filename}.\")\n\n\n\nLet’s take a look at whether or not torch.compile() improves performance in our py313t free-threaded environment, first.\n\nPerformance Comparison\nI wrote a bash script run-py313t-gpt2-compile-tests.sh, reproduced below, that ran various permutations of generation with different torch.compile() options.\n#!/bin/bash\n\n# Ensure our environment name is `py313t`.\nif [ \"$CONDA_DEFAULT_ENV\" != \"py313t\" ]; then\n  echo \"Error: Conda environment is not 'py313t'.\"\n  exit 1\nfi\n\n# Ensure PARALLELOPEDIA_ROOT is set.\nif [ -z \"$PARALLELOPEDIA_ROOT\" ]; then\n  echo \"Error: PARALLELOPEDIA_ROOT is not set.\"\n  exit 1\nfi\n\n\nSEED=42\nDEVICE=\"cuda:3\"\nROUNDS=20\n\nOPTIONS=(\n  \"--torch-compile\"\n  \"--torch-compile --torch-compile-fullgraph\"\n  \"--torch-compile --torch-compile-reduce-overhead\"\n  \"--torch-compile --torch-compile-reduce-overhead --torch-compile-fullgraph\"\n  \"--torch-compile --torch-compile-reduce-overhead --torch-compile-fullgraph\"\n  \"--torch-compile --torch-compile-max-autotune\"\n  \"--torch-compile --torch-compile-max-autotune --torch-compile-fullgraph\"\n)\n\necho \"GPT.generate() variants\"\ntime python -Xgil=0 -m parallelopedia.gpt2    \\\n    --seed=$SEED                              \\\n    --rounds=$ROUNDS                          \\\n    --device=$DEVICE\n\nfor opt in \"${OPTIONS[@]}\"; do\n    # Split opt into separate arguments.\n    eval set -- $opt\n    time python -Xgil=0 -m parallelopedia.gpt2    \\\n        --seed=$SEED                              \\\n        --rounds=$ROUNDS                          \\\n        --device=$DEVICE                          \\\n        \"$@\"\ndone\nThe full log file for the run is captured in the callout below.\n\n\n\n\n\n\nrun-py313t-gpt2-compile-tests.log\n\n\n\n\n\nGPT.generate() variants\n2025-02-10 20:47:17,958 - INFO - Loaded /mnt/raid1/trent/src/parallelopedia/data/model_19072.pt checkpoint in 0.463 seconds.\n2025-02-10 20:47:17,965 - INFO - Initialized GPT model in 0.007 seconds.\n2025-02-10 20:47:18,191 - INFO - Loaded model weights in 0.226 seconds.\n&lt;frozen importlib._bootstrap&gt;:488: RuntimeWarning: The global interpreter lock (GIL) has been enabled to load module 'triton._C.libtriton', which has not declared that it can run safely without the GIL. To override this behavior and keep the GIL disabled (at your own risk), run with PYTHON_GIL=0 or -Xgil=0.\n2025-02-10 20:47:18,558 - INFO - Created GPT model in 0.600 seconds.\n2025-02-10 20:47:18,642 - INFO - Moved model to cuda:3 in 0.083 seconds.\n2025-02-10 20:47:18,642 - INFO - Loaded model from step 19072, val_loss 3.0519702434539795\n2025-02-10 20:47:18,642 - INFO - Loaded gpt2 on cuda:3 in 1.148 seconds.\n2025-02-10 20:47:18,642 - INFO - Round 1 of 20.\n2025-02-10 20:47:19,454 - INFO - Generated 91 tokens in 0.81 seconds (112.32 tokens/sec)\n2025-02-10 20:47:19,454 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:19,454 - INFO - Round 2 of 20.\n2025-02-10 20:47:20,091 - INFO - Generated 91 tokens in 0.64 seconds (142.89 tokens/sec)\n2025-02-10 20:47:20,092 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:20,092 - INFO - Round 3 of 20.\n2025-02-10 20:47:20,731 - INFO - Generated 91 tokens in 0.64 seconds (142.49 tokens/sec)\n2025-02-10 20:47:20,731 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:20,731 - INFO - Round 4 of 20.\n2025-02-10 20:47:21,366 - INFO - Generated 91 tokens in 0.63 seconds (143.47 tokens/sec)\n2025-02-10 20:47:21,366 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:21,366 - INFO - Round 5 of 20.\n2025-02-10 20:47:22,000 - INFO - Generated 91 tokens in 0.63 seconds (143.62 tokens/sec)\n2025-02-10 20:47:22,000 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:22,000 - INFO - Round 6 of 20.\n2025-02-10 20:47:22,634 - INFO - Generated 91 tokens in 0.63 seconds (143.62 tokens/sec)\n2025-02-10 20:47:22,635 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:22,635 - INFO - Round 7 of 20.\n2025-02-10 20:47:23,270 - INFO - Generated 91 tokens in 0.64 seconds (143.25 tokens/sec)\n2025-02-10 20:47:23,271 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:23,271 - INFO - Round 8 of 20.\n2025-02-10 20:47:23,904 - INFO - Generated 91 tokens in 0.63 seconds (143.67 tokens/sec)\n2025-02-10 20:47:23,905 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:23,905 - INFO - Round 9 of 20.\n2025-02-10 20:47:24,539 - INFO - Generated 91 tokens in 0.63 seconds (143.56 tokens/sec)\n2025-02-10 20:47:24,539 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:24,539 - INFO - Round 10 of 20.\n2025-02-10 20:47:25,174 - INFO - Generated 91 tokens in 0.63 seconds (143.56 tokens/sec)\n2025-02-10 20:47:25,174 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:25,174 - INFO - Round 11 of 20.\n2025-02-10 20:47:25,812 - INFO - Generated 91 tokens in 0.64 seconds (142.78 tokens/sec)\n2025-02-10 20:47:25,812 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:25,812 - INFO - Round 12 of 20.\n2025-02-10 20:47:26,444 - INFO - Generated 91 tokens in 0.63 seconds (143.92 tokens/sec)\n2025-02-10 20:47:26,445 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:26,445 - INFO - Round 13 of 20.\n2025-02-10 20:47:27,080 - INFO - Generated 91 tokens in 0.63 seconds (143.34 tokens/sec)\n2025-02-10 20:47:27,080 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:27,081 - INFO - Round 14 of 20.\n2025-02-10 20:47:27,716 - INFO - Generated 91 tokens in 0.63 seconds (143.34 tokens/sec)\n2025-02-10 20:47:27,716 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:27,716 - INFO - Round 15 of 20.\n2025-02-10 20:47:28,350 - INFO - Generated 91 tokens in 0.63 seconds (143.65 tokens/sec)\n2025-02-10 20:47:28,350 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:28,350 - INFO - Round 16 of 20.\n2025-02-10 20:47:28,984 - INFO - Generated 91 tokens in 0.63 seconds (143.73 tokens/sec)\n2025-02-10 20:47:28,984 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:28,984 - INFO - Round 17 of 20.\n2025-02-10 20:47:29,617 - INFO - Generated 91 tokens in 0.63 seconds (143.79 tokens/sec)\n2025-02-10 20:47:29,618 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:29,618 - INFO - Round 18 of 20.\n2025-02-10 20:47:30,260 - INFO - Generated 91 tokens in 0.64 seconds (141.71 tokens/sec)\n2025-02-10 20:47:30,261 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:30,261 - INFO - Round 19 of 20.\n2025-02-10 20:47:30,896 - INFO - Generated 91 tokens in 0.63 seconds (143.36 tokens/sec)\n2025-02-10 20:47:30,896 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:30,896 - INFO - Round 20 of 20.\n2025-02-10 20:47:31,530 - INFO - Generated 91 tokens in 0.63 seconds (143.55 tokens/sec)\n2025-02-10 20:47:31,531 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:31,531 - INFO - Run details saved to gpt2-rates-2025-02-10-20-47-31-531204-py313t.json.\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\n\nreal    0m19.736s\nuser    0m22.944s\nsys 0m1.382s\nException ignored in: &lt;_io.BufferedWriter name=41&gt;\nBrokenPipeError: [Errno 32] Broken pipe\n2025-02-10 20:47:37,663 - INFO - Loaded /mnt/raid1/trent/src/parallelopedia/data/model_19072.pt checkpoint in 0.484 seconds.\n2025-02-10 20:47:37,670 - INFO - Initialized GPT model in 0.006 seconds.\n2025-02-10 20:47:37,896 - INFO - Loaded model weights in 0.226 seconds.\n&lt;frozen importlib._bootstrap&gt;:488: RuntimeWarning: The global interpreter lock (GIL) has been enabled to load module 'triton._C.libtriton', which has not declared that it can run safely without the GIL. To override this behavior and keep the GIL disabled (at your own risk), run with PYTHON_GIL=0 or -Xgil=0.\n2025-02-10 20:47:38,263 - INFO - Created GPT model in 0.600 seconds.\n2025-02-10 20:47:38,347 - INFO - Moved model to cuda:3 in 0.083 seconds.\n2025-02-10 20:47:38,347 - INFO - Loaded model from step 19072, val_loss 3.0519702434539795\n2025-02-10 20:47:38,347 - INFO - Loaded gpt2 on cuda:3 in 1.168 seconds.\n2025-02-10 20:47:38,349 - INFO - torch.compiled model in 0.002 seconds.\n2025-02-10 20:47:38,349 - INFO - Round 1 of 20.\n2025-02-10 20:47:39,174 - INFO - Generated 91 tokens in 0.82 seconds (110.47 tokens/sec)\n2025-02-10 20:47:39,174 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:39,174 - INFO - Round 2 of 20.\n2025-02-10 20:47:39,828 - INFO - Generated 91 tokens in 0.65 seconds (139.24 tokens/sec)\n2025-02-10 20:47:39,829 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:39,829 - INFO - Round 3 of 20.\n2025-02-10 20:47:40,483 - INFO - Generated 91 tokens in 0.65 seconds (139.04 tokens/sec)\n2025-02-10 20:47:40,484 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:40,484 - INFO - Round 4 of 20.\n2025-02-10 20:47:41,138 - INFO - Generated 91 tokens in 0.65 seconds (139.23 tokens/sec)\n2025-02-10 20:47:41,138 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:41,138 - INFO - Round 5 of 20.\n2025-02-10 20:47:41,791 - INFO - Generated 91 tokens in 0.65 seconds (139.47 tokens/sec)\n2025-02-10 20:47:41,791 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:41,791 - INFO - Round 6 of 20.\n2025-02-10 20:47:42,445 - INFO - Generated 91 tokens in 0.65 seconds (139.29 tokens/sec)\n2025-02-10 20:47:42,445 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:42,445 - INFO - Round 7 of 20.\n2025-02-10 20:47:43,099 - INFO - Generated 91 tokens in 0.65 seconds (139.09 tokens/sec)\n2025-02-10 20:47:43,100 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:43,100 - INFO - Round 8 of 20.\n2025-02-10 20:47:43,755 - INFO - Generated 91 tokens in 0.66 seconds (138.85 tokens/sec)\n2025-02-10 20:47:43,756 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:43,756 - INFO - Round 9 of 20.\n2025-02-10 20:47:44,409 - INFO - Generated 91 tokens in 0.65 seconds (139.29 tokens/sec)\n2025-02-10 20:47:44,410 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:44,410 - INFO - Round 10 of 20.\n2025-02-10 20:47:45,063 - INFO - Generated 91 tokens in 0.65 seconds (139.29 tokens/sec)\n2025-02-10 20:47:45,064 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:45,064 - INFO - Round 11 of 20.\n2025-02-10 20:47:45,718 - INFO - Generated 91 tokens in 0.65 seconds (139.11 tokens/sec)\n2025-02-10 20:47:45,718 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:45,719 - INFO - Round 12 of 20.\n2025-02-10 20:47:46,371 - INFO - Generated 91 tokens in 0.65 seconds (139.47 tokens/sec)\n2025-02-10 20:47:46,372 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:46,372 - INFO - Round 13 of 20.\n2025-02-10 20:47:47,046 - INFO - Generated 91 tokens in 0.67 seconds (135.03 tokens/sec)\n2025-02-10 20:47:47,046 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:47,046 - INFO - Round 14 of 20.\n2025-02-10 20:47:47,692 - INFO - Generated 91 tokens in 0.65 seconds (140.90 tokens/sec)\n2025-02-10 20:47:47,693 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:47,693 - INFO - Round 15 of 20.\n2025-02-10 20:47:48,339 - INFO - Generated 91 tokens in 0.65 seconds (140.84 tokens/sec)\n2025-02-10 20:47:48,339 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:48,340 - INFO - Round 16 of 20.\n2025-02-10 20:47:48,986 - INFO - Generated 91 tokens in 0.65 seconds (140.90 tokens/sec)\n2025-02-10 20:47:48,986 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:48,986 - INFO - Round 17 of 20.\n2025-02-10 20:47:49,634 - INFO - Generated 91 tokens in 0.65 seconds (140.40 tokens/sec)\n2025-02-10 20:47:49,635 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:49,635 - INFO - Round 18 of 20.\n2025-02-10 20:47:50,282 - INFO - Generated 91 tokens in 0.65 seconds (140.63 tokens/sec)\n2025-02-10 20:47:50,283 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:50,283 - INFO - Round 19 of 20.\n2025-02-10 20:47:50,929 - INFO - Generated 91 tokens in 0.65 seconds (140.73 tokens/sec)\n2025-02-10 20:47:50,930 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:50,930 - INFO - Round 20 of 20.\n2025-02-10 20:47:51,578 - INFO - Generated 91 tokens in 0.65 seconds (140.41 tokens/sec)\n2025-02-10 20:47:51,579 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:51,579 - INFO - Run details saved to gpt2-rates-2025-02-10-20-47-51-579116-torch-compile-py313t.json.\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\n\nreal    0m20.073s\nuser    0m23.400s\nsys 0m1.313s\nException ignored in: &lt;_io.BufferedWriter name=41&gt;\nBrokenPipeError: [Errno 32] Broken pipe\n2025-02-10 20:47:57,975 - INFO - Loaded /mnt/raid1/trent/src/parallelopedia/data/model_19072.pt checkpoint in 0.486 seconds.\n2025-02-10 20:47:57,982 - INFO - Initialized GPT model in 0.006 seconds.\n2025-02-10 20:47:58,209 - INFO - Loaded model weights in 0.227 seconds.\n&lt;frozen importlib._bootstrap&gt;:488: RuntimeWarning: The global interpreter lock (GIL) has been enabled to load module 'triton._C.libtriton', which has not declared that it can run safely without the GIL. To override this behavior and keep the GIL disabled (at your own risk), run with PYTHON_GIL=0 or -Xgil=0.\n2025-02-10 20:47:58,575 - INFO - Created GPT model in 0.599 seconds.\n2025-02-10 20:47:58,659 - INFO - Moved model to cuda:3 in 0.084 seconds.\n2025-02-10 20:47:58,659 - INFO - Loaded model from step 19072, val_loss 3.0519702434539795\n2025-02-10 20:47:58,659 - INFO - Loaded gpt2 on cuda:3 in 1.170 seconds.\n2025-02-10 20:47:58,660 - INFO - torch.compiled model in 0.001 seconds.\n2025-02-10 20:47:58,661 - INFO - Round 1 of 20.\n2025-02-10 20:47:59,483 - INFO - Generated 91 tokens in 0.82 seconds (110.79 tokens/sec)\n2025-02-10 20:47:59,483 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:47:59,483 - INFO - Round 2 of 20.\n2025-02-10 20:48:00,153 - INFO - Generated 91 tokens in 0.67 seconds (135.92 tokens/sec)\n2025-02-10 20:48:00,153 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:00,153 - INFO - Round 3 of 20.\n2025-02-10 20:48:00,796 - INFO - Generated 91 tokens in 0.64 seconds (141.66 tokens/sec)\n2025-02-10 20:48:00,796 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:00,796 - INFO - Round 4 of 20.\n2025-02-10 20:48:01,439 - INFO - Generated 91 tokens in 0.64 seconds (141.69 tokens/sec)\n2025-02-10 20:48:01,439 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:01,439 - INFO - Round 5 of 20.\n2025-02-10 20:48:02,086 - INFO - Generated 91 tokens in 0.65 seconds (140.83 tokens/sec)\n2025-02-10 20:48:02,086 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:02,086 - INFO - Round 6 of 20.\n2025-02-10 20:48:02,730 - INFO - Generated 91 tokens in 0.64 seconds (141.33 tokens/sec)\n2025-02-10 20:48:02,731 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:02,731 - INFO - Round 7 of 20.\n2025-02-10 20:48:03,374 - INFO - Generated 91 tokens in 0.64 seconds (141.45 tokens/sec)\n2025-02-10 20:48:03,375 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:03,375 - INFO - Round 8 of 20.\n2025-02-10 20:48:04,017 - INFO - Generated 91 tokens in 0.64 seconds (141.76 tokens/sec)\n2025-02-10 20:48:04,017 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:04,017 - INFO - Round 9 of 20.\n2025-02-10 20:48:04,661 - INFO - Generated 91 tokens in 0.64 seconds (141.46 tokens/sec)\n2025-02-10 20:48:04,661 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:04,661 - INFO - Round 10 of 20.\n2025-02-10 20:48:05,303 - INFO - Generated 91 tokens in 0.64 seconds (141.82 tokens/sec)\n2025-02-10 20:48:05,303 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:05,303 - INFO - Round 11 of 20.\n2025-02-10 20:48:05,945 - INFO - Generated 91 tokens in 0.64 seconds (141.91 tokens/sec)\n2025-02-10 20:48:05,945 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:05,945 - INFO - Round 12 of 20.\n2025-02-10 20:48:06,587 - INFO - Generated 91 tokens in 0.64 seconds (141.83 tokens/sec)\n2025-02-10 20:48:06,587 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:06,587 - INFO - Round 13 of 20.\n2025-02-10 20:48:07,229 - INFO - Generated 91 tokens in 0.64 seconds (141.93 tokens/sec)\n2025-02-10 20:48:07,229 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:07,229 - INFO - Round 14 of 20.\n2025-02-10 20:48:07,871 - INFO - Generated 91 tokens in 0.64 seconds (141.88 tokens/sec)\n2025-02-10 20:48:07,871 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:07,871 - INFO - Round 15 of 20.\n2025-02-10 20:48:08,513 - INFO - Generated 91 tokens in 0.64 seconds (141.74 tokens/sec)\n2025-02-10 20:48:08,514 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:08,514 - INFO - Round 16 of 20.\n2025-02-10 20:48:09,157 - INFO - Generated 91 tokens in 0.64 seconds (141.58 tokens/sec)\n2025-02-10 20:48:09,157 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:09,157 - INFO - Round 17 of 20.\n2025-02-10 20:48:09,799 - INFO - Generated 91 tokens in 0.64 seconds (141.79 tokens/sec)\n2025-02-10 20:48:09,800 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:09,800 - INFO - Round 18 of 20.\n2025-02-10 20:48:10,442 - INFO - Generated 91 tokens in 0.64 seconds (141.75 tokens/sec)\n2025-02-10 20:48:10,442 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:10,442 - INFO - Round 19 of 20.\n2025-02-10 20:48:11,084 - INFO - Generated 91 tokens in 0.64 seconds (141.77 tokens/sec)\n2025-02-10 20:48:11,085 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:11,085 - INFO - Round 20 of 20.\n2025-02-10 20:48:11,727 - INFO - Generated 91 tokens in 0.64 seconds (141.75 tokens/sec)\n2025-02-10 20:48:11,727 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:11,728 - INFO - Run details saved to gpt2-rates-2025-02-10-20-48-11-727901-torch-compile-fullgraph-py313t.json.\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\n\nreal    0m20.125s\nuser    0m23.218s\nsys 0m1.382s\nException ignored in: &lt;_io.BufferedWriter name=41&gt;\nBrokenPipeError: [Errno 32] Broken pipe\n2025-02-10 20:48:17,900 - INFO - Loaded /mnt/raid1/trent/src/parallelopedia/data/model_19072.pt checkpoint in 0.486 seconds.\n2025-02-10 20:48:17,907 - INFO - Initialized GPT model in 0.006 seconds.\n2025-02-10 20:48:18,132 - INFO - Loaded model weights in 0.225 seconds.\n&lt;frozen importlib._bootstrap&gt;:488: RuntimeWarning: The global interpreter lock (GIL) has been enabled to load module 'triton._C.libtriton', which has not declared that it can run safely without the GIL. To override this behavior and keep the GIL disabled (at your own risk), run with PYTHON_GIL=0 or -Xgil=0.\n2025-02-10 20:48:18,494 - INFO - Created GPT model in 0.594 seconds.\n2025-02-10 20:48:18,577 - INFO - Moved model to cuda:3 in 0.082 seconds.\n2025-02-10 20:48:18,577 - INFO - Loaded model from step 19072, val_loss 3.0519702434539795\n2025-02-10 20:48:18,577 - INFO - Loaded gpt2 on cuda:3 in 1.162 seconds.\n2025-02-10 20:48:18,581 - INFO - torch.compiled model in 0.004 seconds.\n2025-02-10 20:48:18,581 - INFO - Round 1 of 20.\n2025-02-10 20:48:19,397 - INFO - Generated 91 tokens in 0.82 seconds (111.57 tokens/sec)\n2025-02-10 20:48:19,398 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:19,398 - INFO - Round 2 of 20.\n2025-02-10 20:48:20,044 - INFO - Generated 91 tokens in 0.65 seconds (140.99 tokens/sec)\n2025-02-10 20:48:20,044 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:20,044 - INFO - Round 3 of 20.\n2025-02-10 20:48:20,690 - INFO - Generated 91 tokens in 0.65 seconds (140.95 tokens/sec)\n2025-02-10 20:48:20,690 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:20,690 - INFO - Round 4 of 20.\n2025-02-10 20:48:21,335 - INFO - Generated 91 tokens in 0.64 seconds (141.16 tokens/sec)\n2025-02-10 20:48:21,336 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:21,336 - INFO - Round 5 of 20.\n2025-02-10 20:48:21,981 - INFO - Generated 91 tokens in 0.64 seconds (141.10 tokens/sec)\n2025-02-10 20:48:21,981 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:21,981 - INFO - Round 6 of 20.\n2025-02-10 20:48:22,627 - INFO - Generated 91 tokens in 0.65 seconds (141.03 tokens/sec)\n2025-02-10 20:48:22,627 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:22,627 - INFO - Round 7 of 20.\n2025-02-10 20:48:23,274 - INFO - Generated 91 tokens in 0.65 seconds (140.67 tokens/sec)\n2025-02-10 20:48:23,275 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:23,275 - INFO - Round 8 of 20.\n2025-02-10 20:48:23,950 - INFO - Generated 91 tokens in 0.68 seconds (134.77 tokens/sec)\n2025-02-10 20:48:23,950 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:23,951 - INFO - Round 9 of 20.\n2025-02-10 20:48:24,637 - INFO - Generated 91 tokens in 0.69 seconds (132.66 tokens/sec)\n2025-02-10 20:48:24,637 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:24,637 - INFO - Round 10 of 20.\n2025-02-10 20:48:25,293 - INFO - Generated 91 tokens in 0.66 seconds (138.78 tokens/sec)\n2025-02-10 20:48:25,294 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:25,294 - INFO - Round 11 of 20.\n2025-02-10 20:48:25,952 - INFO - Generated 91 tokens in 0.66 seconds (138.35 tokens/sec)\n2025-02-10 20:48:25,952 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:25,952 - INFO - Round 12 of 20.\n2025-02-10 20:48:26,609 - INFO - Generated 91 tokens in 0.66 seconds (138.65 tokens/sec)\n2025-02-10 20:48:26,609 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:26,609 - INFO - Round 13 of 20.\n2025-02-10 20:48:27,265 - INFO - Generated 91 tokens in 0.66 seconds (138.73 tokens/sec)\n2025-02-10 20:48:27,265 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:27,265 - INFO - Round 14 of 20.\n2025-02-10 20:48:27,922 - INFO - Generated 91 tokens in 0.66 seconds (138.71 tokens/sec)\n2025-02-10 20:48:27,922 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:27,922 - INFO - Round 15 of 20.\n2025-02-10 20:48:28,579 - INFO - Generated 91 tokens in 0.66 seconds (138.54 tokens/sec)\n2025-02-10 20:48:28,580 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:28,580 - INFO - Round 16 of 20.\n2025-02-10 20:48:29,236 - INFO - Generated 91 tokens in 0.66 seconds (138.70 tokens/sec)\n2025-02-10 20:48:29,236 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:29,236 - INFO - Round 17 of 20.\n2025-02-10 20:48:29,894 - INFO - Generated 91 tokens in 0.66 seconds (138.52 tokens/sec)\n2025-02-10 20:48:29,894 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:29,894 - INFO - Round 18 of 20.\n2025-02-10 20:48:30,550 - INFO - Generated 91 tokens in 0.66 seconds (138.78 tokens/sec)\n2025-02-10 20:48:30,550 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:30,550 - INFO - Round 19 of 20.\n2025-02-10 20:48:31,208 - INFO - Generated 91 tokens in 0.66 seconds (138.36 tokens/sec)\n2025-02-10 20:48:31,209 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:31,209 - INFO - Round 20 of 20.\n2025-02-10 20:48:31,869 - INFO - Generated 91 tokens in 0.66 seconds (137.96 tokens/sec)\n2025-02-10 20:48:31,869 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:31,869 - INFO - Run details saved to gpt2-rates-2025-02-10-20-48-31-869451-torch-compile-reduce-overhead-py313t.json.\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\n\nreal    0m20.138s\nuser    0m23.350s\nsys 0m1.425s\nException ignored in: &lt;_io.BufferedWriter name=41&gt;\nBrokenPipeError: [Errno 32] Broken pipe\n2025-02-10 20:48:38,069 - INFO - Loaded /mnt/raid1/trent/src/parallelopedia/data/model_19072.pt checkpoint in 0.481 seconds.\n2025-02-10 20:48:38,076 - INFO - Initialized GPT model in 0.006 seconds.\n2025-02-10 20:48:38,305 - INFO - Loaded model weights in 0.228 seconds.\n&lt;frozen importlib._bootstrap&gt;:488: RuntimeWarning: The global interpreter lock (GIL) has been enabled to load module 'triton._C.libtriton', which has not declared that it can run safely without the GIL. To override this behavior and keep the GIL disabled (at your own risk), run with PYTHON_GIL=0 or -Xgil=0.\n2025-02-10 20:48:38,672 - INFO - Created GPT model in 0.602 seconds.\n2025-02-10 20:48:38,756 - INFO - Moved model to cuda:3 in 0.085 seconds.\n2025-02-10 20:48:38,756 - INFO - Loaded model from step 19072, val_loss 3.0519702434539795\n2025-02-10 20:48:38,757 - INFO - Loaded gpt2 on cuda:3 in 1.169 seconds.\n2025-02-10 20:48:38,759 - INFO - torch.compiled model in 0.002 seconds.\n2025-02-10 20:48:38,759 - INFO - Round 1 of 20.\n2025-02-10 20:48:39,584 - INFO - Generated 91 tokens in 0.82 seconds (110.43 tokens/sec)\n2025-02-10 20:48:39,584 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:39,584 - INFO - Round 2 of 20.\n2025-02-10 20:48:40,223 - INFO - Generated 91 tokens in 0.64 seconds (142.66 tokens/sec)\n2025-02-10 20:48:40,223 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:40,223 - INFO - Round 3 of 20.\n2025-02-10 20:48:40,863 - INFO - Generated 91 tokens in 0.64 seconds (142.18 tokens/sec)\n2025-02-10 20:48:40,864 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:40,864 - INFO - Round 4 of 20.\n2025-02-10 20:48:41,501 - INFO - Generated 91 tokens in 0.64 seconds (142.76 tokens/sec)\n2025-02-10 20:48:41,502 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:41,502 - INFO - Round 5 of 20.\n2025-02-10 20:48:42,140 - INFO - Generated 91 tokens in 0.64 seconds (142.55 tokens/sec)\n2025-02-10 20:48:42,141 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:42,141 - INFO - Round 6 of 20.\n2025-02-10 20:48:42,779 - INFO - Generated 91 tokens in 0.64 seconds (142.60 tokens/sec)\n2025-02-10 20:48:42,779 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:42,779 - INFO - Round 7 of 20.\n2025-02-10 20:48:43,416 - INFO - Generated 91 tokens in 0.64 seconds (142.91 tokens/sec)\n2025-02-10 20:48:43,417 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:43,417 - INFO - Round 8 of 20.\n2025-02-10 20:48:44,058 - INFO - Generated 91 tokens in 0.64 seconds (141.92 tokens/sec)\n2025-02-10 20:48:44,059 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:44,059 - INFO - Round 9 of 20.\n2025-02-10 20:48:44,700 - INFO - Generated 91 tokens in 0.64 seconds (141.97 tokens/sec)\n2025-02-10 20:48:44,700 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:44,700 - INFO - Round 10 of 20.\n2025-02-10 20:48:45,339 - INFO - Generated 91 tokens in 0.64 seconds (142.54 tokens/sec)\n2025-02-10 20:48:45,339 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:45,339 - INFO - Round 11 of 20.\n2025-02-10 20:48:45,977 - INFO - Generated 91 tokens in 0.64 seconds (142.78 tokens/sec)\n2025-02-10 20:48:45,977 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:45,977 - INFO - Round 12 of 20.\n2025-02-10 20:48:46,617 - INFO - Generated 91 tokens in 0.64 seconds (142.24 tokens/sec)\n2025-02-10 20:48:46,618 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:46,618 - INFO - Round 13 of 20.\n2025-02-10 20:48:47,264 - INFO - Generated 91 tokens in 0.65 seconds (140.87 tokens/sec)\n2025-02-10 20:48:47,264 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:47,265 - INFO - Round 14 of 20.\n2025-02-10 20:48:47,912 - INFO - Generated 91 tokens in 0.65 seconds (140.53 tokens/sec)\n2025-02-10 20:48:47,913 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:47,913 - INFO - Round 15 of 20.\n2025-02-10 20:48:48,561 - INFO - Generated 91 tokens in 0.65 seconds (140.36 tokens/sec)\n2025-02-10 20:48:48,562 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:48,562 - INFO - Round 16 of 20.\n2025-02-10 20:48:49,185 - INFO - Generated 91 tokens in 0.62 seconds (146.20 tokens/sec)\n2025-02-10 20:48:49,185 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:49,185 - INFO - Round 17 of 20.\n2025-02-10 20:48:49,805 - INFO - Generated 91 tokens in 0.62 seconds (146.85 tokens/sec)\n2025-02-10 20:48:49,805 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:49,805 - INFO - Round 18 of 20.\n2025-02-10 20:48:50,426 - INFO - Generated 91 tokens in 0.62 seconds (146.54 tokens/sec)\n2025-02-10 20:48:50,427 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:50,427 - INFO - Round 19 of 20.\n2025-02-10 20:48:51,048 - INFO - Generated 91 tokens in 0.62 seconds (146.67 tokens/sec)\n2025-02-10 20:48:51,048 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:51,048 - INFO - Round 20 of 20.\n2025-02-10 20:48:51,667 - INFO - Generated 91 tokens in 0.62 seconds (146.98 tokens/sec)\n2025-02-10 20:48:51,668 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:51,668 - INFO - Run details saved to gpt2-rates-2025-02-10-20-48-51-668280-torch-compile-reduce-overhead-fullgraph-py313t.json.\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\n\nreal    0m19.806s\nuser    0m23.067s\nsys 0m1.336s\nException ignored in: &lt;_io.BufferedWriter name=41&gt;\nBrokenPipeError: [Errno 32] Broken pipe\n2025-02-10 20:48:57,852 - INFO - Loaded /mnt/raid1/trent/src/parallelopedia/data/model_19072.pt checkpoint in 0.472 seconds.\n2025-02-10 20:48:57,859 - INFO - Initialized GPT model in 0.007 seconds.\n2025-02-10 20:48:58,087 - INFO - Loaded model weights in 0.228 seconds.\n&lt;frozen importlib._bootstrap&gt;:488: RuntimeWarning: The global interpreter lock (GIL) has been enabled to load module 'triton._C.libtriton', which has not declared that it can run safely without the GIL. To override this behavior and keep the GIL disabled (at your own risk), run with PYTHON_GIL=0 or -Xgil=0.\n2025-02-10 20:48:58,455 - INFO - Created GPT model in 0.603 seconds.\n2025-02-10 20:48:58,540 - INFO - Moved model to cuda:3 in 0.085 seconds.\n2025-02-10 20:48:58,540 - INFO - Loaded model from step 19072, val_loss 3.0519702434539795\n2025-02-10 20:48:58,541 - INFO - Loaded gpt2 on cuda:3 in 1.161 seconds.\n2025-02-10 20:48:58,543 - INFO - torch.compiled model in 0.003 seconds.\n2025-02-10 20:48:58,543 - INFO - Round 1 of 20.\n2025-02-10 20:48:59,366 - INFO - Generated 91 tokens in 0.82 seconds (110.79 tokens/sec)\n2025-02-10 20:48:59,366 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:48:59,366 - INFO - Round 2 of 20.\n2025-02-10 20:49:00,019 - INFO - Generated 91 tokens in 0.65 seconds (139.51 tokens/sec)\n2025-02-10 20:49:00,019 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:00,019 - INFO - Round 3 of 20.\n2025-02-10 20:49:00,706 - INFO - Generated 91 tokens in 0.69 seconds (132.47 tokens/sec)\n2025-02-10 20:49:00,707 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:00,707 - INFO - Round 4 of 20.\n2025-02-10 20:49:01,327 - INFO - Generated 91 tokens in 0.62 seconds (146.66 tokens/sec)\n2025-02-10 20:49:01,328 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:01,328 - INFO - Round 5 of 20.\n2025-02-10 20:49:01,950 - INFO - Generated 91 tokens in 0.62 seconds (146.40 tokens/sec)\n2025-02-10 20:49:01,950 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:01,950 - INFO - Round 6 of 20.\n2025-02-10 20:49:02,571 - INFO - Generated 91 tokens in 0.62 seconds (146.62 tokens/sec)\n2025-02-10 20:49:02,571 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:02,571 - INFO - Round 7 of 20.\n2025-02-10 20:49:03,193 - INFO - Generated 91 tokens in 0.62 seconds (146.54 tokens/sec)\n2025-02-10 20:49:03,193 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:03,193 - INFO - Round 8 of 20.\n2025-02-10 20:49:03,816 - INFO - Generated 91 tokens in 0.62 seconds (146.13 tokens/sec)\n2025-02-10 20:49:03,816 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:03,816 - INFO - Round 9 of 20.\n2025-02-10 20:49:04,444 - INFO - Generated 91 tokens in 0.63 seconds (145.02 tokens/sec)\n2025-02-10 20:49:04,444 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:04,444 - INFO - Round 10 of 20.\n2025-02-10 20:49:05,066 - INFO - Generated 91 tokens in 0.62 seconds (146.47 tokens/sec)\n2025-02-10 20:49:05,066 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:05,066 - INFO - Round 11 of 20.\n2025-02-10 20:49:05,688 - INFO - Generated 91 tokens in 0.62 seconds (146.45 tokens/sec)\n2025-02-10 20:49:05,688 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:05,688 - INFO - Round 12 of 20.\n2025-02-10 20:49:06,310 - INFO - Generated 91 tokens in 0.62 seconds (146.37 tokens/sec)\n2025-02-10 20:49:06,311 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:06,311 - INFO - Round 13 of 20.\n2025-02-10 20:49:06,933 - INFO - Generated 91 tokens in 0.62 seconds (146.27 tokens/sec)\n2025-02-10 20:49:06,933 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:06,933 - INFO - Round 14 of 20.\n2025-02-10 20:49:07,554 - INFO - Generated 91 tokens in 0.62 seconds (146.56 tokens/sec)\n2025-02-10 20:49:07,555 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:07,555 - INFO - Round 15 of 20.\n2025-02-10 20:49:08,176 - INFO - Generated 91 tokens in 0.62 seconds (146.45 tokens/sec)\n2025-02-10 20:49:08,177 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:08,177 - INFO - Round 16 of 20.\n2025-02-10 20:49:08,799 - INFO - Generated 91 tokens in 0.62 seconds (146.39 tokens/sec)\n2025-02-10 20:49:08,799 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:08,799 - INFO - Round 17 of 20.\n2025-02-10 20:49:09,420 - INFO - Generated 91 tokens in 0.62 seconds (146.49 tokens/sec)\n2025-02-10 20:49:09,421 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:09,421 - INFO - Round 18 of 20.\n2025-02-10 20:49:10,043 - INFO - Generated 91 tokens in 0.62 seconds (146.24 tokens/sec)\n2025-02-10 20:49:10,044 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:10,044 - INFO - Round 19 of 20.\n2025-02-10 20:49:10,665 - INFO - Generated 91 tokens in 0.62 seconds (146.62 tokens/sec)\n2025-02-10 20:49:10,665 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:10,665 - INFO - Round 20 of 20.\n2025-02-10 20:49:11,286 - INFO - Generated 91 tokens in 0.62 seconds (146.54 tokens/sec)\n2025-02-10 20:49:11,286 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:11,287 - INFO - Run details saved to gpt2-rates-2025-02-10-20-49-11-287012-torch-compile-reduce-overhead-fullgraph-py313t.json.\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\n\nreal    0m19.626s\nuser    0m22.831s\nsys 0m1.406s\nException ignored in: &lt;_io.BufferedWriter name=41&gt;\nBrokenPipeError: [Errno 32] Broken pipe\n2025-02-10 20:49:17,458 - INFO - Loaded /mnt/raid1/trent/src/parallelopedia/data/model_19072.pt checkpoint in 0.491 seconds.\n2025-02-10 20:49:17,465 - INFO - Initialized GPT model in 0.006 seconds.\n2025-02-10 20:49:17,704 - INFO - Loaded model weights in 0.239 seconds.\n&lt;frozen importlib._bootstrap&gt;:488: RuntimeWarning: The global interpreter lock (GIL) has been enabled to load module 'triton._C.libtriton', which has not declared that it can run safely without the GIL. To override this behavior and keep the GIL disabled (at your own risk), run with PYTHON_GIL=0 or -Xgil=0.\n2025-02-10 20:49:18,069 - INFO - Created GPT model in 0.611 seconds.\n2025-02-10 20:49:18,153 - INFO - Moved model to cuda:3 in 0.084 seconds.\n2025-02-10 20:49:18,153 - INFO - Loaded model from step 19072, val_loss 3.0519702434539795\n2025-02-10 20:49:18,153 - INFO - Loaded gpt2 on cuda:3 in 1.187 seconds.\n2025-02-10 20:49:18,157 - INFO - torch.compiled model in 0.003 seconds.\n2025-02-10 20:49:18,157 - INFO - Round 1 of 20.\n2025-02-10 20:49:18,973 - INFO - Generated 91 tokens in 0.82 seconds (111.60 tokens/sec)\n2025-02-10 20:49:18,973 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:18,973 - INFO - Round 2 of 20.\n2025-02-10 20:49:19,621 - INFO - Generated 91 tokens in 0.65 seconds (140.58 tokens/sec)\n2025-02-10 20:49:19,621 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:19,621 - INFO - Round 3 of 20.\n2025-02-10 20:49:20,266 - INFO - Generated 91 tokens in 0.64 seconds (141.26 tokens/sec)\n2025-02-10 20:49:20,266 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:20,266 - INFO - Round 4 of 20.\n2025-02-10 20:49:20,911 - INFO - Generated 91 tokens in 0.64 seconds (141.24 tokens/sec)\n2025-02-10 20:49:20,911 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:20,911 - INFO - Round 5 of 20.\n2025-02-10 20:49:21,555 - INFO - Generated 91 tokens in 0.64 seconds (141.46 tokens/sec)\n2025-02-10 20:49:21,555 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:21,555 - INFO - Round 6 of 20.\n2025-02-10 20:49:22,199 - INFO - Generated 91 tokens in 0.64 seconds (141.27 tokens/sec)\n2025-02-10 20:49:22,200 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:22,200 - INFO - Round 7 of 20.\n2025-02-10 20:49:22,846 - INFO - Generated 91 tokens in 0.65 seconds (140.98 tokens/sec)\n2025-02-10 20:49:22,846 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:22,846 - INFO - Round 8 of 20.\n2025-02-10 20:49:23,486 - INFO - Generated 91 tokens in 0.64 seconds (142.29 tokens/sec)\n2025-02-10 20:49:23,487 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:23,487 - INFO - Round 9 of 20.\n2025-02-10 20:49:24,129 - INFO - Generated 91 tokens in 0.64 seconds (141.71 tokens/sec)\n2025-02-10 20:49:24,130 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:24,130 - INFO - Round 10 of 20.\n2025-02-10 20:49:24,771 - INFO - Generated 91 tokens in 0.64 seconds (141.83 tokens/sec)\n2025-02-10 20:49:24,772 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:24,772 - INFO - Round 11 of 20.\n2025-02-10 20:49:25,413 - INFO - Generated 91 tokens in 0.64 seconds (142.00 tokens/sec)\n2025-02-10 20:49:25,413 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:25,414 - INFO - Round 12 of 20.\n2025-02-10 20:49:26,056 - INFO - Generated 91 tokens in 0.64 seconds (141.66 tokens/sec)\n2025-02-10 20:49:26,056 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:26,057 - INFO - Round 13 of 20.\n2025-02-10 20:49:26,703 - INFO - Generated 91 tokens in 0.65 seconds (140.87 tokens/sec)\n2025-02-10 20:49:26,703 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:26,703 - INFO - Round 14 of 20.\n2025-02-10 20:49:27,344 - INFO - Generated 91 tokens in 0.64 seconds (141.96 tokens/sec)\n2025-02-10 20:49:27,345 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:27,345 - INFO - Round 15 of 20.\n2025-02-10 20:49:27,986 - INFO - Generated 91 tokens in 0.64 seconds (142.08 tokens/sec)\n2025-02-10 20:49:27,986 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:27,986 - INFO - Round 16 of 20.\n2025-02-10 20:49:28,628 - INFO - Generated 91 tokens in 0.64 seconds (141.93 tokens/sec)\n2025-02-10 20:49:28,628 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:28,628 - INFO - Round 17 of 20.\n2025-02-10 20:49:29,269 - INFO - Generated 91 tokens in 0.64 seconds (142.10 tokens/sec)\n2025-02-10 20:49:29,269 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:29,269 - INFO - Round 18 of 20.\n2025-02-10 20:49:29,913 - INFO - Generated 91 tokens in 0.64 seconds (141.43 tokens/sec)\n2025-02-10 20:49:29,913 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:29,913 - INFO - Round 19 of 20.\n2025-02-10 20:49:30,557 - INFO - Generated 91 tokens in 0.64 seconds (141.46 tokens/sec)\n2025-02-10 20:49:30,557 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:30,557 - INFO - Round 20 of 20.\n2025-02-10 20:49:31,199 - INFO - Generated 91 tokens in 0.64 seconds (141.84 tokens/sec)\n2025-02-10 20:49:31,199 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:31,200 - INFO - Run details saved to gpt2-rates-2025-02-10-20-49-31-199651-torch-compile-max-autotune-py313t.json.\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\n\nreal    0m19.900s\nuser    0m23.112s\nsys 0m1.409s\nException ignored in: &lt;_io.BufferedWriter name=41&gt;\nBrokenPipeError: [Errno 32] Broken pipe\n2025-02-10 20:49:37,383 - INFO - Loaded /mnt/raid1/trent/src/parallelopedia/data/model_19072.pt checkpoint in 0.482 seconds.\n2025-02-10 20:49:37,390 - INFO - Initialized GPT model in 0.006 seconds.\n2025-02-10 20:49:37,613 - INFO - Loaded model weights in 0.223 seconds.\n&lt;frozen importlib._bootstrap&gt;:488: RuntimeWarning: The global interpreter lock (GIL) has been enabled to load module 'triton._C.libtriton', which has not declared that it can run safely without the GIL. To override this behavior and keep the GIL disabled (at your own risk), run with PYTHON_GIL=0 or -Xgil=0.\n2025-02-10 20:49:37,976 - INFO - Created GPT model in 0.592 seconds.\n2025-02-10 20:49:38,058 - INFO - Moved model to cuda:3 in 0.082 seconds.\n2025-02-10 20:49:38,058 - INFO - Loaded model from step 19072, val_loss 3.0519702434539795\n2025-02-10 20:49:38,058 - INFO - Loaded gpt2 on cuda:3 in 1.157 seconds.\n2025-02-10 20:49:38,061 - INFO - torch.compiled model in 0.002 seconds.\n2025-02-10 20:49:38,061 - INFO - Round 1 of 20.\n2025-02-10 20:49:38,896 - INFO - Generated 91 tokens in 0.83 seconds (109.09 tokens/sec)\n2025-02-10 20:49:38,896 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:38,896 - INFO - Round 2 of 20.\n2025-02-10 20:49:39,552 - INFO - Generated 91 tokens in 0.66 seconds (138.68 tokens/sec)\n2025-02-10 20:49:39,553 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:39,553 - INFO - Round 3 of 20.\n2025-02-10 20:49:40,199 - INFO - Generated 91 tokens in 0.65 seconds (140.90 tokens/sec)\n2025-02-10 20:49:40,199 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:40,199 - INFO - Round 4 of 20.\n2025-02-10 20:49:40,851 - INFO - Generated 91 tokens in 0.65 seconds (139.61 tokens/sec)\n2025-02-10 20:49:40,852 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:40,852 - INFO - Round 5 of 20.\n2025-02-10 20:49:41,496 - INFO - Generated 91 tokens in 0.64 seconds (141.24 tokens/sec)\n2025-02-10 20:49:41,497 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:41,497 - INFO - Round 6 of 20.\n2025-02-10 20:49:42,143 - INFO - Generated 91 tokens in 0.65 seconds (140.79 tokens/sec)\n2025-02-10 20:49:42,144 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:42,144 - INFO - Round 7 of 20.\n2025-02-10 20:49:42,794 - INFO - Generated 91 tokens in 0.65 seconds (139.98 tokens/sec)\n2025-02-10 20:49:42,794 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:42,795 - INFO - Round 8 of 20.\n2025-02-10 20:49:43,442 - INFO - Generated 91 tokens in 0.65 seconds (140.59 tokens/sec)\n2025-02-10 20:49:43,442 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:43,442 - INFO - Round 9 of 20.\n2025-02-10 20:49:44,088 - INFO - Generated 91 tokens in 0.65 seconds (141.07 tokens/sec)\n2025-02-10 20:49:44,088 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:44,088 - INFO - Round 10 of 20.\n2025-02-10 20:49:44,738 - INFO - Generated 91 tokens in 0.65 seconds (140.10 tokens/sec)\n2025-02-10 20:49:44,738 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:44,738 - INFO - Round 11 of 20.\n2025-02-10 20:49:45,382 - INFO - Generated 91 tokens in 0.64 seconds (141.34 tokens/sec)\n2025-02-10 20:49:45,383 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:45,383 - INFO - Round 12 of 20.\n2025-02-10 20:49:46,026 - INFO - Generated 91 tokens in 0.64 seconds (141.47 tokens/sec)\n2025-02-10 20:49:46,027 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:46,027 - INFO - Round 13 of 20.\n2025-02-10 20:49:46,695 - INFO - Generated 91 tokens in 0.67 seconds (136.23 tokens/sec)\n2025-02-10 20:49:46,695 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:46,695 - INFO - Round 14 of 20.\n2025-02-10 20:49:47,339 - INFO - Generated 91 tokens in 0.64 seconds (141.40 tokens/sec)\n2025-02-10 20:49:47,340 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:47,340 - INFO - Round 15 of 20.\n2025-02-10 20:49:47,988 - INFO - Generated 91 tokens in 0.65 seconds (140.35 tokens/sec)\n2025-02-10 20:49:47,989 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:47,989 - INFO - Round 16 of 20.\n2025-02-10 20:49:48,649 - INFO - Generated 91 tokens in 0.66 seconds (137.84 tokens/sec)\n2025-02-10 20:49:48,649 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:48,649 - INFO - Round 17 of 20.\n2025-02-10 20:49:49,295 - INFO - Generated 91 tokens in 0.64 seconds (141.12 tokens/sec)\n2025-02-10 20:49:49,295 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:49,295 - INFO - Round 18 of 20.\n2025-02-10 20:49:49,939 - INFO - Generated 91 tokens in 0.64 seconds (141.44 tokens/sec)\n2025-02-10 20:49:49,939 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:49,939 - INFO - Round 19 of 20.\n2025-02-10 20:49:50,582 - INFO - Generated 91 tokens in 0.64 seconds (141.49 tokens/sec)\n2025-02-10 20:49:50,583 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:50,583 - INFO - Round 20 of 20.\n2025-02-10 20:49:51,232 - INFO - Generated 91 tokens in 0.65 seconds (140.31 tokens/sec)\n2025-02-10 20:49:51,232 - INFO - Output:\nEinstein's Theory of Relativity states that the speed of\nlight in a vacuum is simply the speed of the electrons in\nthat vacuum, since light has a speed. Since the speed of\nlight in a vacuum is equal to the speed of the electrons in\na solid, the light from this source has a speed of\napproximately 1/299,792 m/s. Einstein's theory of relativity\nexplains this speed by a phenomenon known as the speed at\nthe end of time. In other words, this speed is\n2025-02-10 20:49:51,232 - INFO - Run details saved to gpt2-rates-2025-02-10-20-49-51-232526-torch-compile-max-autotune-fullgraph-py313t.json.\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch.__init__: Ignoring unsupported torch.compile() with no GIL unsupported\ntorch._dynamo.eval_frame: Ignoring unsupported torch.compile() with no GIL unsupported\n\nreal    0m20.061s\nuser    0m23.272s\nsys 0m1.387s\nException ignored in: &lt;_io.BufferedWriter name=41&gt;\nBrokenPipeError: [Errno 32] Broken pipe\n\n\n\nAfter each run, a JSON file is saved capturing details about the run. These can all be found in this json directory.\nUsing gpt2-rates-2025-02-09-18-19-29-116321-py313t.json as an example:\n{\n    \"rates\": [\n        103.45683188097036,\n        133.69021647689885,\n        134.64711111769682,\n        134.99572668445947,\n        135.07252279473053,\n        134.93995013027606,\n        134.8097791019913,\n        134.97874539755563,\n        134.96994164914173,\n        134.2781961646748,\n        133.36089184927351,\n        134.91936892711604,\n        134.99927221213662,\n        134.99574871578727,\n        134.84820822748674,\n        134.90753647890656,\n        134.84542991060954,\n        134.76236728440452,\n        134.939303436755,\n        134.95605543169106\n    ],\n    \"model_config\": {\n        \"block_size\": 1024,\n        \"vocab_size\": 50304,\n        \"n_layer\": 12,\n        \"n_head\": 12,\n        \"n_embd\": 768\n    },\n    \"args\": {\n        \"log_level\": \"INFO\",\n        \"model\": \"gpt2\",\n        \"device\": \"cuda:3\",\n        \"max_length\": 100,\n        \"top_k\": 50,\n        \"seed\": 42,\n        \"prompt\": \"Einstein's Theory of Relativity states that\",\n        \"torch_compile\": false,\n        \"torch_jit\": false,\n        \"torch_compile_fullgraph\": false,\n        \"torch_compile_reduce_overhead\": false,\n        \"torch_compile_max_autotune\": false,\n        \"generate_slim\": false,\n        \"rounds\": 20,\n        \"wrap\": 60,\n        \"note\": \"\"\n    },\n    \"start_timestamp\": \"2025-02-09T18:19:14.156224\",\n    \"end_timestamp\": \"2025-02-09T18:19:29.116383\",\n    \"elapsed\": \"14.960\",\n    \"device_name\": \"Tesla V100-DGXS-32GB\",\n    \"conda_env_name\": \"py313t\",\n    \"is_gil_enabled\": false,\n    \"note\": \"\"\n}\nAll tests were done for 20 rounds, and the rates key contains an array of floats, representing the tokens/sec generation rate achieved by the call to generate() (or generate_slim(), which we’ll discuss shortly) after optionally compiling the model with the requested parameters.\n\n\nFree-Threaded Python (py313t)\nI ended up doing multiple runs because… well, as you’re about to see from the data visualization below… it was a pretty noisy test. Loads of variance and generally everything was all over the shop. The total run times for each different permutation were all about the same, around 14 seconds or so, but definitely no clear winner regarding whether or not torch.compile() or any particular permutation was having a repeatable speedup. Interesting.\nLine plots and box-plots follow. The box plots omitted the first “warmup” run (which was always slower and skewed the data unnecessarily). If you click on the image you should get a nice gallery presentation mode that allows you to flip between images nicely.\n\n   \n\n\n   \n\n\n\nNormal Python (py313)\nNormal Python (not just free-threaded Python with the GIL enabled, but full-blown old-school normal Python with no knowledge of GIL removal—i.e. our py313 environment) was pretty similar:\n\n\n\n\nGeneration Performance (py313)\n\n\n\n\n\n\n\nGeneration Performance (py313)\n\n\n\n\n\nExplicit @torch.compile Decorator\nHere’s where it gets interesting. In a final, last-ditch effort to see if I could see any sort of speedup from torch.compile(), I introduced a slimmer generate() routine, aptly named generate_slim(), which was stripped of any superfluous code that would have otherwise impeded Torch Dynamo’s ability to optimize the graph. That function looked like this:\nclass GPT:\n    ...\n\n    # @torch.compile\n    def generate_slim(\n        self, text_tokens: torch.Tensor, max_length: int = 1024,\n        top_k: int = 50, seed: int = None,\n    ) -&gt; str:\n        \"\"\"\n        Generate text from the model.  This version differs from\n        `generate()` in that it does not use any Python code that\n        causes a torch graph break.\n\n        Args:\n\n            text (str): Supplies the prompt.\n\n            max_length (int): Supplies the maximum total length,\n                including prompt.\n\n            top_k (int): Supplies the number of tokens to consider\n                at each generation step.\n\n            seed (int): Ignored!\n\n        Returns:\n\n            str: The generated text (including the initial prompt).\n        \"\"\"\n        # Initialize alias.\n        device = self.device\n        stop_token = self.stop_token\n\n        # Create the tensor for capturing predicted tokens.\n        x = torch.tensor(\n            text_tokens,\n            dtype=torch.long,\n            device=device\n        ).unsqueeze(0)\n\n        # Create a random generator for reproducibility.\n        # sample_rng = torch.Generator(device=device)\n        # if seed is None:\n        #     seed = self.manual_seed\n        # sample_rng.manual_seed(seed)\n\n        # Generate tokens up to our max length.\n        for _ in range(max_length):\n            with torch.no_grad():\n                # Forward pass, ignoring the returned loss.\n                (logits, _) = self(x)\n\n            # Take the logits at the last time-step (shape:\n            # (1, vocab_size)).\n            logits = logits[:, -1, :]\n\n            # Convert to probabilities.\n            probs = F.softmax(logits, dim=-1)\n\n            # Top-k sampling.\n            topk_probs, topk_indices = torch.topk(\n                probs, k=top_k, dim=-1,\n            )\n\n            # Sample the next token.\n            next_idx = torch.multinomial(\n                topk_probs,\n                num_samples=1,\n                # generator=sample_rng,\n            )\n            next_token = torch.gather(topk_indices, -1, next_idx)\n\n            # If the next token is the stop token, we're done.\n            # next_token_item = next_token.item()\n            # if next_token_item == stop_token:\n            #    break\n\n            # Append token to current sequence.\n            x = torch.cat((x, next_token), dim=1)\n\n        return x\nNote that we had to make a number of sizable modifications. No more random number generator—that was causing graph breaks. No more explicitly checking for the stop token, again, that makes the dynamic optimizer’s job much harder at runtime without extra tracing overhead for tracking scalars. So we now generate tokens up to the maximum specified, ignorant of any stop tokens, and return that.\nI wanted to do two runs here, one where we call everything as normal with all the different torch.compile() invocations we’d used in prior runs, and then a second one where I explicitly mark the generate_slim() routine with a @torch.compile decorator.\nThe latter absolutely does not work in free-threaded Python, it segfaults after about ten seconds or so, thus, I couldn’t test it.\nHowever, on the normal Python version… we finally saw some interesting results.\nFirst, let’s look at our baseline: normal generate_slim() with no @torch.compile generator (the bash scripts verify that the decorator is uncommented and commented as necessary):\n\n\n\n\nGeneration Performance - generate_slim() - No @torch.compile Decorator (py313)\n\n\n\n\n\n\n\nGeneration Performance - generate_slim() - No @torch.compile Decorator (py313)\n\n\n\nWell we finally see one configuration break out from the pack: apparently torch.compile(model, {'fullgraph': True}) yielded the best generation rate we’ve seen yet, hovering around 160 tokens/sec. Note that all the total run times are still pretty similar, hovering around that 14-15s mark.\nNow, let’s uncomment the @torch.compile decorator above def generate_slim() and do another full run:\n\n\n\n\nGeneration Performance - generate_slim() - With @torch.compile Decorator (py313)\n\n\n\n\n\n\n\nGeneration Performance - generate_slim() - With @torch.compile Decorator (py313)\n\n\n\nOh man. That first compilation took forever. But once compiled, our tokens/sec generation rate shoots up significantly to the 250+ range instead of the 150+ range! But at a crazy up-front cost—as you can see with all of the run times (the values in parenthesis in the labels and x-axis in first and second plots, respectively) were in excess of four minutes.\nAs we’re only doing twenty runs of generating ~90-100 characters, that startup cost is brutal, however, if we were doing model training or launching a long-running inference service like our HTTP server, the startup cost would be quickly amortized away as we benefit from about a 75% speedup.\nSo, interesting stuff, kind of. To be fair… PyTorch clearly indicates free-threaded Python isn’t supported, per our hacks earlier, so, this should be an interesting area of development in future releases, especially now that we can see how much benefit there is to doing multi-threaded run-time inference in a single Python process."
  },
  {
    "objectID": "articles/pytorch-and-python-free-threading/index.html#footnotes",
    "href": "articles/pytorch-and-python-free-threading/index.html#footnotes",
    "title": "PyTorch and Python Free-Threading",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nI used 0.23.3, as that was the latest version available at the time, however, 0.23.4 has since been released, so you could try that too.↩︎\nAnd I’m sure I used the existing Python stdlib http.server code at the time as the basis; ain’t nobody got time to be writing new web servers from scratch.↩︎\nUnfortunately, it doesn’t appear to work on Windows as-is; using the exact same code, only one thread can be seen running when the server is loaded. It’s not doing a round-robin between all threads, like you’d expect to see with the GIL enabled, there’s just a single sole thread attempting to service all incoming requests, with all other threads sitting idle. I don’t know if it’s because of something quirky with regards to additional, non-main-thread threads not getting their own event loop (hopefully easy to fix), or something more insidious related to how we’re misuing I/O completion ports behind the scenes in IocpProactor() now that we have free-threading (much harder to fix). I haven’t had time to investigate in more detail.↩︎"
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Projects & Repositories",
    "section": "",
    "text": "PerfectHash\nTracer\nPyParallel (GitHub)"
  },
  {
    "objectID": "projects/index.html#recent",
    "href": "projects/index.html#recent",
    "title": "Projects & Repositories",
    "section": "",
    "text": "PerfectHash\nTracer\nPyParallel (GitHub)"
  },
  {
    "objectID": "projects/index.html#not-so-recent",
    "href": "projects/index.html#not-so-recent",
    "title": "Projects & Repositories",
    "section": "Not So Recent",
    "text": "Not So Recent\n\nEnversion\nCQ Python\nPersonal Python Library ‘tpn’"
  },
  {
    "objectID": "tools/index.html",
    "href": "tools/index.html",
    "title": "Tools",
    "section": "",
    "text": "Intel Intrinsics Guide\n\nIntel Intrinsics Guide.\n\n\n\nOak Ridge National Laboratory CUDA Training Series\n\nCUDA Training Series\nPDFs of the slides"
  }
]